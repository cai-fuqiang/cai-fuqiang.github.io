<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>one step at a time</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2025-09-25T23:44:43+08:00</updated> <author> <name>fuqiang wang</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2025 fuqiang wang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>schedule: Directory</title><link href="/posts/eevdf-paper/" rel="alternate" type="text/html" title="schedule: Directory" /><published>2025-09-15T21:40:00+08:00</published> <updated>2025-09-15T21:40:00+08:00</updated> <id>/posts/eevdf-paper/</id> <content src="/posts/eevdf-paper/" /> <author> <name>fuqiang</name> </author> <category term="schedule" /> <category term="paper" /> <summary>eevdf 公式推导 [\begin{align} V(e) &amp;amp;amp;= V(t^i_0) + \frac{s_i(t^i_0, t)}{w_i} \tag {7} V(d) &amp;amp;amp;= V(e) + \frac{r}{w_i} \tag {8} \end{align}] If the client uses each time the entire service time it has requested, (7) and (8) we obtain the following reccurence which computes both the virtual eligible time and the virtual deadline of each request: [\begin{align} ve^{(1)} &amp;amp;amp;= V(t_0^i) \tag{9}...</summary> </entry> <entry><title>schedule: weight</title><link href="/posts/sched-weight/" rel="alternate" type="text/html" title="schedule: weight" /><published>2025-09-11T22:16:00+08:00</published> <updated>2025-09-11T22:16:00+08:00</updated> <id>/posts/sched-weight/</id> <content src="/posts/sched-weight/" /> <author> <name>fuqiang</name> </author> <category term="schedule" /> <summary>weight 计算公式 Linux weight 和 nice 有一个对应关系, 具体的公式为: x为nice y为weight [\begin{align} NICE_0_weigth = 1024 , x \in [-20,19] f(x) = NICE_0_weight * \frac{1}{1.25^x} \end{align}] 在kernel 代码中静态保存这个关系的数组: /* * Nice levels are multiplicative, with a gentle 10% change for every * nice level changed. I.e. when a CPU-bound task goes from nice 0 to * nice 1, it will get ~10% less CPU time than anothe...</summary> </entry> <entry><title>[论文翻译] Lottery and Stride Scheduling: Flexible Proportional-Share Resource Management</title><link href="/posts/stride_sched_paper/" rel="alternate" type="text/html" title="[论文翻译] Lottery and Stride Scheduling: Flexible Proportional-Share Resource Management" /><published>2025-09-05T22:18:00+08:00</published> <updated>2025-09-05T22:18:00+08:00</updated> <id>/posts/stride_sched_paper/</id> <content src="/posts/stride_sched_paper/" /> <author> <name>fuqiang</name> </author> <category term="schedule" /> <category term="paper" /> <summary>Chapter 2 Resource Management Framework This chapter presents a general, flexible framework for specifying resource management policies in concurrent systems. Resource rights are encapsulated by abstract, first-class objects called tickets. Ticket-based policies are expressed using two basic techniques: ticket transfers and ticket inflation. Ticket transfers allow resource rights to be directl...</summary> </entry> <entry><title>[arm] RMM</title><link href="/posts/RMM/" rel="alternate" type="text/html" title="[arm] RMM" /><published>2025-09-03T15:31:00+08:00</published> <updated>2025-09-03T15:31:00+08:00</updated> <id>/posts/RMM/</id> <content src="/posts/RMM/" /> <author> <name>fuqiang</name> </author> <category term="coco" /> <category term="RMM" /> <summary>overflow RMM 是一个系统软件（固件）器和 RME (hardware extension) 一起构成实现了 ARM Confidential Compute Architecture(CCA) 用来提供受保护的可执行环境 Realms. Confidential Computing Armv8-A 通过建立了如下图的权限层次结构: 该层次结构的逻辑是，让高权限等级去管理权限异常等级使用的资源，并且资源管理和访问 权限是绑定在一起的。 举个例子: EL2&amp;amp;amp;1 中 EL2 用来分配为EL1分配物理页，在 EL1&amp;amp;amp;0 中EL1为EL0分配虚拟机认为 的物理页。并且低权限等级不能访问高权限等级的资源: guest user space(el0) 不能访问 guest kernel (el1)的内存，guest kernel (el1) 不能访问hos...</summary> </entry> <entry><title>schedule: overflow</title><link href="/posts/sched/" rel="alternate" type="text/html" title="schedule: overflow" /><published>2025-09-02T22:00:00+08:00</published> <updated>2025-09-02T22:00:00+08:00</updated> <id>/posts/sched/</id> <content src="/posts/sched/" /> <author> <name>fuqiang</name> </author> <category term="schedule" /> <summary>调度子系统的任务: 调度程序负责决定运行哪个程序，该程序运行多长时间。 调度系统的责任很明确, 需要在不富裕的CPU上，合理的运行所有程序。目前的cpu架构决定, 在一个core上, 同一时间只能有一个task运行, 所以调度子系统会决定当前cpu运行某个进 程，并且让其他进程等待, 在合适的时机，将cpu上的进程调出，运行下一个合适的进程， 依次循环。 所以调度系统是建立在多任务的基础上构建, 我们可以设想下, 如果将来某一天，体系架构 从根本上变了, – CPU &amp;amp;gt;&amp;amp;gt; task number, Linus本人可能要执行rm -rf kernel/sched。 schedule system type 而这种多任务的调度系统分为两类: 非抢占式 抢占式 非抢占式是指在前一个任务未主动退出之前，调度子系统不会将另一个该任务踢出，运行另 一个任...</summary> </entry> </feed>
