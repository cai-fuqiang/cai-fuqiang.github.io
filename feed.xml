<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>one step at a time</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2024-11-13T00:10:05+08:00</updated> <author> <name>fuqiang wang</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 fuqiang wang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>auto-converge</title><link href="/posts/dirty-ring/" rel="alternate" type="text/html" title="auto-converge" /><published>2024-11-12T23:20:00+08:00</published> <updated>2024-11-12T23:20:00+08:00</updated> <id>/posts/dirty-ring/</id> <content src="/posts/dirty-ring/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="autoconverge" /> <summary>NONE</summary> </entry> <entry><title>auto-converge</title><link href="/posts/auto-converge/" rel="alternate" type="text/html" title="auto-converge" /><published>2024-11-12T23:20:00+08:00</published> <updated>2024-11-12T23:20:00+08:00</updated> <id>/posts/auto-converge/</id> <content src="/posts/auto-converge/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="autoconverge" /> <summary>简介 在大型机器，并且系统负载高时热迁移，工作负载往往比热迁移速度更快，从而导致 live migration无法 converge. 这个往往受限于bandwidth, 虽然现在网卡的带宽越来越高。但是虚拟机的核心数量 以及cpu主频，内存带宽也在逐渐增大。 Chegu Vinod 在 2013 年提出了 auto-converge, （但是的场景即使使用了10Gig NICs也仍然NOT converge). 所以，他提出了该方案，来限制脏页产生速度，也就是 简单粗暴的限制vcpu的”频率”, (让vcpu线程sleep). 我们来看下该patch 的 commit message: Busy enterprise workloads hosted on large sized VM&amp;#39;s tend to dirty memory faster than the trans...</summary> </entry> <entry><title>[Translate]: Migration auto-converge problem</title><link href="/posts/Migration-auto-converge-problem/" rel="alternate" type="text/html" title="[Translate]: Migration auto-converge problem" /><published>2024-11-12T23:20:00+08:00</published> <updated>2024-11-12T23:20:00+08:00</updated> <id>/posts/Migration-auto-converge-problem/</id> <content src="/posts/Migration-auto-converge-problem/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="auto-converge" /> <summary>From: &amp;quot;Jason J. Herne&amp;quot; &amp;amp;lt;jjherne@linux.vnet.ibm.com&amp;amp;gt; To: &amp;quot;qemu-devel@nongnu.org qemu-devel&amp;quot; &amp;amp;lt;qemu-devel@nongnu.org&amp;amp;gt;, Christian Borntraeger &amp;amp;lt;borntraeger@de.ibm.com&amp;amp;gt; Subject: [Qemu-devel] Migration auto-converge problem Date: Mon, 02 Mar 2015 16:04:54 -0500 We have a test case that dirties memory very very quickly. When we run this test case in a guest and attempt a migration,...</summary> </entry> <entry><title>auto-converge</title><link href="/posts/live-migration-workflow/" rel="alternate" type="text/html" title="auto-converge" /><published>2024-11-12T23:20:00+08:00</published> <updated>2024-11-12T23:20:00+08:00</updated> <id>/posts/live-migration-workflow/</id> <content src="/posts/live-migration-workflow/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <summary>热迁移简述 热迁移(live migration) 可以在虚拟机正在RUNNING时，对用户透明的从 source host 迁移到dest host. 涉及迁移对象种类 热迁移的流程会大概包含几个对象: cpu 内存 设备 主要工作 而热迁移主要工作是将这几个对象的信息，从原端 copy到目的端，并且 做好sync工作。 由于不停机vm，vcpu还会更改一些对象状态。例如: 内存，可能在迁移完 一个page后，该page由于vcpu还在跑, 有可能又有更改。这时，qemu还需要 track到该page，并完成对该page的再一次的迁移。 如何做到避免在热迁移过程中影响vcpu 迁移线程和vcpu线程是不同线程, 所以热迁移时，q...</summary> </entry> <entry><title>Mem</title><link href="/posts/mem/" rel="alternate" type="text/html" title="Mem" /><published>2024-10-16T00:00:00+08:00</published> <updated>2024-10-16T00:00:00+08:00</updated> <id>/posts/mem/</id> <content src="/posts/mem/" /> <author> <name>fuqiang wang</name> </author> <summary>struct 内存初始化流程 初始化MemoryRegion main =&amp;amp;gt; qemu_init =&amp;amp;gt; qemu_create_machine =&amp;amp;gt; qmp_x_exit_preconfig =&amp;amp;gt; qemu_init_board =&amp;amp;gt; machine_run_board_init =&amp;amp;gt; create_default_memdev(current_machine, mem_path, errp) =&amp;amp;gt; user_creatable_complete =&amp;amp;gt; host_memory_backend_memory_complete =&amp;amp;gt; ram_back...</summary> </entry> </feed>
