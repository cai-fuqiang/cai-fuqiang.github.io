<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>one step at a time</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2024-11-25T22:49:48+08:00</updated> <author> <name>fuqiang wang</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 fuqiang wang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Dirty Rate</title><link href="/posts/dirty-rate/" rel="alternate" type="text/html" title="Dirty Rate" /><published>2024-11-25T00:00:00+08:00</published> <updated>2024-11-25T00:00:00+08:00</updated> <id>/posts/dirty-rate/</id> <content src="/posts/dirty-rate/" /> <author> <name>fuqiang wang</name> </author> <summary>dirty rate calc-dirty-rate 整体流程 qmp_calc_dirty_rate =&amp;amp;gt; qemu_thread_create(,MIGRATION_THREAD_DIRTY_RATE, get_dirtyrate_thread,,) (get_dirtyrate_thread) =&amp;amp;gt; dirtyrate_set_state(,,DIRTY_RATE_STATUS_MEASURING) =&amp;amp;gt; calculate_dirtyrate() =&amp;amp;gt; switch(mode) =&amp;amp;gt; DIRTY_RATE_MEASURE_MODE_DIRTY_BITMAP =&amp;amp;gt; calculate_dirtyrate_dirty_bitmap ...</summary> </entry> <entry><title>guestperf</title><link href="/posts/guestperf/" rel="alternate" type="text/html" title="guestperf" /><published>2024-11-20T15:27:00+08:00</published> <updated>2024-11-20T15:27:00+08:00</updated> <id>/posts/guestperf/</id> <content src="/posts/guestperf/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="test" /> <summary>guestperf代码分析 参考链接 https://blog.csdn.net/huang987246510/article/details/114379675?spm=1001.2014.3001.5501</summary> </entry> <entry><title>kernel PML</title><link href="/posts/kernel-pml/" rel="alternate" type="text/html" title="kernel PML" /><published>2024-11-19T09:50:00+08:00</published> <updated>2024-11-19T09:50:00+08:00</updated> <id>/posts/kernel-pml/</id> <content src="/posts/kernel-pml/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="kernel pml" /> <summary>PML &amp;amp;amp;&amp;amp;amp; WP PML 和 WP 起到的作用是一样的，只不过PML可以达到一种batch WP的效果: PML index始终指向 next PML entry, 每次record PML时，PML index 会dec, 并且check --PML_index的值, 是否在[0, 511]范围之内. 当PML index=0时， 如果此时再record PML, 则会触发--pml_index=0xffff, PML index 则不在 [0, 511], 此时会broken当前的write 操作，并VM-exit。 PML table大小为4096, 每一个entry 大小为8-byte, 保存着 dirty page的PFN. 其中，红色绿色， 两次write 操作在执行时，不会触发VM-exit，而是在write操作过程中，如果 需要di...</summary> </entry> <entry><title>dirty-ring</title><link href="/posts/dirty-ring/" rel="alternate" type="text/html" title="dirty-ring" /><published>2024-11-12T23:20:00+08:00</published> <updated>2024-11-12T23:20:00+08:00</updated> <id>/posts/dirty-ring/</id> <content src="/posts/dirty-ring/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="dirty-ring" /> <summary>示意图: 参考资料 KVM: Dirty ring interface Peter Xu 2020 https://lore.kernel.org/all/20201023183358.50607-1-peterx@redhat.com/</summary> </entry> <entry><title>dirty-bitmap</title><link href="/posts/kvm-dirty_bitmap/" rel="alternate" type="text/html" title="dirty-bitmap" /><published>2024-11-12T23:20:00+08:00</published> <updated>2024-11-12T23:20:00+08:00</updated> <id>/posts/kvm-dirty_bitmap/</id> <content src="/posts/kvm-dirty_bitmap/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="dirty-bitmap" /> <summary>ORG PATCH 我们来看下最初的KVM实现了哪些功能。最初的KVM代码，是基于shadow page table, 支持了dirty_bitmap. 我们从几个方面看下dirty_bitmap实现: kernel data struct USER API lock Contention Analysis kernel data struct 并支持了dirty_bitmap, 同样是定义在了memslot结构体中，每个slot一个 dirty_bitmap struct kvm_memory_slot { gfn_t base_gfn; unsigned long npages; unsigned long flags; struct page **phys_mem; uns...</summary> </entry> </feed>
