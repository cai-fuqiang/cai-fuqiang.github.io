<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Chirpy</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2026-01-15T09:19:41+08:00</updated> <author> <name>your_full_name</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2026 your_full_name </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>rcu - rcu hierarchical</title><link href="/posts/rcu-hierarchical/" rel="alternate" type="text/html" title="rcu - rcu hierarchical" /><published>2026-01-13T20:44:00+08:00</published> <updated>2026-01-13T20:44:00+08:00</updated> <id>/posts/rcu-hierarchical/</id> <content type="text/html" src="/posts/rcu-hierarchical/" /> <author> <name>fuqiang</name> </author> <category term="os" /> <category term="synchronization" /> <summary>NOTE 代码流程笔记 代码静态初始化 rcu_state: struct rcu_state rcu_state = RCU_STATE_INITIALIZER(rcu_state); #define RCU_STATE_INITIALIZER(name) { \ //只初始化level[0] .level = { &amp;amp;name.node[0] }, \ //初始化 levelcnt .levelcnt = { \ NUM_RCU_LVL_0, /* root of hierarchy. */ \ NUM_RCU_LVL_1, \ NUM_RCU_LVL_2, \ NUM_RCU_LVL_3, /* == MAX_RCU_LVLS */ \ }, \ }, ...</summary> </entry> <entry><title>rcu - rcu latency optimization</title><link href="/posts/rcu-latency-optimization/" rel="alternate" type="text/html" title="rcu - rcu latency optimization" /><published>2026-01-12T22:13:00+08:00</published> <updated>2026-01-12T22:13:00+08:00</updated> <id>/posts/rcu-latency-optimization/</id> <content type="text/html" src="/posts/rcu-latency-optimization/" /> <author> <name>fuqiang</name> </author> <category term="os" /> <category term="synchronization" /> <summary>overflow rcu callback 往往用来释放内存, 如果rcu callback调用的延迟比较高, 就会造成较高的 内存占用. 所以减少rcu callback的调用延迟也是一个很重要的优化方向。 ORG PATCH 在最初的版本中, rcu_data中存放了两个链表 rcu_data-&amp;gt;nxtlist: 调用call_rcu() 向该链表存放数据 rcu_data-&amp;gt;curlist: 当rcu_check_callbacks()检测到nxtlist有成员但是 curlist没有成员时，会将nxtlist 中的链表成员移动到cur_list中, 并且发起一个 新的宽限期用来处理curlist中的数据。 两个链表均为 list_head数据结构，详细请看: rcu - classic list_head为双向链表，大小为2 * sizeo...</summary> </entry> <entry><title>rcu - stalled grace peroiod detection</title><link href="/posts/rcu-stall-dettection/" rel="alternate" type="text/html" title="rcu - stalled grace peroiod detection" /><published>2026-01-12T10:00:00+08:00</published> <updated>2026-01-12T10:00:00+08:00</updated> <id>/posts/rcu-stall-dettection/</id> <content type="text/html" src="/posts/rcu-stall-dettection/" /> <author> <name>fuqiang</name> </author> <category term="os" /> <category term="synchronization" /> <summary>rcu, debug: detect stalled grace periods 67182ae1c42206e516f7efb292b745e826497b24 Paul E. McKenney paulmck@linux.vnet.ibm.com Sun Aug 10 18:35:38 2008 -0700 rcu: RCU-based detection of stalled CPUs for Classic RCU 2133b5d7ff531bc15a923db4a6a50bf96c561be9 Paul E. McKenney paulmck@linux.vnet.ibm.com Thu Oct 2 16:06:39 2008 -0700</summary> </entry> <entry><title>sequence counters and sequential locks</title><link href="/posts/seqcounter-and-seqlock/" rel="alternate" type="text/html" title="sequence counters and sequential locks" /><published>2026-01-07T16:35:00+08:00</published> <updated>2026-01-07T16:35:00+08:00</updated> <id>/posts/seqcounter-and-seqlock/</id> <content type="text/html" src="/posts/seqcounter-and-seqlock/" /> <author> <name>fuqiang</name> </author> <category term="os" /> <category term="synchronization" /> <summary>introduce Definination of sequence: In mathematics, a sequence is an infinite list $x_1, x_2, x_3$, … (Sometimes finite lists are also called sequence) 2 大概的意思是序列是一个无限列表。而counter的含义是一个计数器。计数器的特点是 计数前后的差值为1。那么 sequence counter 的特点是, $0,1,2,3 …$ 这样的一个 列表。 sequence counters/locks 是一种 reader-writer consistency mechanism, 特点是 lockless readers(read-only retry loops), 不会有写饥饿。 ...</summary> </entry> <entry><title>rcu - classic</title><link href="/posts/rcu-classic/" rel="alternate" type="text/html" title="rcu - classic" /><published>2026-01-05T10:00:00+08:00</published> <updated>2026-01-05T10:00:00+08:00</updated> <id>/posts/rcu-classic/</id> <content type="text/html" src="/posts/rcu-classic/" /> <author> <name>fuqiang</name> </author> <category term="os" /> <category term="synchronization" /> <summary>本文主要讲解 经典rcu (classical rcu) 历史. 在介绍具体实现之前, 我们先明确几个概 念: quiescent state: 该CPU 上运行的所有 RCU 读取端临界区都已完成1 grace period: rcu 删除分为三部分, emoval ,Grace Period, and Reclamation. 宽限期 结束以所有cpu rcu 读临界区完成, 即所有cpu 都经历一次 quiescent state rcu callback: 某些rcu writer将释放动作封装为一个rcu_head, 通过调用 call_rcu()注册回调，允许异步执行释放动作。 rcu处理流程的关键点是: 如何发现新的rcu callback, 发起一个新的宽限期 如何判定该宽限期结束, 调用相关rcu callback 如下图所示...</summary> </entry> </feed>
