<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Chirpy</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2025-12-26T20:53:33+08:00</updated> <author> <name>your_full_name</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 your_full_name </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>history of scalable spinlock</title><link href="/posts/history-of-scalable-spinlock/" rel="alternate" type="text/html" title="history of scalable spinlock" /><published>2025-12-26T11:00:00+08:00</published> <updated>2025-12-26T11:00:00+08:00</updated> <id>/posts/history-of-scalable-spinlock/</id> <content type="text/html" src="/posts/history-of-scalable-spinlock/" /> <author> <name>fuqiang</name> </author> <category term="synchronization" /> <summary>自旋锁是一种会让尝试获取它的线程陷入循环 （“自旋”）并不断检查锁是否可用的锁 1。 和mutex 不同，mutex 可以睡眠，将cpu让渡给其他的程序，而自旋锁则是占据着cpu资源忙 等。忙等最主要的有点时，避免了调度所带来的上下文开销, 可以提升等锁进程获得锁的延 迟。另外，如果加锁的临界区很小，自旋锁忙等所带来的开销，可能会小于上下文切换的开 销，自旋锁的收益就会非常大。所以，自旋锁适用于临界区小的场景。 overflow 本文主要是来讲述, spinlock 的可伸缩性(scalable). 可扩展性是指系统处理不断增长的 工作量的能力。软件系统的可扩展性定义之一是，可以通过向系统添加资源来实现 2. 而对于spinlock而言, 如何增加其工作量呢？ 增加并行调用spinlock的cpu 在介绍之前我们先思考下，自旋锁和 “smp”, “up” 关系3。首先按照自...</summary> </entry> <entry><title>non-blocking algorithm</title><link href="/posts/overflow/" rel="alternate" type="text/html" title="non-blocking algorithm" /><published>2025-12-25T10:00:00+08:00</published> <updated>2025-12-25T10:00:00+08:00</updated> <id>/posts/overflow/</id> <content type="text/html" src="/posts/overflow/" /> <author> <name>fuqiang</name> </author> <category term="synchronization" /> <summary>在计算机科学中，如果任何线程的故障或挂起不会导致其他线程的故障或挂起，则称该算法 为非阻塞算法1。根据非阻塞算法的达到效果，可以分为两类: wait-free: if there is also guaranteed per-thread progress lock-free: if there is guaranteed system-wide progress Obstruction-free: 只要某个线程能独占执行（其他线程不干扰），该线程的操作必在有限步骤内完成。 pre-thread progress vs system-wide progress progress的意思是进展。system-wide表示整个程序或者整个系统，而pre-thread要求每 个thread. 拿CAS来说, 可能某个thread在非常多次交换中都失败，但...</summary> </entry> <entry><title>qemu coroutine</title><link href="/posts/coroutine/" rel="alternate" type="text/html" title="qemu coroutine" /><published>2025-02-25T11:00:00+08:00</published> <updated>2025-02-25T11:00:00+08:00</updated> <id>/posts/coroutine/</id> <content type="text/html" src="/posts/coroutine/" /> <author> <name>fuqiang</name> </author> <category term="qemu" /> <category term="coroutine" /> <summary>Introduction Linux User Context Switch qemu coroutine 协程状态机 CREATE and INIT enter switch yield Use Case for QEMU Introduction 多线程和协程都可以用于并行编程，但是他们实现方式和使用场景 有很大的区别，我们来对比下: 对比项 协程 多线程 实现方式 在用户态单线程中，完成上下文切换 内核态完成上下文切换 开销 开销较低 线程创建销毁，以及切换都需要进入内核态，开销较高 ...</summary> </entry> <entry><title>qspinlock</title><link href="/posts/qspinlock/" rel="alternate" type="text/html" title="qspinlock" /><published>2023-09-11T10:00:00+08:00</published> <updated>2023-09-11T10:00:00+08:00</updated> <id>/posts/qspinlock/</id> <content type="text/html" src="/posts/qspinlock/" /> <author> <name>fuqiang</name> </author> <category term="synchronization" /> <summary>简介 内核中的自旋锁是互斥锁。而内核中的自旋锁经过多个版本的演进， 最终是在 mcs 自旋锁 算法之上，根据kernel 本身的需求，作了改进。 我们这里不去回顾 Linux 自旋锁的历史，简单介绍下 mcs 自旋锁算法， 并详细讲解 kernel 中的 mcs自旋锁的变体。 NOTE 如果想要了解 kernel 自旋锁的演进，可以看下 深入理解Linux内核之自旋锁 1 该文章详细讲解了kernel自旋锁的演进，并通过举例子 的方式，讲解了各个算法（包括最新的算法），十分值 得看, 本文主要分析kernel 最新的 自旋锁算法。 MCS 自旋锁 MCS 自旋锁是在为了解决票号自旋锁带来的 cache line bouncing2, 实现了一个队列，使其各自自旋各自的地址, 而不是自旋一个地址，这样就 解决了这个问题。 NOTE 1 这个...</summary> </entry> </feed>
