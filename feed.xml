<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>one step at a time</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2025-01-22T00:03:38+08:00</updated> <author> <name>fuqiang wang</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2025 fuqiang wang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>qemu brige migration</title><link href="/posts/pci_bridge/" rel="alternate" type="text/html" title="qemu brige migration" /><published>2025-01-21T23:02:00+08:00</published> <updated>2025-01-21T23:02:00+08:00</updated> <id>/posts/pci_bridge/</id> <content src="/posts/pci_bridge/" /> <author> <name>fuqiang</name> </author> <category term="qemu" /> <category term="pci_bridge" /> <summary>PCI bridge dev vmstate static const VMStateDescription pci_bridge_dev_vmstate = { .name = &amp;quot;pci_bridge&amp;quot;, .priority = MIG_PRI_PCI_BUS, .fields = (VMStateField[]) { VMSTATE_PCI_DEVICE(parent_obj, PCIBridge), SHPC_VMSTATE(shpc, PCIDevice, pci_device_shpc_present), VMSTATE_END_OF_LIST() } }; 而pci_bridge type为: static const TypeInfo pci_bridge_type_info = {...</summary> </entry> <entry><title>time</title><link href="/posts/time/" rel="alternate" type="text/html" title="time" /><published>2024-12-20T22:19:00+08:00</published> <updated>2024-12-20T22:19:00+08:00</updated> <id>/posts/time/</id> <content src="/posts/time/" /> <author> <name>fuqiang</name> </author> <category term="time" /> <summary>参考链接 We Are Not Getting Any Younger: A New Approach to Time and Timers</summary> </entry> <entry><title>apic timer</title><link href="/posts/setup-apic-timer/" rel="alternate" type="text/html" title="apic timer" /><published>2024-12-20T10:10:00+08:00</published> <updated>2024-12-20T10:10:00+08:00</updated> <id>/posts/setup-apic-timer/</id> <content src="/posts/setup-apic-timer/" /> <author> <name>fuqiang</name> </author> <category term="timer" /> <category term="apic-timer" /> <summary>setup timer boot cpu start_kernel =&amp;amp;gt; time_init(); =&amp;amp;gt; choose early clocksource in [hpet, pm, pit] to calibrate_tsc ## 以hpet计算tsc 为例 ## 这里主要是因为hpet/pit/pm频率是确定的，但是tsc ## 频率不确定, 需要用其他的clocksource来计算下 =&amp;amp;gt; cpu_khz = hpet_calibrate_tsc(); =&amp;amp;gt; ((tsc_delta) * 1000000000L) / hpet_delta * =&amp;amp;gt; enable early timer =&amp;amp;gt; setup_irq(0, &amp;amp;amp;irq0...</summary> </entry> <entry><title>kvm stats</title><link href="/posts/kvm-stats/" rel="alternate" type="text/html" title="kvm stats" /><published>2024-11-29T21:17:00+08:00</published> <updated>2024-11-29T21:17:00+08:00</updated> <id>/posts/kvm-stats/</id> <content src="/posts/kvm-stats/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="kvm stats" /> <summary>背景 我们如果对一个只启动bios的虚拟机做热迁移，发现其实际迁移的数据量不大， 如下: qemu 参数: # src qemu-system-x86_64 -m 16G --nographic --enable-kvm --serial tcp:localhost:6666,server,nowait --monitor stdio # dst: qemu-system-x86_64 --incoming tcp:xxxx:9000 -m 16G --nographic --enable-kvm 执行热迁移命令: (qemu) migrate -d tcp:xxxx:9000 (qemu) info migrate globals: store-global-state: on only-migratable: off send-configuration: on sen...</summary> </entry> <entry><title>dirty-rate calc</title><link href="/posts/dirty-rate/" rel="alternate" type="text/html" title="dirty-rate calc" /><published>2024-11-25T11:00:00+08:00</published> <updated>2024-11-25T11:00:00+08:00</updated> <id>/posts/dirty-rate/</id> <content src="/posts/dirty-rate/" /> <author> <name>fuqiang</name> </author> <category term="live_migration" /> <category term="dirty_rate" /> <summary>calc-dirty-rate 整体流程 qmp_calc_dirty_rate =&amp;amp;gt; qemu_thread_create(,MIGRATION_THREAD_DIRTY_RATE, get_dirtyrate_thread,,) (get_dirtyrate_thread) =&amp;amp;gt; dirtyrate_set_state(,,DIRTY_RATE_STATUS_MEASURING) =&amp;amp;gt; calculate_dirtyrate() =&amp;amp;gt; switch(mode) =&amp;amp;gt; DIRTY_RATE_MEASURE_MODE_DIRTY_BITMAP =&amp;amp;gt; calculate_dirtyrate_dirty_bitmap =&amp;amp;gt; ...</summary> </entry> </feed>
