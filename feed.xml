<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Chirpy</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2025-12-25T18:18:29+08:00</updated> <author> <name>your_full_name</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 your_full_name </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>non-blocking algorithm</title><link href="/posts/overflow/" rel="alternate" type="text/html" title="non-blocking algorithm" /><published>2025-12-25T10:00:00+08:00</published> <updated>2025-12-25T10:00:00+08:00</updated> <id>/posts/overflow/</id> <content type="text/html" src="/posts/overflow/" /> <author> <name>fuqiang</name> </author> <category term="synchronization" /> <summary>在计算机科学中，如果任何线程的故障或挂起不会导致其他线程的故障或挂起，则称该算法 为非阻塞算法1。根据非阻塞算法的达到效果，可以分为两类: wait-free: if there is also guaranteed per-thread progress lock-free: if there is guaranteed system-wide progress Obstruction-free: 只要某个线程能独占执行（其他线程不干扰），该线程的操作必在有限步骤内完成。 pre-thread progress vs system-wide progress progress的意思是进展。system-wide表示整个程序或者整个系统，而pre-thread要求每 个thread. 拿CAS来说, 可能某个thread在非常多次交换中都失败，但...</summary> </entry> <entry><title>qemu coroutine</title><link href="/posts/coroutine/" rel="alternate" type="text/html" title="qemu coroutine" /><published>2025-02-25T11:00:00+08:00</published> <updated>2025-02-25T11:00:00+08:00</updated> <id>/posts/coroutine/</id> <content type="text/html" src="/posts/coroutine/" /> <author> <name>fuqiang</name> </author> <category term="qemu" /> <category term="coroutine" /> <summary>Introduction Linux User Context Switch qemu coroutine 协程状态机 CREATE and INIT enter switch yield Use Case for QEMU Introduction 多线程和协程都可以用于并行编程，但是他们实现方式和使用场景 有很大的区别，我们来对比下: 对比项 协程 多线程 实现方式 在用户态单线程中，完成上下文切换 内核态完成上下文切换 开销 开销较低 线程创建销毁，以及切换都需要进入内核态，开销较高 ...</summary> </entry> <entry><title>qspinlock</title><link href="/posts/qspinlock/" rel="alternate" type="text/html" title="qspinlock" /><published>2023-09-11T10:00:00+08:00</published> <updated>2023-09-11T10:00:00+08:00</updated> <id>/posts/qspinlock/</id> <content type="text/html" src="/posts/qspinlock/" /> <author> <name>fuqiang</name> </author> <category term="synchronization" /> <summary>简介 内核中的自旋锁是互斥锁。而内核中的自旋锁经过多个版本的演进， 最终是在 mcs 自旋锁 算法之上，根据kernel 本身的需求，作了改进。 我们这里不去回顾 Linux 自旋锁的历史，简单介绍下 mcs 自旋锁算法， 并详细讲解 kernel 中的 mcs自旋锁的变体。 NOTE 如果想要了解 kernel 自旋锁的演进，可以看下 深入理解Linux内核之自旋锁 该文章详细讲解了kernel自旋锁的演进，并通过举例子 的方式，讲解了各个算法（包括最新的算法），十分值 得看, 本文主要分析kernel 最新的 自旋锁算法。 MCS 自旋锁 MCS 自旋锁是在为了解决票号自旋锁带来的 cache 抖动的问题1, 实现了一个队列，使其各自自旋各自的地址, 而不是自旋一个地址，这样就 解决了这个问题。 NOTE 1 这里提到的缓存抖动，大...</summary> </entry> </feed>
