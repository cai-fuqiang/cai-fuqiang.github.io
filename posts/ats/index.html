<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="ats" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /><meta property="og:description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /><link rel="canonical" href="/posts/ats/" /><meta property="og:url" content="/posts/ats/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-03-31T11:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ats" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2025-03-31T11:00:00+08:00","datePublished":"2025-03-31T11:00:00+08:00","description":"A minimal, responsive and feature-rich Jekyll theme for technical writing.","headline":"ats","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/ats/"},"url":"/posts/ats/"}</script><title>ats | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>ats</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>ats</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1743390000" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Mar 31, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="8255 words" > <em>45 min</em> read</span></div></div></div></header><div class="content"><style> blockquote { font-family: Arial, sans-serif; /* 修改字体 */ color: gray; /* 修改颜色 */ font-size: 13px; border-left: 5px solid orange; /* 修改左边框颜色 */ padding-left: 10px; /* 左侧内边距 */ margin: 10px 0; /* 上下外边距 */ } blockquote blockquote { font-weight: bold; }</style><h1 id="ats-specification">ATS Specification</h1><h1 id="101-ats-architectural-overview">10.1 ATS Architectural Overview</h1><p>Most contemporary system architectures make provisions for translating addresses from DMA (bus mastering) I/O Functions. In many implementations, it has been common practice to assume that the physical address space seen by the CPU and by an I/O Function is equivalent. While in others, this is not the case. The address programmed into an I/O Function is a “handle” that is processed by the Root Complex (RC). The result of this processing is often a translation to a physical memory address within the central complex. Typically, the processing includes access rights checking to insure that the DMA Function is allowed to access the referenced memory location(s).</p><blockquote><p>大部分现代系统架构对I/O Functions 的DMA (bus mastering)的地址转换作了规定. 在 许多实现中, 通常的做法是假定CPU 和I/O Fucntions看到的是相同的物理地址空间. 而 在其他情况下并非如此. 编程到 I/O Function 中的地址是一个由 Root Complex 处理的 ‘句柄’. 这种处理的结果通常是将其转换为 central complex 内的物理内存地址。通常， 这个处理包括访问权限检查，以确保 DMA Function 被允许访问引用的内存位置。</p></blockquote><p>The purposes for having DMA address translation vary and include:</p><ul><li>Limiting the destructiveness of a “broken” or miss-programmed DMA I/O Function<li>Providing for scatter/gather<li>Ability to redirect message-signaled interrupts (e.g., MSI or MSI-X) to different address ranges without requiring coordination with the underlying I/O Function<li>Address space conversion (32-bit I/O Function to larger system address space)<li>Virtualization support</ul><blockquote><p>进行DMA address translation的不同的目的包括</p><ul><li>限制”broken”或者误编程的DMA I/O Function的破坏性<li>提供给 scatter/gather使用<li>能够将message-signaled interrupts(例如:MSI/MSIx)重定向到不同的<li>地址范围,并且不需要和下层的I/O Function协调<li>地址空间的转换(将32-bit I/O Function转换成更大的系统地址空间)<li>虚拟化支持</ul><blockquote><ul><li>destructiveness: 破坏性，毁灭性</ul></blockquote></blockquote><p>Irrespective of the motivation, the presence of DMA address translation in the host system has certain performance implications for DMA accesses.</p><blockquote><p>不管动机如何, 主机系统中的DMA address translation的存在会造成DMA access时有一 定的性能影响</p><blockquote><p>irrespective: 无论, 不考虑</p></blockquote></blockquote><p>Depending on the implementation, DMA access time can be significantly lengthened due to the time required to resolve the actual physical address. If an implementation requires access to a main-memory-resident translation table, the access time can be significantly longer than the time for an untranslated access. Additionally, if each transaction requires multiple memory accesses (e.g., for a table walk), then the memory transaction rate (i.e., overhead) associated with DMA can be high.</p><blockquote><p>根据实现情况,DMA access的时间会因为解析实际的物理地址而显著增长. 如果实现中需 要访问main-memory-resident(主存中驻留)的地址转换表, 访问的时间可能比不经过翻译 的访问时间长的多.此外,如果每个transaction需要 multiple memory access(例如 for a table work), 则和DMA相关的内存事务率(即开销) 可能会很高</p></blockquote><p>To mitigate these impacts, designs often include address translation caches in the entity that performs the address translation. In a CPU, the address translation cache is most commonly referred to as a translation look-aside buffer (TLB). For an I/O TA, the term address translation cache or ATC is used to differentiate it from the translation cache used by the CPU.</p><blockquote><p>为了减轻这些影响, 设计时通常在执行地址转换的实体中包含地址转换缓存. 在CPU 中, 地址转换缓存最常见之的是 translation look-aside buffer(TLB). 对于I/O TA, 使用 术语address translation cache 或者ATC 来区分CPU使用的地址转换缓存</p><blockquote><p>entity: 实体</p></blockquote></blockquote><p>While there are some similarities between TLB and ATC, there are important differences. A TLB serves the needs of a CPU that is nominally running one thread at a time. The ATC, however, is generally processing requests from multiple I/O Functions, each of which can be considered a separate thread. This difference makes sizing an ATC difficult depending upon cost models and expected technology reuse across a wide range of system configurations.</p><blockquote><p>虽然对于TLB和ATC之间有一些相似点, 但是也有很大的不同之处. 一个翻译后备缓冲区 （TLB）满足CPU的需求，CPU通常一次运行一个线程。而ATC通常处理来自于muliple I/O Functions,他们中的每个都可以被认为是一个单独的thread. 这种差异使得根据成本模型 和预期技术在各种系统配置中重复使用的情况下，确定地址转换缓存（ATC）的大小变得 困难。</p></blockquote><p>The mechanisms described in this specification allow an I/O Device to participate in the translation process and provide an ATC for its own memory accesses. The benefits of having an ATC within a Device include:</p><ul><li>Ability to alleviate TA resource pressure by distributing address translation caching responsibility (reduced probability of “thrashing” within the TA)<li>Enable ATC Devices to have less performance dependency on a system’s ATC size<li>Potential to ensure optimal access latency by sending pretranslated requests to central complex</ul><blockquote><p>本规范中描述的机制允许I/O设备参与地址转换过程，并为其自身的内存访问提供地址转 换缓存（ATC）。在设备内部拥有ATC的好处包括: 在Device中有ATC的好处包括:</p><ul><li>能够通过分配address trasnlation cache(ATC)责任来缓解 TA资源方面的压力(减少TA中的”thrashing(抖动)”的可能性)<li>使ATC devices减少对系统ATC size的性能依赖<li>通过将预翻译的请求发送到 central complex ，确保最佳访问延迟的潜力。</ul></blockquote><p>This specification will provide the interoperability that allows PCIe Devices to be used in conjunction with a TA, but the TA and its Address Translation and Protection Table (ATPT) are treated as implementation-specific and are outside the scope of this specification. While it may be possible to implement ATS within other PCIe Components, this specification is confined to PCIe Devices and PCIe Root Complex Integrated Endpoints (RCiEPs).</p><blockquote><p>本规范将提供互操作性，使PCIe设备能够与翻译代理（TA）一起使用，但TA及其地址转换 和保护表（ATPT）被视为特定于实现的内容，不在本规范的范围之内。虽然可以在其他的 PCIe 组件中实现ATS, 但是本规范仅限于PCIe Devices和PCIe Root Complex Integrated Endpoints. (RCiEPs)</p></blockquote><p>Figure 10-1 illustrates an example platform with a TA and ATPT, along with a set of PCIe Devices and RC Integrated Endpoints with integrated ATC. A TA and an ATPT are implementation-specific and can be distinct or integrated components within a given system design.</p><blockquote><p>图10-1举例说明了一个带有TA和ATPT的平台, 并带有一些PCIe Devices和RC Integrated Endpoints with integrated ATC.TA和ATPT是 implementation-specific并且在给定的系统 设计中是不同的或者集成的组件</p></blockquote><p><img src="pic/eg_platform_with_ta.png" alt="带TA的例子" /></p><blockquote class="prompt-info"><p>总结:</p><ul><li>在现代架构中, CPU 和 I/FUNCTIONS 可能因为IOMMU 组件做DMA address translation, 导致两者view 不同<li>DMA address translation 有很多好处，其中一点是虚拟化<li>DMA address translation 会带来很多额外的开销，就像CPU 的page table walk一样, 所以本章节主要是定义了一套规范, 来实现类似于CPU 侧的TLB。具体的方法是:<ul><li>PCIe endpoint 硬件提供address translation cache<li>通过下面章节中描述的协议来完成该cache的同步</ul></ul></blockquote><h1 id="1011-address-translation-services-ats-overview">10.1.1 Address Translation Services (ATS) Overview</h1><p>The ATS chapter provides a new set of TLP and associated semantics. ATS uses a request-completion protocol between a Device<sup>1</sup> and a Root Complex (RC) to provide translation services. In addition, a new AT field is defined within the Memory Read and Memory Write TLP. The new AT field enables an RC to determine whether a given request has been translated or not via the ATS protocol.</p><blockquote><p>ATS这个章节提供了一组新的TLP和相关的概念.ATS在Device[1]和Root Complex(RC)之间 使用一种request-completion协议来确保 translation services. 此外,在Memory Read 和 Memory Write TLP中提供了一个新的AT字段. 这个新的AT字段使RC 确定给定的 request是否通过ATS协议进行了translate</p></blockquote><p>Figure 10-2 illustrates the basic flow of an ATS Translation Request operation</p><blockquote><p>Figure 10-2 描述了ATS Translation Request主要的操作流程</p></blockquote><p><img src="pic/ATS_T_R.png" alt="10-2" /></p><p>In this example, a Function-specific work request is received by a single-Function PCIe Device. The Function determines through an implementation-specific method that caching a translation within its ATC would be beneficial. There are a number of considerations a Function or software can use in making such a determination; for example:</p><ul><li><p>Memory address ranges that will be frequently accessed over an extended period of time or whose associated buffer content is subject to a significant update rate</p><li><p>Memory address ranges, such as work and completion queue structures, data buffers for low-latency communications, graphics frame buffers, host memory that is used to cache Function-specific content, and so forth</p></ul><blockquote><p>在这个示例中，single-function PCIe Device 接收到一个 Function-specific 工作请 求。该 single-function 通过一种实现特定的方法确定在其 ATC 中缓存一个转换是有益 的。在做出这种判断时，single-function 或软件可以考虑多个因素；例如：</p><ul><li>该内存地址段在一段时间内被频繁访问,或者相关的buffer内容处于一个很高的更新频 率<li>该内存地址段是例如工作和完成队列数据结构,低延迟通信的data buffers, 图形帧缓 冲区用于缓存 Function-specific内容的内存等等</ul></blockquote><p>The Function generates an ATS Translation Request which is sent upstream through the PCIe hierarchy to the RC which then forwards it to the TA. An ATS Translation Request uses the same routing and ordering rules as defined in this specification. Further, multiple ATS Translation Requests can be outstanding at any given time; i.e., one may pipeline multiple requests on one or more TC. Each TC represents a unique ordering domain and defines the domain that must be used by the associated ATS Translation Completion.</p><blockquote><p>Function生成了一个ATS Translation Request, 该 Request发送到upstream,该过程通过 PCIe 层级到RC, 该RC接下来将转发到TA. 该ATS Translation Request使用和本规范中定 义的相同的routing 和 ordering 规则. 此外，在任何给定时间可以存在多个 ATS 转换 请求；例如,一个 pipeline multiple requests可能需要一个或多个TC.每个TC代表一个 唯一的顺序域, 并定义关联的ATS翻译完成必须使用的域即，可以在一个或多个传输通道 （TC）上对多个请求进行流水线处理。每个 TC 代表一个唯一的排序域，并定义与之相关 的 ATS 转换完成所必须使用的域。</p><blockquote><ul><li>further: 此外, 通常用于表示更进一步的内容、额外的信息或更深层次的解释<li>outstanding: 未解决的, 未处理的</ul></blockquote></blockquote><blockquote class="prompt-info"><p>总结:</p><ol><li>ATS 在Device 和 RC 之间定义了一个 request-competion 的一个协议, 另外, Memory Read/Write 相关的TLP 中也新增了一个AT字段<li>往往需要设备来判断哪些request需要用ATS。（往往是一些访问频繁的，或者对 延迟要求较高的)<li>关于这些新增加的 ATS translation request, 其路由和排序规则和其他TLP一样。 另外，TA这边会pipeline 多个 request，这些request 被 分到不同的TC中，每个 TC是一个ordering domain.</ol></blockquote><p>Upon receipt of an ATS Translation Request, the TA performs the following basic steps:</p><ol><li>Validates that the Function has been configured to issue ATS Translation Requests.<li>Determines whether the Function may access the memory indicated by the ATS Translation Request and has the associated access rights.<li>Determines whether a translation can be provided to the Function. If yes, the TA issues a translation to the Function.<ol><li>ATS is required to support a variety of page sizes to accommodate a range of ATPT and processor implementations.<ul><li>Page sizes are required to be a power of two and naturally aligned.<li>The minimum supported page size is 4096 bytes. ATS capable components</ul><li>A Function must be informed of the minimum translation or invalidate size it will be required to support to provide the Function an opportunity to optimize its resource utilization. The smallest minimum translation size must be 4096 bytes.</ol><li><p>The TA communicates the success or failure of the request to the RC which generates an ATS Translation Completion and transmits via a Response TLP through a RP to the Function.</p><ol><li>An RC is required to generate at least one ATS Translation Completion per ATS Translation Request;i.e., there is minimally a 1:1 correspondence independent of the success or failure of the request.<ul><li>A successful translation can result in one or two ATS Translation Completion TLPs per request. The Translation Completion indicates the range of translation covered.<li>An RC may pipeline multiple ATS Translation Completions; i.e., an RC may return multiple ATS Translation Completions and these ATS Translation Completions may be in any order relative to ATS Translation Requests.<li>The RC is required to transmit the ATS Translation Completion using the same TC (Traffic Class) as the corresponding ATS Translation Request.</ul><li>The requested address may not be valid. The RC is required to issue a Translation Completion indicating that the requested address is not accessible.</ol></ol><blockquote><p>当收到一个ATS Translation Request, TA 执行下面的主要步骤:</p><ol><li>验证这个Function已经被配置为 可以提交 ATS Translation Requests.<li>确定 Function 是否可以访问 ATS Translation Request 指示的内存并具有相关的访 问权限。<li>确定可以向该Function 提供 translation. 如果可以, TA 将为该Function 提交一个 translation<ol><li>ATS 需要支持各种页面大小以适应一系列 ATPT(Address Translation and Page Table) 和处理器实现。<ul><li>页面大小必须是2的幂,并自然对齐<li>支持的page size的最小值是4096字节. ATS capable 组件需要支持此最小页面 的大小</ul><li>必须告知功能它需要支持的最小translation/invalidate 大小，以便为function 提供优化其资源利用的机会。最小的转换大小必须为 4096 字节。</ol><li><p>TA需要告诉RC 该请求的结果是成功还是失败, 该RC会产生一个ATS Translation Completion并且通过RP(root port??) 向Fucntion发送一个 Response TLP</p><ol><li>RC需要为每个ATS Translation Request 生成至少一个ATS Translation Completion; 也就是说, 至少存在1:1的对应关系, 与request的成功失败无关<ul><li>一个成功执行的translation可以为每个request回应一条或两条 ATS Translation Completion. Translation Completion表明了 translation 的范 围.<li><p>RC 可以对多个 ATS 转换完成进行流水线处理；即，RC 可以返回多个 ATS Trnaslation Completion，这些 ATS Translation Completion 相对于 ATS Translation Request 可以是任意顺序。</p><li>RC 必须使用与相应的 ATS Translation Request 相同的 TC来传输 ATS Translation Completion.</ul><li>请求的地址可能无效。RC 必须发出一个 Translation Completion，指示请求的地 址不可访问。</ol></ol></blockquote><p>When the Function receives the ATS Translation Completion and either updates its ATC to reflect the translation or notes that a translation does not exist. The Function proceeds with processing its work request and generates subsequent requests using either a translated address or an untranslated address based on the results of the Completion.</p><ul><li>Similar to Read Completions, a Function is required to allocate resource space for each completion(s) without causing backpressure on the PCIe Link.<li>A Function is required to discard Translation Completions that might be “stale”. Stale Translation Completions can occur for a variety of reasons.</ul><blockquote><p>当一个Function收到了ATS Translation Completion并且更新了这个translation 对应的 ATC或者发现这个translation不存在. (TA page table work broken). 该 Function 继 续处理他的工作请求并且接下来产生的请求根据 Completion的结果使用已经翻译过的地 址或者未翻译的地址</p><ul><li>和Read Completions相似, Function需要在当前PCIe link不产生backpressure 的情况 下, 为每个compleions分配resource space<li>Function 需要丢弃已经”stale”(实效的)Translation Completions. Stale translation Completion可能由于不同的原因产生</ul></blockquote><p>As one can surmise, ATS Translation Request and Translation Completion processing is conceptually similar and, in many respects, identical to PCIe Read Request and Read Completion processing. This is intentional to reduce design complexity and to simplify integration of ATS into existing and new PCIe-based solutions. Keeping this in mind, ATS requires the following:</p><ul><li>ATS capable components must interoperate with [PCIe-1.1] compliant components.<li>ATS is enabled through a new Capability and associated configuration structure. To enable ATS, software must detect this Capability and enable the Function to issue ATS TLP. If a Function is not enabled, the Function is required not to issue ATS Translation Requests and is required to issue all DMA Read and Write Requests with the TLP AT field set to “untranslated”.<li>ATS TLPs are routed using either address-based or Requester ID (RID) routing.<li>ATS TLPs are required to use the same ordering rules as specified in this specification.<li>ATS TLPs are required to flow unmodified through [PCIe-1.1] compliant Switches.<li>A Function is permitted to intermix translated and untranslated requests.<li>ATS transactions are required not to rely upon the address field of a memory request to communicate additional information beyond its current use as defined by the PCI-SIG.</ul><blockquote><p>可以推测，ATS 翻译请求和翻译完成的处理在概念上与 PCIe Read Request 和 Read completion 的处理相似，并且在许多方面是相同的。这种设计是有意为之，以降低设计 复杂性并简化 ATS 在现有和新的基于 PCIe 的解决方案中的集成。考虑到这一点，ATS 要求如下：</p><ul><li>支持 ATS 的组件必须能够与符合 [PCIe-1.1] 标准的组件进行互操作。<li><p>ATS 需要通过一个新的 Capability 和相关的configuration structure 来启用该功能. 为了enable ATS, 软件必须识别这个 Capability 并且使能该 Function 来提交 ATS TLP. 如果一个Function 没有 enable, Function 不能提交 ATS Translation Request 并且提交的 DMA Read 和 Write Request 的TLP 中的AT field 需要设置成 “untranslated”</p><li>ATS TLPs 可以通过 address-based 或者 Requester ID (RID) 路由<li>ATS TLPs 需要 未经修改的通过[PCIe-1.1] compliant Switches.<li>Function 允许去混合 translated 和 untranslated request<li>要求 ATS translation 不依赖内存请求的地址字段传递当前PCI-SIG之外 的额外信息</ul></blockquote><blockquote><p>IMPLEMENTATION NODE</p><blockquote><p>Adress Range Overlap</p><blockquote><p>It is likely that the untranslated and translated address range will overlap, perhaps in their entirety. This is not a requirement of ATS but may be an implementation constraint on the TA so that memory requests will be properly routed.</p><p>未翻译和已翻译的地址范围很可能会重叠，甚至可能完全重叠。这并不是 ATS 的要 求，但可能是 TA（翻译代理）在实现上的限制，以确保内存请求能够被正确路由。</p></blockquote></blockquote></blockquote><p>In contrast to the prior example, Figure 10-3 illustrates an example Multi-Function Device. In this example Device, there are three Functions. Key points to note in Figure 10-3 are:</p><ul><li><p>Each ATC is associated with a single Function. Each ATS-capable Function must be able to source and sink at least one of each ATS Translation Request or Translation Completion type.</p><li><p>Each ATC is configured and accessed on a per Function basis. A Multi-Function Device is not required to implement ATS on every Function.</p><li><p>If the ATC implementation shares resources among a set of Functions, then the logical behavior is required to be consistent with fully independent ATC implementations.</p></ul><blockquote><p>对比前一个例子, Figure 10_3 举例说明了一个Multi-Function Device. 在这个例子中 的Device, 有三个Functions. Figure 10-3 需要注意的关键点如下:</p><ul><li>每个ATC和一个单独的Function相关. 每个ATS-capable Function 必须能够去source and sick至少 ATS Translation Request 或 Translation Completion 一种<li><p>每个ATC都基于每个Function进行配置和访问. 一个 Multi-Function设备不需要在每个 Function上</p><li>如果 ATC 实现在一组功能之间共享资源，则逻辑行为需要与完全独立的 ATC 实现一致。</ul></blockquote><p><img src="pic/muti_func_dev.png" alt="Figure_10_3" /></p><p>Independent of the number of Functions within a Device, the following are required:</p><ul><li>A Function is required not to issue any TLP with the AT field set unless the address within the TLP was obtained through the ATS Translation Request and Translation Completion protocol.<li>Each ATC is required to only be populated using the ATS protocol; i.e., each entry within the ATC must be filled via an ATS Translation Completion in response to the Function issuing an ATS Translation Request for a given address.<li>Each ATC cannot be modified except through the ATS protocol. That is:<ul><li>Host system software cannot modify the ATC other than through the protocols defined in this specification except to invalidate one or more translations in an ATC. A Device or Function reset would be an example of an operation performed by software to change the contents of the ATC, but a reset is only allowed to invalidate entries not modify their contents.<li>It must not be possible for host system software to use software executing on the Device to modify the ATC.</ul></ul><blockquote><p>无论设备中有多少个 Function，都需要满足以下要求:</p><ul><li><p>Function不需要提交带有AT字段的TLP除非这个TLP中的address通过 ATS Translation Request 和Translation Completion 协议获取过</p><li>ATC必须仅通过 ATS 协议进行填充；也就是说，ATC 中的每个条目都必须通过 ATS 翻译完成来填充，这是对 Function 发出的特定地址的 ATS 翻译请求的响应<li>每一个ATC 不能被修改,除非通过ATS protocol.<ul><li>Host 系统软件只能通过该规范中的定义的协议来修改ATC, 除非去invalidate 一个 或多个ATC中的 translations. Device 或者Function Reset操作将会是一个由 software 去改变ATC内容的例子,但是reset操作只能能允许去invalidate entries 但是不能modify他们的内容<li>主机系统软件不能通过在设备上运行的软件来修改ATC。</ul></ul></blockquote><p>When a TA determines that a Function should no longer maintain a translation within its ATC, the TA initiates the ATS invalidation protocol. The invalidation protocol consists of a single Invalidation Request and one or more Invalidate Completions.</p><blockquote><p>当TA判定某个功能不应再在其ATC中维护某个translation时，TA 会启动 ATS Invalidation protocol invailidation. invailidate protocol 由一个 Invalidation Request 和一个或多个 Invalidate Completions组成</p></blockquote><p><img src="pic/10-4.png" alt="10-4" /></p><p>As Figure 10-4 illustrates, there are essentially three steps in the ATS Invalidation protocol:</p><blockquote><p>如10-4图所示, ATS Invalidate protocol 基本上包含三个步骤</p></blockquote><ol><li><p>The system software updates an entry in the tables used by the TA. After the table is changed, the TA determines that a translation should be invalidated in an ATC and initiates an Invalidation Request TLP which is transmitted from the RP to the example single-Function Device. The Invalidate Request communicates an untranslated address range, the TC, and an RP unique tag which is used to correlate Invalidate Completions with the Invalidation Request.</p><blockquote><p>system software更新了一个entry, 而这个entry恰好被TA使用. 在这个table被改变 后,TA判定对应的translation应该在ATC中被 invailidated并且发起一个 Invalidation Request TLP,该TLP从 RP传达到例子中的single-Function Device.该 Invalidate Request 传递了一个 untranslated address range, TC, 和一个 RP unique tag, 该tag用来把 Invalidate Completions 和 Invalidation Request 关联 起来</p></blockquote><li><p>The Function receives the Invalidate Request and invalidates all matching ATC entries. A Function is not required to immediately flush all pending requests upon receipt of an Invalidate Request. If transactions are in a queue waiting to be sent, it is not necessary for the Function to expunge requests from the queue even if those transactions use an address that is being invalidated.</p><blockquote><p>该function收到了Invalidate Request并且无效了所有对应的ATC entries. 在收到 Invalidate Request 后, function 不需要立即flush 所有pending的 requests.如果 一个 transactions 正在队列中等待发送, 则该function没有必要从队列中删除请求, 即使这些事务使用的address正在被 invailidated</p></blockquote><ul><li><p>A Function is required not to indicate the invalidation has completed until all outstanding Read Requests or Translation Requests that reference the associated translated address have been retired or nullified.</p><blockquote><p>A Function 必须确保，只有在所有引用相关翻译地址的未完成 Read Requests 或 Translation Requests 都已完成或取消后，才能指示invalidation 已经完成。</p></blockquote><li><p>A Function is required to ensure that the Invalidate Completion indication to the RC will arrive at the RC after any previously posted writes that use the “stale” address.</p><blockquote><p>Function需要保证 发送到RC的 Invalidate Completion 到达RC之前, 之前任何的 posted writes都必须使用 “stale”(老的,旧的) 地址</p></blockquote></ul><li><p>When a Function has ascertained that all uses of the translated address are complete, it issues one or more ATS Invalidate Completions.</p><blockquote><p>当该function 确定了所用这个translated address相关请求都已经complete, 他会提 交1个或多个ATS Invalidate Completions</p></blockquote><ul><li><p>An Invalidate Completion is issued for each TC that may have referenced the range invalidated. These completions act as a flush mechanism to ensure the hierarchy is cleansed of any in-flight transactions which may contain references to the translated address.</p><blockquote><p>为每个引用了无效范围的TC发出 Invalidate Completion. 这些 completions 充当 了一个flush 机制来保证 hierarchy已经清除了任何可能包含translated address 的正在处理的事物</p></blockquote><ul><li><p>The number of Completions required is communicated within each Invalidate Completion. A TA or RC implementation can maintain a counter to ensure that all Invalidate Completions are received before considering the translation to no longer be in use.</p><blockquote><p>每个Invalidate Completion 都会包含Completions的数量.TA或者RC的实现中会包 含一个计数器来确保在认为这个translation 没有人在使用之前, 所有的 Invalidate Completions都已经收到.</p></blockquote><li><p>If more than one Invalidation Complete is sent, the Invalidate Completion sent in each TC must be identical in the fields detailed in Section 10.3.2 .</p><blockquote><p>如果多个 Invalidate Complete 发出, 每个TC 发出的Invalidate Completion 需 要和 Section 10.3.2中描述的字段保持一致</p></blockquote></ul><li><p>An Invalidate Completion contains the ITAG from Invalidate Request to enable the RC to correlate Invalidate Requests and Completions.</p><blockquote><p>Invalidate Completion 中包含来自于 Invalidate Request 中的ITAG 来保证 RC可 以将这些 Invalidate Request和 Completion 联系起来</p></blockquote></ul></ol><h1 id="1012-page-request-interface-extension">10.1.2 Page Request Interface Extension</h1><p>ATS improves the behavior of DMA based data movement. An associated Page Request Interface (PRI) provides additional advantages by allowing DMA operations to be initiated without requiring that all the data to be moved into or out of system memory be pinned. The overhead associated with pinning memory may be modest, but the negative impact on system performance of removing large portions of memory from the pageable pool can be significant.</p><blockquote><p>ATS 改善了基于 DMA 的数据移动行为。相关的页面请求接口（PRI）通过允许在不需要将 所有数据固定到系统内存中的情况下启动 DMA 操作，提供了额外的优势。(感觉这里是说, 不需要所有的内存请求的地址都是 present的). pinning memory相关的开销可能不明显, 但是从pageable pool 中删除大量的内存对系统性能负面影响可能很大.</p><p>Page able????</p></blockquote><p>PRI is functionally independent of the other aspects of ATS. That is, a device that supports ATS need not support PRI, but PRI is dependent on ATS’s capabilities.</p><blockquote><p>PRI 在功能方面是独立于 ATS 其他部分. 展开来说, 一个设备支持ATS 不一定支持PRI, 但是 PRI 依赖 ATS的capabilitis</p></blockquote><p>Intelligent I/O devices can be constructed to make good use of a more dynamic memory interface. Pinning will always have the best performance characteristics from a device’s perspective-all the memory it wants to touch is guaranteed to be present. However, guaranteeing the residence of all the memory a device might touch can be problematic and force a sub-optimal level of device awareness on a host. Allowing a device to operate more independently (to page fault when it requires memory resources that are not present) provides a superior level of coupling between device and host.</p><font color="gray" face="黑体" size="2"> 可以构建智能 I/O 设备以充分利用更动态的内存接口。从设备的全视角来看, Pining 总是会有更高的性能特性 -- 该设备想要touch 的内存需要保证present. 但是, 保证设备可能touch的所有内存都present可能是有问题的,并且会对host device awareness 水平强制处于 sub-optimal. 允许设备操作来更加独立(当他 需要的内存资源不是present的时候,会触发一个page fault)在设备和主机之间 提供了更高级别(更良好)的耦合. (降低了耦合性, 或者说host对于device不需 要增加一些特殊的管理了) </font><p>The mechanisms used to take advantage of a Page Request Interface are very device specific. As an example of a model in which such an interface could improve overall system performance, let us examine a high-speed LAN device. Such adevice knows its burst rate and need only have as much physical buffer space available for inbound data as it can receive within some quantum. A vector of unpinned virtual memory pages could be made available to the device, that the device then requests as needed to maintain its burst window. This minimizes the required memory footprint of the device and simplifies the interface with the host, both without negatively impacting performance.</p><font color="gray" face="黑体" size="2"> 利用 Page Request Interface 的机制实现是非常特定于设备的. 让我们来 参考一个高速的LAN 设备, 作为例子模型来展示像这样的一个接口可以提高系统 整体的性能.这样的一个设备指导它的burst rate(突发速率,最大速率)并且只 需要为在一定范围内它可以接受的数据提供尽可能多的物理buffer空间. 可以向 设备提供一个不固定的虚拟内存页的vector(也就是所有的page不一定是pinned, 可能不是present，可能present，但是指向的physical page不同)， 之后设备 需要维护他的 burst windows. 这将最小化设备所需的内存占用，简化与主机 的接口，并且两者不会产生性能方面的负面影响. </font><p>The ability to page, begs the question of page table status flag management. Typical TAs associate flags (e.g., dirty and access indications) with each untranslated address. Without any additional hints about how to manage pages mapped to a Function, such TAs would need to conservatively assume that when they grant a Function permission to read or write a page, that Function will use the permission. Such writable pages would need to be marked as dirty before their translated addresses are made available to a Function.</p><font color="gray" face="黑体" size="2"> 对于page来说，该 ability回避了page table status flag 管理的问题。 典型的TA 会将flags(eg. dirty &amp;&amp; access 标志位)和每个未翻译的address 联系起来。如果没有关于如何管理映射到function页面的额外的指示, 这些TAs 需要谨慎的假设当他们授予一个function去读写一个page 权限, 这些function 将会使用这些权限.(当function 去write, 那么认为该page就有write的权限). 这些可写页面需要在translated address 提供给function之前, 需要标记成 脏页 </font><p>This conservative dirty-on-write-permission-grant behavior is generally not a significant issue for Functions that do not support paging, where pages are pinned and the cost of saving a clean page to memory will seldom be paid. However, Functions that support the Page Request Interface could pay a significant penalty if all writable pages are treated as dirty, since such Functions operate without pinning their accessible memory footprints and may issue speculative page requests for performance. The cost of saving clean pages (instead of just discarding them) in such systems can diminish the value of otherwise attractive paging techniques. This can cause significant performance issues and risk functional issues in circumstances where the backing store is unable to be written, such as a CD-ROM.</p><font color="gray" face="黑体" size="2"> 对于不支持paging的function来说, 保守的 dirty-on-write-permission-grant行为 通常不会是一个重要问题, 其中固定页面在保存clean page到内存中将花费很少 代价. 但是支持 Page Request Interface 的function可能会付出比较大的代价 ,如果所有的可写入的page都被对待为dirty的话,因为这些function不会固定他们要 访问的内存空间并且可能会有一些预测性质的 page request 来提高性能(预读). 在无法写入后段存储(例如 CD-ROM) 的情景下, 可能会导致严重的性能问题 以及可能会造成一些安全问题(risk functional issues) </font><p>The No Write (NW) flag in Translation Requests indicates that a Function is willing to restrict its usage to only reading the page, independent of the access rights that would otherwise have been granted.</p><font color="gray" face="黑体" size="2"> Translation Requests NO Write (NW) flag 表明function将其使用限制 为仅读取页面，而与原本授予的访问权限无关。 </font><p>If a device chooses to request only read access by issuing a Translation Request with the NW flag Set and later determines that it needs to write to the page, then the device must issue a new Translation Request.</p><font color="gray" face="黑体" size="2"> 如果 device 通过发出带有 NW flag 的 Translation Request 来提交只读请求 ,然而之后决定需要去写这个page, 这样的话,device 必须发出一个新的 Translation Request </font><p>Upon receiving a Translation Request with the NW flag Clear, TAs are permitted to mark the associated pages dirty. It is strongly recommended that Functions not issue such Requests unless they have been given explicit write permission. An example of write permission is where the host issues a command to a Function to load data from a storage device and write that data into memory.</p><font color="gray" face="黑体" size="2"> 当受到一个不带 NW flag的 Translation Request, TAs 允许去标记相关的 page 为dirty . 强烈建议function 不要发出这样的请求,除非他们已经获得了 明确的写入权限.写入权限的一个例子是, 当主机提交了给function一个 从 storage device 中 load data的cmd并且将该数据写入内存 </font><h1 id="1013-process-address-space-id-pasid">10.1.3 Process Address Space ID (PASID)</h1><p>Certain TLPs can optionally be associated with a Process Address Space ID (PASID). This value is conveyed using the PASID TLP Prefix. The PASID TLP Prefix is defined in the Section 6.20 .</p><font color="gray" face="黑体" size="2"> 某些TLPs 可以选择性的带有 Process Address Space ID (PASID).该值 通过 PASID TLP Prefix(前缀)标识. PASID TLP Prefix 在Section 6.20 中定义 </font><p>The PASID TLP Prefix is permitted on:</p><ul><li>Memory Requests (including Untranslated AtomicOp Requests) with Untranslated Addresses<li>Address Translation Requests<li>Page Request Messages<li>ATS Invalidation Requests<li>PRG Response Messages</ul><font color="gray" face="黑体" size="2"> PASID TLP Prefix允许在下面的请求中使用:<ul><li> 带有 Untranslated Adress Memory Requests(包括 Untranslated AtomicOp Requests)<li> Address Translation Requests<li> Page Request Messages<li> ATS Invalidation Requests<li> RPG Response Messages</ul></font><p>Usage of the PASID TLP Prefix for Untranslated Memory Requests is defined in Section 6.20 . This section describes PASID TLP Prefix for the remaining TLPs.</p><font color="gray" face="黑体" size="2"> 对于 Untranslated Memory Requests使用 PASID TLP Prefix在 Section 6.20中定义. 该章节描述了其他 TLPs 中的PASID TLP Prefix </font><p>When a Request does not have a PASID TLP Prefix, the Untranslated Address represents an address space associated with the Requester ID.</p><p>When a Request has a PASID TLP Prefix, the Untranslated Address represents an address space associated with both the Requester ID and the PASID value.</p><font color="gray" face="黑体" size="2"> 当一个Requset 不带有 PASID TLP Prefix, 这个 Untranslated Address 表示与 Requester ID相关的地址空间 当一个Request 带有 PASID TLP Prefix, 这个 Untranslated Address 表示 与Requester ID和PASID 值 相关的地址空间 (Requester ID + PASID --&gt; request) </font><p>When a Response has a PASID TLP Prefix, the PASID value reflects the address space associated the corresponding Request.</p><font color="gray" face="黑体" size="2"> 当一个 Response 带有 PASID TLP Prefix, 这个 PASID的值反映了 与其相应的请求相关的地址空间 </font><p>Each Function has an independent set of PASID values. The PASID field is 20 bits wide however the effective width is constrained by the lesser of the width supported by the Root Complex (TA) and the width supported by the Function (ATC). Unused upper bits of the PASID value must be 0b.</p><font color="gray" face="黑体" size="2"> 每个 function 都有一组独立的 PASID 值. PASID字段有20 bits宽, 但是 有效的宽度会被 Root Complex (TA) 和function (ATC) 限制的更短. PASID的没有使用的高bits位必须是0 </font><p>For Endpoints in systems where a Virtual Intermediary (VI) is present, Untranslated.</p><font color="gray" face="黑体" size="2"> 对于一个存在 Virtual Intermediary (VI) (VMM) 的Enpoints, 是 Untranslated </font><p>Addresses with an associated PASID are typically used to represent Guest Virtual Addresses (GVA) and Untranslated Addresses that are not associated with a PASID represent Guest Physical Addresses (GPA). The TA could be designed so that the VI manages the tables used to perform translations from GPA to Translated Addresses while the individual Guest Operating Systems manage tables used to perform translations from GVA to GPA. When translating an address with an associated PASID, the TA performs both translations and returns the resulting Translated Address (i.e., GVA to GPA followed by GPA to Translated Address). The intermediate GPA value is not visible to the ATC.</p><font color="gray" face="黑体" size="2"> 带有相关的 PASID 的address 通常用于标识 Guest Virtual Address (GVA), 不带 PASID 的 Untranslated Address标识 Guest Physical Address (GPA). TA这样设计以便 VI 管理用于执行从GPA 到 Translated Address 页表, 而独立的Guest 操作系统管理用于从GVA到 GPA的页表.当 转换一个带有 相关 PASID的地址, TA 执行 两种translations 并且返回 Translated Address (也就是说: GVA --&gt; GPA 然后是 GPA --&gt; Translated Address). 中间的GPA值对ATC不可见 </font><p>When an ATC invalidates a cached GPA mapping, it invalidates the GPA mapping and also invalidates all GVA mappings in the ATC. When the GPA invalidate completes, the VI can safely remove pages backing GPA memory range from a Guest Operating System. The VI does not need to know which GVA mappings involved the GPA mapping.</p><font color="gray" face="黑体" size="2"> </font></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/pcie/">pcie</a>, <a href="/categories/acs/">acs</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/pcie/" class="post-tag no-text-decoration" >pcie</a> <a href="/tags/acs/" class="post-tag no-text-decoration" >acs</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=ats%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fats%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=ats%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fats%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fats%2F&text=ats%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/RME-spec/">[arm] RME(spec)</a><li class="text-truncate lh-lg"> <a href="/posts/learn-RME/">[arm] learn RME</a><li class="text-truncate lh-lg"> <a href="/posts/virtcca-paper/">[arm] virtCCA</a><li class="text-truncate lh-lg"> <a href="/posts/la57-switch_mode/">[mm:la57] switch to la57</a><li class="text-truncate lh-lg"> <a href="/posts/js-comm-webset/">[js] js common webset</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/acs/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1728788400" data-df="ll" > Oct 13, 2024 </time><h4 class="pt-0 my-2">acs</h4><div class="text-muted"><p>ACS defines a set of control points within a PCI Express topology to determine whether a TLP is to be routed normally, blocked, or redirected. ACS is applicable to RCs, Switches, and Multi-Function...</p></div></div></a></article><article class="col"> <a href="/posts/drain-pasid/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1745329860" data-df="ll" > Apr 22, 2025 </time><h4 class="pt-0 my-2">drain pasid</h4><div class="text-muted"><p>PASID 简介 PASID overflow PASID 全称Process Address Space ID, PASID 同 requester ID结合，共同确定该request 所映射的地址空间。所以 PASID 和 ASID 类似, 均标识一个地址映射关系。但是ASID 用于 标识CPU 侧的memory request，而PASID 则标识PCIe end point 的D...</p></div></div></a></article><article class="col"> <a href="/posts/host-bridge/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1737639420" data-df="ll" > Jan 23, 2025 </time><h4 class="pt-0 my-2">host-bridge is pci device BUT NOT pci bridge</h4><div class="text-muted"><p>查看host-bridge配置空间 [root@A06-R08-I134-73-919XB72 openEuler-2403]# lspci -xxx -s 00:00.0 00: [86 80] [00 2f] [40 05] [10 00] 02 [00 00 06] 00 00 [00] 00 [vendor] [device] [comm...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/coherence_basic/" class="btn btn-outline-primary" aria-label="Older" ><p>CHAPTER 2 Coherence Basics</p></a> <a href="/posts/lat-mem-bench/" class="btn btn-outline-primary" aria-label="Newer" ><p>[perftest] lat mem rd</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
