<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="qspinlock" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="简介 内核中的自旋锁是互斥锁。而内核中的自旋锁经过多个版本的演进， 最终是在 mcs 自旋锁 算法之上，根据kernel 本身的需求，作了改进。" /><meta property="og:description" content="简介 内核中的自旋锁是互斥锁。而内核中的自旋锁经过多个版本的演进， 最终是在 mcs 自旋锁 算法之上，根据kernel 本身的需求，作了改进。" /><link rel="canonical" href="/posts/qspinlock/" /><meta property="og:url" content="/posts/qspinlock/" /><meta property="og:site_name" content="Chirpy" /><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/pic/kernel_spin_lock_org.svg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-09-11T10:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/pic/kernel_spin_lock_org.svg" /><meta property="twitter:title" content="qspinlock" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2023-09-11T10:00:00+08:00","datePublished":"2023-09-11T10:00:00+08:00","description":"简介 内核中的自旋锁是互斥锁。而内核中的自旋锁经过多个版本的演进， 最终是在 mcs 自旋锁 算法之上，根据kernel 本身的需求，作了改进。","headline":"qspinlock","image":"https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/pic/kernel_spin_lock_org.svg","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/qspinlock/"},"url":"/posts/qspinlock/"}</script><title>qspinlock | Chirpy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chirpy"><meta name="application-name" content="Chirpy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/commons/avatar.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Chirpy</a><p class="site-subtitle fst-italic mb-0">A text-focused Jekyll theme</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/overflow/" class="nav-link"> <i class="fa-fw fas fa-star"></i> <span>OVERFLOW</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/github_username" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>qspinlock</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>qspinlock</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1694397600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Sep 11, 2023 </time> </span><div class="mt-3 mb-3"> <a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/pic/kernel_spin_lock_org.svg" class="popup img-link preview-img shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/pic/kernel_spin_lock_org.svg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3684 words" > <em>20 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">qspinlock</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">qspinlock</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h1 id="简介">简介</h1><p>内核中的自旋锁是互斥锁。而内核中的自旋锁经过多个版本的演进， 最终是在 mcs 自旋锁 算法之上，根据kernel 本身的需求，作了改进。</p><p>我们这里不去回顾 Linux 自旋锁的历史，简单介绍下 mcs 自旋锁算法， 并详细讲解 kernel 中的 mcs自旋锁的变体。</p><blockquote class="prompt-tip"><p>NOTE</p><p>如果想要了解 kernel 自旋锁的演进，可以看下</p><p><a href="https://zhuanlan.zhihu.com/p/584016727">深入理解Linux内核之自旋锁</a> <sup>1</sup></p><p>该文章详细讲解了kernel自旋锁的演进，并通过举例子 的方式，讲解了各个算法（包括最新的算法），十分值 得看, 本文主要分析kernel 最新的 自旋锁算法。</p></blockquote><h2 id="mcs-自旋锁"><span class="me-2">MCS 自旋锁</span><a href="#mcs-自旋锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>MCS 自旋锁是在为了解决票号自旋锁带来的 cache line bouncing<sup>2</sup>, 实现了一个队列，使其各自自旋各自的地址, 而不是自旋一个地址，这样就 解决了这个问题。</p><blockquote class="prompt-tip"><p>NOTE 1</p><p>这个我们放到附录1中讲述 什么是cache line bouncing，为什么cache line bouncing在 spinlock场景会尤为突出。</p></blockquote><p>所以 MCS自旋锁 即保持票号自旋锁的保证线程获取锁的顺序的优点， 同时解决票号自旋锁带来的cache 抖动问题。但是也有缺点，我们下面会介绍。</p><p>我们先来看下 MCS自旋锁的实现</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/pic/MCS.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/pic/MCS.png" alt="MCS" loading="lazy"></a></p><p>而MCS自旋锁有什么缺点呢 ?</p><ul><li>更改了spinlock的相关接口<li>锁占用的内存变大</ul><p>kernel 对此做了一些优化，我们来看下</p><h2 id="kernel-mcs-变体"><span class="me-2">KERNEL MCS 变体</span><a href="#kernel-mcs-变体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/./pic/kernel_spin_lock_org.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/./pic/kernel_spin_lock_org.svg" alt="初始状态" loading="lazy"></a></p><p>spinlock的相关数据结构(struct qspinlock)，仍然保持之前的样子 大小为<code class="language-plaintext highlighter-rouge">sizeof(u32)</code>。但是该空间分割成主要的三个成员 <code class="language-plaintext highlighter-rouge">(locked, pending,tail)</code>。我们来看下kernel代码定义:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">qspinlock</span> <span class="p">{</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="n">atomic_t</span> <span class="n">val</span><span class="p">;</span>

                <span class="cm">/*
                ¦* By using the whole 2nd least significant byte for the
                ¦* pending bit, we can allow better optimization of the lock
                ¦* acquisition for the pending bit holder.
                ¦*/</span>
<span class="cp">#ifdef __LITTLE_ENDIAN
</span>                <span class="k">struct</span> <span class="p">{</span>
                        <span class="n">u8</span>      <span class="n">locked</span><span class="p">;</span>
                        <span class="n">u8</span>      <span class="n">pending</span><span class="p">;</span>
                <span class="p">};</span>
                <span class="k">struct</span> <span class="p">{</span>
                        <span class="n">u16</span>     <span class="n">locked_pending</span><span class="p">;</span>
                        <span class="n">u16</span>     <span class="n">tail</span><span class="p">;</span>
                <span class="p">};</span>
<span class="cp">#else
</span>                <span class="k">struct</span> <span class="p">{</span>
                        <span class="n">u16</span>     <span class="n">tail</span><span class="p">;</span>
                        <span class="n">u16</span>     <span class="n">locked_pending</span><span class="p">;</span>
                <span class="p">};</span>
                <span class="k">struct</span> <span class="p">{</span>
                        <span class="n">u8</span>      <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
                        <span class="n">u8</span>      <span class="n">pending</span><span class="p">;</span>
                        <span class="n">u8</span>      <span class="n">locked</span><span class="p">;</span>
                <span class="p">};</span>
<span class="cp">#endif
</span>        <span class="p">};</span>
<span class="p">}</span> <span class="n">arch_spinlock_t</span><span class="p">;</span>
</pre></table></code></div></div><p>可以看到访问该数据结构，应该使用原子操作(qspinlock.val), 根据的线程(cpu)的情况可能需要关注的东西不同, 例如: <code class="language-plaintext highlighter-rouge">mcs.locked = 1</code>的cpu需要关注 (qspinlock.locked_pending)成员。 而pending的cpu仅需要关注(qspinlock.locked), 我们下面会介绍具体的流程</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/./pic/kernel_spin_lock.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/qspinlock/./pic/kernel_spin_lock.svg" alt="竞争过程" loading="lazy"></a></p><ul><li>简单来说，是占据pending 的cpu抢占locked, 而 占据 mcs head 的cpu 抢占 <code class="language-plaintext highlighter-rouge">locked_pending</code>, 而非mcs head的cpu, 先抢占 <code class="language-plaintext highlighter-rouge">self.mcs.locked == 1</code>, 等待该条件满足时，表示其为 mcs head, 然后再抢占 <code class="language-plaintext highlighter-rouge">locked_pending</code><li>每个 cpu有四个 mcs0, 代表4中状态（代表4层执行流，线程、软中断、 硬中断、屏蔽中断), 举个例子，线程拿到了锁，这时候来了一个硬 中断，硬中断处理完后，进入软中断处理及流程，这时拿了一把锁， 此时又来了一个硬中断，该中断处理中又拿了一个自旋锁，还未解锁时， 来了一个NMI又拿了一个自旋锁。 这样每个CPU最多持有四把自旋锁。而 每个自旋锁，如果都需要使用 mcs结构 enqueue， 最多需要4个mcs结构。<li>tail的计算也是基于上面。每个cpu最多拿四个mcs, 所以tail[bit:1,bit:0] 用来表示当前用了几个自旋锁。cpu index记录在剩余的bits中。另外 <code class="language-plaintext highlighter-rouge">tail == 0</code>有特殊的含义 – 表示没有 mcs 在抢占自旋锁。所以不存在 <code class="language-plaintext highlighter-rouge">cpu0.mcs0</code>的这种情况，需要将 <code class="language-plaintext highlighter-rouge">cpu_index++</code>, 也就是下面的公式:<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>tail = ((cpu_index + 1) &lt;&lt; 2) + mcs_index
</pre></table></code></div></div></ul><h2 id="代码分析"><span class="me-2">代码分析</span><a href="#代码分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>NOTE</p><p>下面 频繁使用三元组 (tail, pending, locked) , 例如(0, 0, 1) 表示 locked = 1, pending = 0, tail = 0</p><p>另外 tail = n , 表示tail位被占用</p><p>tail = z, 则表示tail 为任意值</p><p>locked, pending == x, y 表示任意值</p></blockquote><p>我们直接看 <code class="language-plaintext highlighter-rouge">queue_spin_lock()</code>的相关代码:</p><h3 id="queued_spin_lock"><span class="me-2">queued_spin_lock</span><a href="#queued_spin_lock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">queued_spin_lock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">//=============(1)=================</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">atomic_cmpxchg_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_Q_LOCKED_VAL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="c1">//============(2)==================</span>
        <span class="n">queued_spin_lock_slowpath</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>查看<code class="language-plaintext highlighter-rouge">lock-&gt;val</code> 是否为0, 如果为0, 则说明没有人在使用该锁, 将 (0, 0, 0) 修改为 (0, 0, 1)<li>如果有人占用锁，则走slowpath流程</ol><h3 id="slow-path"><span class="me-2">slow path</span><a href="#slow-path" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="lock-pending--part-1"><span class="me-2">lock pending – part 1</span><a href="#lock-pending--part-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">queued_spin_lock_slowpath</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">mcs_spinlock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
        <span class="n">u32</span> <span class="n">old</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

        <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">CONFIG_NR_CPUS</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">_Q_TAIL_CPU_BITS</span><span class="p">));</span>
        <span class="c1">//===============(1)==================</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pv_enabled</span><span class="p">())</span>
                <span class="k">goto</span> <span class="n">pv_queue</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">virt_spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="cm">/*
         * Wait for in-progress pending-&gt;locked hand-overs with a bounded
         * number of spins so that we guarantee forward progress.
         *
         * 0,1,0 -&gt; 0,0,1
         */</span>
        <span class="c1">//===============(2)==================</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">_Q_PENDING_VAL</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">_Q_PENDING_LOOPS</span><span class="p">;</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">atomic_cond_read_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span>
                                        <span class="p">(</span><span class="n">VAL</span> <span class="o">!=</span> <span class="n">_Q_PENDING_VAL</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">cnt</span><span class="o">--</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/*
        ¦* If we observe any contention; queue.
        ¦*/</span>
        <span class="c1">//===============(3)==================</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_Q_LOCKED_MASK</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">queue</span><span class="p">;</span>
        <span class="cm">/*
         * trylock || pending
         *
         * 0,0,* -&gt; 0,1,* -&gt; 0,0,1 pending, trylock
         */</span>
        <span class="c1">//===============(4)==================</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">queued_fetch_set_pending_acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="p">...</span>
</pre></table></code></div></div><ol><li>我们这里先不关注半虚拟化<li>如果是(0, 1, 0)， 则等待其进入(0, 0, 1), 这样做的好处是，如果其进入了 (0,0,1) 则直接抢占pending位，状态为(0,1,1), 就不用走queue的流程<li>如果除 locked位，其他位不为0, 则说明有被别的线程抢占了，则走queue的流程<li>该代码为:<div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">__always_inline</span> <span class="n">u32</span> <span class="nf">queued_fetch_set_pending_acquire</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
     <span class="k">return</span> <span class="n">atomic_fetch_or_acquire</span><span class="p">(</span><span class="n">_Q_PENDING_VAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里进行按位或操作，并返回之前的值，我们来想下在原子操作前有那 几种可能的情况。</p><ul><li>(z, 1, y) : 进行逻辑或操作无影响。但是本次抢占锁失败<li>(n, 0, y) : !! 这种情况就打乱了顺序，不允许, 并且需要将pending位还原<li>(0, 0, 1) : 抢占pending位，spin lock位<li>(0, 0, 0) : 抢占了pending位，然后这时，只有自己能抢占lock位，再抢占lock位</ul></ol><p>我们继续分析(4) 之后的代码:</p><h4 id="lock-pending--part2"><span class="me-2">lock pending – part2</span><a href="#lock-pending--part2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre>
        <span class="cm">/*
         * If we observe contention, there is a concurrent locker.
         *
         * Undo and queue; our setting of PENDING might have made the
         * n,0,0 -&gt; 0,0,0 transition fail and it will now be waiting
         * on @next to become !NULL.
         */</span>
        <span class="c1">//============(1)====================</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_Q_LOCKED_MASK</span><span class="p">))</span> <span class="p">{</span>

        <span class="c1">//============(1.1)====================</span>
                <span class="cm">/* Undo PENDING if we set it. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_Q_PENDING_MASK</span><span class="p">))</span>
                        <span class="n">clear_pending</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

                <span class="k">goto</span> <span class="n">queue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * We're pending, wait for the owner to go away.
         *
         * 0,1,1 -&gt; 0,1,0
         *
         * this wait loop must be a load-acquire such that we match the
         * store-release that clears the locked bit and create lock
         * sequentiality; this is because not all
         * clear_pending_set_locked() implementations imply full
         * barriers.
         */</span>
        <span class="c1">//===============(2)================</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_Q_LOCKED_MASK</span><span class="p">)</span>
                <span class="n">atomic_cond_read_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">VAL</span> <span class="o">&amp;</span> <span class="n">_Q_LOCKED_MASK</span><span class="p">));</span>
        <span class="cm">/*
         * take ownership and clear the pending bit.
         *
         * 0,1,0 -&gt; 0,0,1
         */</span>
        <span class="n">clear_pending_set_locked</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">lockevent_inc</span><span class="p">(</span><span class="n">lock_pending</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
</pre></table></code></div></div><ol><li>除了locked字段以外还有值，则抢锁失败<ul><li>pending字段有值，则为(z, 1, y), 抢锁失败不需要做什么事情,<li>pending 字段未有值，那tail字段肯定有值，则为(n, 0, y), 抢锁 失败，还需要将pending位还原为0<li>以上两种情况都需要入队</ul><li>这种情况为 (0, 0, y)<ul><li>如果为 (0, 0, 1), 则spin lock位，等待其变为0<li>如果位 (0, 0, 0), clear pending 并且 抢占 lock位</ul></ol><h4 id="queue--part1"><span class="me-2">queue – part1</span><a href="#queue--part1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">queued_spin_lock_slowpath</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
        <span class="p">...</span>
<span class="nl">queue:</span>
        <span class="n">lockevent_inc</span><span class="p">(</span><span class="n">lock_slowpath</span><span class="p">);</span>
<span class="nl">pv_queue:</span>
        <span class="c1">//=================(1)=======================</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qnodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mcs</span><span class="p">);</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">encode_tail</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">idx</span><span class="p">);</span>

        <span class="cm">/*
         * 4 nodes are allocated based on the assumption that there will
         * not be nested NMIs taking spinlocks. That may not be true in
         * some architectures even though the chance of needing more than
         * 4 nodes will still be extremely unlikely. When that happens,
         * we fall back to spinning on the lock directly without using
         * any MCS node. This is not the most elegant solution, but is
         * simple enough.
         */</span>
        <span class="c1">//=================(2)=======================</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">MAX_NODES</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">lockevent_inc</span><span class="p">(</span><span class="n">lock_no_node</span><span class="p">);</span>
                <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">queued_spin_trylock</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
                        <span class="n">cpu_relax</span><span class="p">();</span>
                <span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//=================(3)=======================</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">grab_mcs_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>获取mcs结构，关于该node的count,在 qnodes[0].mcs中记录。 <code class="language-plaintext highlighter-rouge">encode_tail()</code> 会根据 当前cpu idx和原来的count值计算出一个 值作为tail的值。<li><code class="language-plaintext highlighter-rouge">idx &gt;= MAX_NODES</code>其实是不正常的（说明已经获取了 MAX_NODES(4) 次锁), 注释中写了可能的原因，我们这里先不细看 (!!后续补充!!)<li>获取 qnodes[idx].mcs node</ol><h4 id="queue--part2"><span class="me-2">queue – part2</span><a href="#queue--part2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">queued_spin_lock_slowpath</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
        <span class="p">...</span>
        <span class="cm">/*
         * 上节代码:
         * idx = node-&gt;count++;
         */</span>
		<span class="p">...</span>
        <span class="cm">/*
         * Keep counts of non-zero index values:
         */</span>
        <span class="n">lockevent_cond_inc</span><span class="p">(</span><span class="n">lock_use_node2</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

        <span class="c1">//=============(1)===============</span>
        <span class="cm">/*
        ¦* Ensure that we increment the head node-&gt;count before initialising
        ¦* the actual node. If the compiler is kind enough to reorder these
        ¦* stores, then an IRQ could overwrite our assignments.
        ¦*/</span>
        <span class="n">barrier</span><span class="p">();</span>
        <span class="c1">//=============(2)===============</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">pv_init_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

        <span class="cm">/*
        ¦* We touched a (possibly) cold cacheline in the per-cpu queue node;
        ¦* attempt the trylock once more in the hope someone let go while we
        ¦* weren't watching.
        ¦*/</span>
        <span class="c1">//=============(3)===============</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">queued_spin_trylock</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
                <span class="k">goto</span> <span class="n">release</span><span class="p">;</span>

		<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li><p><a href="https://lore.kernel.org/lkml/20180528100209.755214820@linuxfoundation.org/">locking/qspinlock: Ensure node-&gt;count is updated before initialising node</a></p><blockquote><p>commit 11dc13224c975efcec96647a4768a6f1bb7a19a8 该 barrier是为了避免编译器将 <code class="language-plaintext highlighter-rouge">init node</code> 和 <code class="language-plaintext highlighter-rouge">idx = node-&gt;count++</code>顺序搞乱。 在单执行流跑的时候不会有问题。当遇到下面的情况 ``` (1) 未加barrier()之前, 编译器乱序 normal thread 触发中断 //乱序 init node[0] init node[0] idx = node-&gt;count++</p></blockquote><p>(2) 加了barrier normal thread idx = node-&gt;count++ 触发中断 init node[1] init node[0] ``` 未加 barrier()之前，会遇到中断执行流和normal thread执行流，使用 一个node的情况。</p><li>初始化该node<li>这时候，我们只修改了node, 如果能抢到锁，恢复原来的node也很好恢复。 所以尝试抢锁，抢到就血赚。</ol><h4 id="queue--part3"><span class="me-2">queue – part3</span><a href="#queue--part3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">queued_spin_lock_slowpath</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/*
         * 上节代码:(1)
         * node-&gt;locked = 0;
         * node-&gt;next = NULL;
         */</span>
        <span class="p">...</span>
        <span class="cm">/*
        ¦* Ensure that the initialisation of @node is complete before we
        ¦* publish the updated tail via xchg_tail() and potentially link
        ¦* @node into the waitqueue via WRITE_ONCE(prev-&gt;next, node) below.
        ¦*/</span>
        <span class="c1">//=============(1)===============</span>
        <span class="n">smp_wmb</span><span class="p">();</span>

        <span class="cm">/*
        ¦* Publish the updated tail.
        ¦* We have already touched the queueing cacheline; don't bother with
        ¦* pending stuff.
        ¦*
        ¦* p,*,* -&gt; n,*,*
        ¦*/</span>
        <span class="c1">//==============(2)===============</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">xchg_tail</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
        <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/*
        ¦* if there was a previous node; link it and wait until reaching the
        ¦* head of the waitqueue.
        ¦*/</span>
        <span class="c1">//==============(3)===============</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_Q_TAIL_MASK</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">decode_tail</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>

                <span class="cm">/* Link @node into the waitqueue. */</span>
        <span class="c1">//==============(4)===============</span>
                <span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

                <span class="n">pv_wait_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
        <span class="c1">//==============(5)===============</span>
                <span class="n">arch_mcs_spin_lock_contended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">);</span>

                <span class="cm">/*
                ¦* While waiting for the MCS lock, the next pointer may have
                ¦* been set by another lock waiter. We optimistically load
                ¦* the next pointer &amp; prefetch the cacheline for writing
                ¦* to reduce latency in the upcoming MCS unlock operation.
                ¦*/</span>
        <span class="c1">//==============(6)===============</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span>
                        <span class="n">prefetchw</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>关于此处的分析，请看<br /><ul><li><a href="./patch/locking-qspinlock-Ensure-node-is-initialised-before-.patch">locking/qspinlock: Ensure node is initialised before updating prev-&gt;next</a><br /><li><a href="./patch/locking-qspinlock-Elide-back-to-back-RELEASE-operati.patch">locking/qspinlock: Elide back-to-back RELEASE operations with smp_wmb</a><br /></ul><li>publish the updated tail (替换tail)<li>判断 old 是否有 tail值，如果有，则说明mcs链表中有成员, 需要获取 prev, 并且更新<code class="language-plaintext highlighter-rouge">prev-&gt;next</code><li>更新 prev-&gt;next<li><p>这时需要自旋等待 node-&gt;locked == 1</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#define arch_mcs_spin_lock_contended(l)                                 \
do {                                                                    \
        smp_cond_load_acquire(l, VAL);                                  \
} while (0)
</span></pre></table></code></div></div><li>因为在(5)处等待了一段时间，很可能node-&gt;next就有值了，因为这时候抢到了 锁，如果有next需要再将<code class="language-plaintext highlighter-rouge">next-&gt;locked = 1</code>, 但是距离写操作还有一些指令， 这里执行<code class="language-plaintext highlighter-rouge">prefetchw</code> 操作，暗示cpu会有对<code class="language-plaintext highlighter-rouge">next</code>地址的写操作，使其在写操作 发生之前，将该地址的内容load到 cache中。</ol><h4 id="queue--part4"><span class="me-2">queue – part4</span><a href="#queue--part4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">queued_spin_lock_slowpath</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
        <span class="p">...</span>
        <span class="cm">/*
        ¦* we're at the head of the waitqueue, wait for the owner &amp; pending to
        ¦* go away.
        ¦*
        ¦* *,x,y -&gt; *,0,0
        ¦*
        ¦* this wait loop must use a load-acquire such that we match the
        ¦* store-release that clears the locked bit and create lock
        ¦* sequentiality; this is because the set_locked() function below
        ¦* does not imply a full barrier.
        ¦*
        ¦* The PV pv_wait_head_or_lock function, if active, will acquire
        ¦* the lock and return a non-zero value. So we have to skip the
        ¦* atomic_cond_read_acquire() call. As the next PV queue head hasn't
        ¦* been designated yet, there is no way for the locked value to become
        ¦* _Q_SLOW_VAL. So both the set_locked() and the
        ¦* atomic_cmpxchg_relaxed() calls will be safe.
        ¦*
        ¦* If PV isn't active, 0 will be returned instead.
        ¦*
        ¦*/</span>
        <span class="c1">//================(1)======================</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">pv_wait_head_or_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span>
                <span class="k">goto</span> <span class="n">locked</span><span class="p">;</span>

        <span class="c1">//================(2)======================</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">atomic_cond_read_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">VAL</span> <span class="o">&amp;</span> <span class="n">_Q_LOCKED_PENDING_MASK</span><span class="p">));</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>pv先不看 !!!!!<li>自旋 <code class="language-plaintext highlighter-rouge">lock-&gt;lock_pending == 0</code> (n, 1, 0) 或者 (n,0,1) –&gt;(n, 0, 0), 这里只有该进程自旋这个地址，所以如果变为(n, 0, 0) , 只有这个进程可以 抢到。</ol><h4 id="locked"><span class="me-2">locked</span><a href="#locked" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">queued_spin_lock_slowpath</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
<span class="nl">locked:</span>
        <span class="cm">/*
        ¦* claim the lock:
        ¦*
        ¦* n,0,0 -&gt; 0,0,1 : lock, uncontended
        ¦* *,*,0 -&gt; *,*,1 : lock, contended
        ¦*
        ¦* If the queue head is the only one in the queue (lock value == tail)
        ¦* and nobody is pending, clear the tail code and grab the lock.
        ¦* Otherwise, we only need to grab the lock.
        ¦*/</span>

        <span class="cm">/*
        ¦* In the PV case we might already have _Q_LOCKED_VAL set, because
        ¦* of lock stealing; therefore we must also allow:
        ¦*
        ¦* n,0,1 -&gt; 0,0,1
        ¦*
        ¦* Note: at this point: (val &amp; _Q_PENDING_MASK) == 0, because of the
        ¦*       above wait condition, therefore any concurrent setting of
        ¦*       PENDING will make the uncontended transition fail.
        ¦*/</span>
        <span class="c1">//==============(1)====================</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_Q_TAIL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//==============(2)====================</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">atomic_try_cmpxchg_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">_Q_LOCKED_VAL</span><span class="p">))</span>
                        <span class="k">goto</span> <span class="n">release</span><span class="p">;</span> <span class="cm">/* No contention */</span>
        <span class="p">}</span>

        <span class="cm">/*
        ¦* contended path; wait for next if not observed yet, release.
        ¦*/</span>
        <span class="c1">//==============(3)====================</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">smp_cond_load_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="p">(</span><span class="n">VAL</span><span class="p">));</span>

        <span class="cm">/*
        ¦* Either somebody is queued behind us or _Q_PENDING_VAL got set
        ¦* which will then detect the remaining tail and queue behind us
        ¦* ensuring we'll see a @next.
        ¦*/</span>
        <span class="c1">//==============(4)====================</span>
        <span class="n">set_locked</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

        <span class="c1">//==============(5)====================</span>
        <span class="n">arch_mcs_spin_unlock_contended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">);</span>
        <span class="n">pv_kick_node</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

<span class="n">release</span><span class="o">:</span>
        <span class="cm">/*
        ¦* release the node
        ¦*/</span>
        <span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">qnodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mcs</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>如果tail 就是 当前的mcs, 说明，没有其他人抢了，这时将 状态变为 (0, 0, 1)<li><code class="language-plaintext highlighter-rouge">atomic_try_cmpxchg_relaxed()</code><ul><li>如果lock-&gt;val == val , val保持不变，返回值为true<li>如果Lock-&gt;val != val, val=lock-&gt;val, 返回值为false<li>所以, 如果返回为真，说明为(this_node, 0, 0)则 直接替换成(0, 0, 1) 即可, 并且释放该mcs</ul><li>如果next没有值，并且这时<code class="language-plaintext highlighter-rouge">lock-&gt;tail != this_node</code>, 说明 有人抢锁，并执行完<code class="language-plaintext highlighter-rouge">old = xchg_tail(lock, tail);</code> 这行代码， 但是还没有执行<code class="language-plaintext highlighter-rouge">WRITE_ONCE(prev-&gt;next, node);</code>, 这行代码， 这时，需要等待 node-&gt;next 被赋值。<li><p>这时，可以抢占锁了。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>commit c61da58d8a9ba9238250a548f00826eaf44af0f7
</pre></table></code></div></div><li><p>将next-&gt;locked 赋值为1</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#define arch_mcs_spin_unlock_contended(l)                               \
        smp_store_release((l), 1)
</span></pre></table></code></div></div></ol><h2 id="附录"><span class="me-2">附录</span><a href="#附录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="附录1--cacheline-bouncing"><span class="me-2">附录1 : cacheline bouncing</span><a href="#附录1--cacheline-bouncing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="参考链接"><span class="me-2">参考链接</span><a href="#参考链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><a href="https://zhuanlan.zhihu.com/p/584016727">深入理解Linux内核之自旋锁</a><li><a href="https://www.quora.com/What-is-cache-line-bouncing-How-may-a-spinlock-trigger-this-frequently">What is cache line bouncing? How may a spinlock trigger this frequently?</a><li><a href="https://hackmd.io/@sysprog/linux-spinlock-scalability#Aliworkqueue">從 CPU cache coherence 談 Linux spinlock 可擴展能力議題</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/synchronization/">synchronization</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/synchronization/" class="post-tag no-text-decoration" >synchronization</a> <a href="/tags/spinlock/" class="post-tag no-text-decoration" >spinlock</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=qspinlock%20-%20Chirpy&url=%2Fposts%2Fqspinlock%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=qspinlock%20-%20Chirpy&u=%2Fposts%2Fqspinlock%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fqspinlock%2F&text=qspinlock%20-%20Chirpy" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/seqcounter-and-seqlock/">sequence counters and sequential locks</a><li class="text-truncate lh-lg"> <a href="/posts/rcu-classic/">rcu - classic</a><li class="text-truncate lh-lg"> <a href="/posts/tdx-spec/">intel tdx (spec)</a><li class="text-truncate lh-lg"> <a href="/posts/rcu-overflow/">rcu - overflow</a><li class="text-truncate lh-lg"> <a href="/posts/intel-memory-encryption/">intel memory encryption technologies</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/synchronization/">synchronization</a> <a class="post-tag btn btn-outline-primary" href="/tags/os/">os</a> <a class="post-tag btn btn-outline-primary" href="/tags/rcu/">rcu</a> <a class="post-tag btn btn-outline-primary" href="/tags/spinlock/">spinlock</a> <a class="post-tag btn btn-outline-primary" href="/tags/tee/">tee</a> <a class="post-tag btn btn-outline-primary" href="/tags/completed/">completed</a> <a class="post-tag btn btn-outline-primary" href="/tags/mktme/">mktme</a> <a class="post-tag btn btn-outline-primary" href="/tags/non-blocking-algorithm/">non-blocking algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu/">qemu</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-coroutine/">qemu_coroutine</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/non-scalable-vs-scalable-spinlock/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1766718000" data-df="ll" > Dec 26, 2025 </time><h4 class="pt-0 my-2">non-scalable VS scalable spinlock</h4><div class="text-muted"><p>自旋锁是一种会让尝试获取它的线程陷入循环 （“自旋”）并不断检查锁是否可用的锁 1。 和mutex 不同，mutex 可以睡眠，将cpu让渡给其他的程序，而自旋锁则是占据着cpu资源忙 等。忙等最主要的优点是，避免了调度所带来的上下文开销, 可以提升等锁进程获得锁的延 迟。另外，如果加锁的临界区很小，自旋锁忙等所带来的开销，可能会小于上下文切换的开 销，自旋锁的收益就会非常大。所以，自旋...</p></div></div></a></article><article class="col"> <a href="/posts/seqcounter-and-seqlock/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1767774900" data-df="ll" > Jan 7, 2026 </time><h4 class="pt-0 my-2">sequence counters and sequential locks</h4><div class="text-muted"><p>## introduce > **_Definination of sequence_**: > > In mathematics, a sequence is an infinite list $x_1, x_2, x_3$, ... (Sometimes > finite lists are also called sequence) 2 > > > 大概的意思是序列是一个无限列表。而...</p></div></div></a></article><article class="col"> <a href="/posts/rcu-classic/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1767578400" data-df="ll" > Jan 5, 2026 </time><h4 class="pt-0 my-2">rcu - classic</h4><div class="text-muted"><p>本文主要讲解 经典rcu (classical rcu) 历史. 在介绍具体实现之前, 我们先明确几个概 念: * **_quiescent state_**: 该CPU 上运行的所有 RCU 读取端临界区都已完成1 * **_grace period_**: rcu 删除分为三部分, emoval ,Grace Period, and Reclamation. 宽限期 结束以所有c...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"><div class="btn btn-outline-primary disabled" aria-label="Older"><p>-</p></div><a href="/posts/coroutine/" class="btn btn-outline-primary" aria-label="Newer" ><p>qemu coroutine</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://twitter.com/username">your_full_name</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.3.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/synchronization/">synchronization</a> <a class="post-tag btn btn-outline-primary" href="/tags/os/">os</a> <a class="post-tag btn btn-outline-primary" href="/tags/rcu/">rcu</a> <a class="post-tag btn btn-outline-primary" href="/tags/spinlock/">spinlock</a> <a class="post-tag btn btn-outline-primary" href="/tags/tee/">tee</a> <a class="post-tag btn btn-outline-primary" href="/tags/completed/">completed</a> <a class="post-tag btn btn-outline-primary" href="/tags/mktme/">mktme</a> <a class="post-tag btn btn-outline-primary" href="/tags/non-blocking-algorithm/">non-blocking algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu/">qemu</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-coroutine/">qemu_coroutine</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> (function () { const themeMapper = Theme.getThemeMapper('light', 'dark_dimmed'); const initTheme = themeMapper[Theme.visualState]; let lang = 'zh-CN';if (lang.length > 2 && !lang.startsWith('zh')) { lang = lang.slice(0, 2); } let giscusAttributes = { src: 'https://giscus.app/client.js', 'data-repo': 'cai-fuqiang/cai-fuqiang.github.io', 'data-repo-id': 'R_kgDOPsVm6A', 'data-category': 'Q&A', 'data-category-id': 'DIC_kwDOPsVm6M4C0OXB', 'data-mapping': 'pathname', 'data-strict' : '0', 'data-reactions-enabled': '1', 'data-emit-metadata': '0', 'data-theme': initTheme, 'data-input-position': 'top', 'data-lang': lang, 'data-loading': 'lazy', crossorigin: 'anonymous', async: '' }; let giscusNode = document.createElement('script'); Object.entries(giscusAttributes).forEach(([key, value]) => giscusNode.setAttribute(key, value) ); const $footer = document.querySelector('footer'); $footer.insertAdjacentElement("beforebegin", giscusNode); addEventListener('message', (event) => { if (event.source === window && event.data && event.data.id === Theme.ID) { const newTheme = themeMapper[Theme.visualState]; const message = { setConfig: { theme: newTheme } }; const giscus = document.getElementsByClassName('giscus-frame')[0].contentWindow; giscus.postMessage({ giscus: message }, 'https://giscus.app'); } }); })(); </script> <script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
