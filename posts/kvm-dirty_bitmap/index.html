<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="dirty-bitmap" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /><meta property="og:description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /><link rel="canonical" href="/posts/kvm-dirty_bitmap/" /><meta property="og:url" content="/posts/kvm-dirty_bitmap/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-12T23:20:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="dirty-bitmap" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2024-11-12T23:20:00+08:00","datePublished":"2024-11-12T23:20:00+08:00","description":"A minimal, responsive and feature-rich Jekyll theme for technical writing.","headline":"dirty-bitmap","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/kvm-dirty_bitmap/"},"url":"/posts/kvm-dirty_bitmap/"}</script><title>dirty-bitmap | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>dirty-bitmap</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>dirty-bitmap</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1731424800" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 12, 2024 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5522 words" > <em>30 min</em> read</span></div></div></div></header><div class="content"><h2 id="org-patch"><span class="me-2">ORG PATCH</span><a href="#org-patch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们来看下最初的KVM实现了哪些功能。最初的KVM代码，是基于shadow page table, 支持了dirty_bitmap. 我们从几个方面看下<code class="language-plaintext highlighter-rouge">dirty_bitmap</code>实现:</p><ul><li>kernel data struct<li>USER API<li>lock Contention Analysis</ul><h3 id="kernel-data-struct"><span class="me-2">kernel data struct</span><a href="#kernel-data-struct" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>并支持了dirty_bitmap, 同样是定义在了<code class="language-plaintext highlighter-rouge">memslot</code>结构体中，每个slot一个 <code class="language-plaintext highlighter-rouge">dirty_bitmap</code></p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">kvm_memory_slot</span> <span class="p">{</span>
        <span class="n">gfn_t</span> <span class="n">base_gfn</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">phys_mem</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>该<code class="language-plaintext highlighter-rouge">dirty_bitmap</code>保存了该<code class="language-plaintext highlighter-rouge">slot</code>中所有物理页是否是dirty的。</p><h3 id="use-api"><span class="me-2">USE API</span><a href="#use-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>提供了<code class="language-plaintext highlighter-rouge">dev_ioctl</code>方法<code class="language-plaintext highlighter-rouge">KVM_GET_DIRTY_LOG</code>:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>kvm_dev_ioctl
=&gt; case KVM_GET_DIRTY_LOG
   =&gt; copy user  param kvm_dirty_log
   =&gt; kvm_dev_ioctl_get_dirty_log
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">kvm_dirty_log</code>定义如下:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">kvm_dirty_log</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">slot</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span> <span class="cm">/* one bit per page */</span>
                <span class="n">__u64</span> <span class="n">padding</span><span class="p">;</span>
        <span class="p">};</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>slot: slot id<li>padding: 为了让 dirty_bitmap 64bit 对齐? 还是为了之后有其他扩展<li>dirty_bitmap: copy kernel bitmap to this</ul><p><code class="language-plaintext highlighter-rouge">kvm_dev_ioctl_get_dirty_log</code>具体函数流程:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>kvm_dev_ioctl_get_dirty_log
   <span class="c"># get memslot by slot id</span>
<span class="o">=&gt;</span> memslot <span class="o">=</span> &amp;kvm-&gt;memslots[log-&gt;slot]<span class="p">;</span>
   <span class="c"># copy kernel dirty_bitmap  to user</span>
<span class="o">=&gt;</span> copy_to_user<span class="o">(</span>log-&gt;dirty_bitmap, memslot-&gt;dirty_bitmap, n<span class="o">)</span>
   <span class="c"># set pte WP</span>
<span class="o">=&gt;</span> spin_lock<span class="o">(</span>&amp;kvm-&gt;lock<span class="o">)</span>
<span class="o">=&gt;</span> kvm_mmu_slot_remove_write_access<span class="o">(</span>kvm, log-&gt;slot<span class="o">)</span><span class="p">;</span>
<span class="o">=&gt;</span> spin_unlock<span class="o">(</span>&amp;kvm-&gt;lock<span class="o">)</span>
   <span class="c"># clear dirty_bitmap</span>
<span class="o">=&gt;</span> memset<span class="o">(</span>dirty_bitmap, 0, n<span class="o">)</span>
   <span class="c"># flush tlb</span>
<span class="o">=&gt;</span> foreach<span class="o">(</span>vcpu<span class="o">)</span>
   <span class="o">=&gt;</span> vcpu_load<span class="o">()</span>
   <span class="o">=&gt;</span> tlb_flush<span class="o">(</span>vcpu<span class="o">)</span>
   <span class="o">=&gt;</span> vcpu_put<span class="o">()</span>
</pre></table></code></div></div><p>主要的工作如下:</p><ol><li>将kernel 中 对应memslot dirty_bitmap copy到 user oparam<li>将 slot 中所有shadow page table 都标记为 WP<li>clear kernel dirty bitmap<li>因为2中会涉及到页表修改, 所以需要flush tlb</ol><p>这里会和page fault的流程有race. 我们先展开mmu page fault 的流程</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>handle_exception
<span class="o">=&gt;</span> spin_lock<span class="o">(</span>&amp;vcpu-&gt;kvm-&gt;lock<span class="o">)</span><span class="p">;</span>
<span class="o">=&gt;</span> paging64_page_fault
   <span class="o">=&gt;</span> paging64_fix_write_pf
      <span class="o">=&gt;</span> mark_page_dirty<span class="o">()</span>
      <span class="c"># shadow pte clear WP(mask writeable)</span>
      <span class="c"># guest pte mask dirty</span>
      <span class="o">=&gt;</span> shadow_ent |<span class="o">=</span> PT_WRITEABLE_MASK
      <span class="o">=&gt;</span> guest_ent  |<span class="o">=</span> PT_DIRTY_MASK
<span class="o">=&gt;</span> spin_unlock<span class="o">(</span>&amp;vcpu-&gt;kvm-&gt;lock<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><p>我们来看下该流程是否有问题。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>kvm_dev_ioctl_get_dirty       handle_exception
----------------------------------------------
copy dirty bitmap
spinlock
set WP
spinunlock

                              spinlock
                              mask_dirty to dirty bitmap
clear_dirty_bitmap
                              clear WP
                              spinunlock
</pre></table></code></div></div><p>这么看似乎有点问题.</p><blockquote><p>NOTE</p><p>但是这个逻辑似乎一直没有更改，不知道自己是否推断的有些问题</p><p>avi 在 https://lkml.org/lkml/2012/2/1/140 也似乎提到了这个问题， 那当前的版本难道是，如果进入了kvm_dev_ioctl_get_dirty, vcpu 没有running的？</p></blockquote><h2 id="引入ept"><span class="me-2">引入EPT</span><a href="#引入ept" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>引入EPT之后，其EPT page table， 就类似于shadown pgtable, 我们在<code class="language-plaintext highlighter-rouge">get_dirty_log</code>时, 需要向<code class="language-plaintext highlighter-rouge">EPT pte</code> set WP.</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>kvm_vm_ioctl_get_dirty_log
  <span class="o">=&gt;</span> down_write<span class="o">(</span>&amp;kvm-&gt;slots_lock<span class="o">)</span><span class="p">;</span>
  <span class="o">=&gt;</span> kvm_mmu_slot_remove_write_access
     <span class="o">=&gt;</span> search_all_ept_pagetable
        <span class="o">=&gt;</span> <span class="k">if in </span>ept_pgtable <span class="k">in </span>this slot
           <span class="o">=&gt;</span> SET WP
  <span class="o">=&gt;</span> kvm_flush_remote_tlbs<span class="o">()</span>
  <span class="o">=&gt;</span> memset<span class="o">(</span>memslot-&gt;dirty_bitmap, 0, n<span class="o">)</span>
  <span class="o">=&gt;</span> up_write<span class="o">(</span>&amp;kvm-&gt;slots_lock<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><p>这个过程中并没有引入任何锁!!!</p><p>如果guest因为WP而触发EPT violation，调用路径如下：</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>tdp_page_fault
   <span class="o">=&gt;</span> spin_lock<span class="o">(</span>&amp;vcpu-&gt;kvm-&gt;mmu_lock<span class="o">)</span><span class="p">;</span>
   <span class="o">=&gt;</span> __direct_map
      <span class="o">=&gt;</span> mmu_set_spte<span class="o">(</span>, <span class="nv">pte_access</span><span class="o">=</span>ACC_ALL,<span class="o">)</span>
         <span class="c">## __direct_map中认为shadow pgtable有全部权限，对于EPT来说，</span>
         <span class="c">## guest权限由guest pgtable来管理即可。无需shadow pgtable(ept</span>
         <span class="c">## pgtable控制</span>
         <span class="o">=&gt;</span> <span class="k">if </span>pte_access &amp; ACC_WRITE_MASK
            <span class="c">## 设置 PT_WRITEABLE_MASK(clear WP)</span>
            <span class="o">=&gt;</span> spte |<span class="o">=</span> PT_WRITEABLE_MASK
            <span class="c">## set bitmap</span>
            <span class="o">=&gt;</span> mark_page_dirty
         <span class="c">## update spte</span>
         <span class="o">=&gt;</span> set_shadow_spte<span class="o">(</span>, spte<span class="o">)</span>
   <span class="o">=&gt;</span> spin_unlock<span class="o">(</span>&amp;vcpu-&gt;kvm-&gt;mmu_lock<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><p>过程和之前类似，就是不知道在<code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_get_dirty_log</code>中为什么两 者不再有临界区了。</p><p>而在<code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_get_dirty_log</code>中使用<code class="language-plaintext highlighter-rouge">kvm-&gt;slots_lock</code> down_write sem, 可能表示在此过程中，要modify dirty_bitmap, 但是为什么在 <code class="language-plaintext highlighter-rouge">mark_page_dirty</code>上下文不需要呢?</p><p>但是这个<code class="language-plaintext highlighter-rouge">slots_lock</code>可能在vcpu线程的多个上下文中会<code class="language-plaintext highlighter-rouge">down_read()</code>, 可能导致 <code class="language-plaintext highlighter-rouge">get_dirty_log</code>的流程影响到<code class="language-plaintext highlighter-rouge">vcpu</code>线程, 典型如:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>__vcpu_run
  down_read<span class="o">(</span>slots_lock<span class="o">)</span>
     vcpu_enter_guest
       up_read<span class="o">(</span>slots_lock<span class="o">)</span>
       kvm_x86_ops-&gt;run<span class="o">()</span>   <span class="c">## vmx_vcpu_run</span>
       down_read<span class="o">(</span>slots_lock<span class="o">)</span>
  up_read<span class="o">(</span>slots_lock<span class="o">)</span>
</pre></table></code></div></div><p>而在链接<a href="https://lore.kernel.org/kvm/4B375E10.8050805@redhat.com/">convert slotslock to SRCU</a> 中，AVI提到， 在没有引入srcu时，似乎在64 smp vm(比较多核的虚拟机)中会遇到拿锁很高的情况。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>_raw_spin_lock_irq
             |
             --- _raw_spin_lock_irq
                |
                |--99.94%-- __down_read
                |          down_read
                |          |
                |          |--99.82%-- 0xffffffffa00479c4
                |          |          0xffffffffa003a6c9
                |          |          vfs_ioctl
                |          |          do_vfs_ioctl
                |          |          sys_ioctl
                |          |          system_call
                |          |          __GI_ioctl
                |           --0.18%-- [...]
                 --0.06%-- [...]

     40.57%  qemu-system-x86  [kernel]                           [k] 
_raw_spin_lock_irqsave
             |
             --- _raw_spin_lock_irqsave
                |
                |--99.88%-- __up_read
                |          up_read
                |          |
                |          |--99.82%-- 0xffffffffa0047897
                |          |          0xffffffffa003a6c9
                |          |          vfs_ioctl
                |          |          do_vfs_ioctl
                |          |          sys_ioctl
                |          |          system_call
                |          |          __GI_ioctl
                |           --0.18%-- [...]
                 --0.12%-- [...]
</pre></table></code></div></div><p>在这种情况下, vcpu 即便是idle的，也会大量消耗cpu。原因未知。(没有想通, 为什么down_read会造成如此高的负载, 看代码也没有频繁的down_write代码路径)</p><p>随着srcu在kernel中应用。KVM 可以用srcu 避免read操作所带来的开销。 （但是这块没有太看懂，有很多疑惑, 我们先过下代码)</p><h2 id="srcu-get_dirty_log"><span class="me-2">srcu get_dirty_log</span><a href="#srcu-get_dirty_log" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>关于 srcu 我们这里只关注下 <code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_get_dirty_log()</code>实现:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>kvm_vm_ioctl_get_dirty_log
   <span class="o">=&gt;</span> down_write<span class="o">(</span>kvm-&gt;slots_lock<span class="o">)</span>
   <span class="o">=&gt;</span> new a dirty_bitmap: dirty_bitmap  <span class="c"># 新创建一个dirty_bitmap</span>
   <span class="o">=&gt;</span> memset<span class="o">(</span>dirty_bitmap<span class="o">)</span>              <span class="c"># 清零</span>
   <span class="o">=&gt;</span> spin_lock<span class="o">(</span>mm_lock<span class="o">)</span>
   <span class="o">=&gt;</span> kvm_mmu_slot_remove_write_access  <span class="c"># 清 write access</span>
   <span class="o">=&gt;</span> spin_unlock<span class="o">(</span>mm_lock<span class="o">)</span>
   <span class="o">=&gt;</span> new a memslots: slots
   <span class="o">=&gt;</span> copy kvm-&gt;memslots <span class="o">=&gt;</span> slots<span class="o">(</span>new<span class="o">)</span>  <span class="c"># 新创建slots，让其copy old_slots</span>
   <span class="o">=&gt;</span> slots-&gt;memslots[].dirty_bitmap <span class="o">=</span> dirty_bitmap <span class="c"># 赋值clear的dirty_bitmap</span>
   <span class="o">=&gt;</span> old_slots <span class="o">=</span> kvm-&gt;memslots
   <span class="o">=&gt;</span> rcu_assign_pointer<span class="o">(</span>kvm-&gt;memslots, slots<span class="o">)</span> <span class="c"># rcu update pointer</span>
   <span class="o">=&gt;</span> synchronize_srcu_expedited               <span class="c"># wait grace period expedited</span>
   <span class="o">=&gt;</span> copy_to_user<span class="o">(</span>old_slots-&gt;memslots[].dirty_map<span class="o">)</span>
   <span class="o">=&gt;</span> up_write<span class="o">(</span>kvm-&gt;slots_lock<span class="o">)</span>
</pre></table></code></div></div><p>似乎，并没有删除<code class="language-plaintext highlighter-rouge">slots_lock</code>, 但是, 该操作，确实解决了上面说的dirty bitmap的丢失问题</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>kvm_vm_ioctl_get_dirty_log                VCPU0
spinlock
SET WP
spinunlock

                                          spinlock
                                          mask_dirty to dirty bitmap
                                             rcu_deference(memslots)
                                          clear WP
                                          spinunlock
get old memslots pointer
rcu assign new kvm memslots
   with dirty_bitmap clear
wait gp

copy old memslots to user
</pre></table></code></div></div><p>因为上面使用了srcu，这样就导致，vcpu0的更新 dirty_bitmap一定会落到 old memslots pointer 锁指向的 memslots中。这样做的好处是，无需将一些对memslots更改的流程放到临界区, 影响reader 效率。但是由于是srcu，我们期望保证get_dirty_log效率，所以这里使用的是<code class="language-plaintext highlighter-rouge">synchronize_srcu_expedited</code> interface</p><p>但是后来Peter Z 推了一个改动，似乎让<code class="language-plaintext highlighter-rouge">synchronize_srcu_expedited</code>的速度变慢了， 这样就会导致, get log接口，会变慢，从而可能增加guest migration 线程处理脏页速度， 以及downtime.</p><p>avi 在<a href="https://lkml.org/lkml/2012/2/1/123">link</a> 中提到，可不可以用atomic clear 的方式，替代srcu。 并且<code class="language-plaintext highlighter-rouge">Takuya Yoshikawa</code> 在<a href="https://lkml.org/lkml/2012/2/2/6">link</a> 中测试了一个草稿，感觉效果还不错。我们来看下最终的patch改动</p><h2 id="srcu-less-get_dirty_log"><span class="me-2">srcu-less get_dirty_log</span><a href="#srcu-less-get_dirty_log" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="o">=&gt;</span> kvm_vm_ioctl_get_dirty_log
   <span class="o">=&gt;</span> for_each dirty_bitmap[i] <span class="k">in  </span>memslot-&gt;dirty_bitmap
   <span class="o">=&gt;</span> get a new dirty_bitmap
      <span class="o">=&gt;</span> dirty_bitmap_buffer <span class="o">=</span> dirty_bitmap + n / sizeof<span class="o">(</span>long<span class="o">)</span><span class="p">;</span>
      <span class="o">=&gt;</span> memset<span class="o">(</span>dirty_bitmap_buffer, 0, n<span class="o">)</span><span class="p">;</span>
   <span class="o">=&gt;</span> spin_lock<span class="o">(</span>&amp;kvm-&gt;mmu_lock<span class="o">)</span><span class="p">;</span>
   <span class="o">=&gt;</span> foreach every long <span class="k">in </span>dirty_bitmap
      <span class="o">=&gt;</span> <span class="k">continue if </span>dirty_bitmap[] <span class="o">==</span> 0
      <span class="o">=&gt;</span> mask <span class="o">=</span> xchg<span class="o">(</span>dirty_bitmap[],0<span class="o">)</span>
      <span class="o">=&gt;</span> dirty_bitmap_buffer[] <span class="o">=</span> mask
      <span class="o">=&gt;</span> kvm_mmu_write_protect_pt_mask<span class="o">(</span>mask<span class="o">)</span>
         <span class="o">{</span>
            unsigned long <span class="k">*</span>rmapp<span class="p">;</span>

            <span class="k">while</span> <span class="o">(</span>mask<span class="o">)</span> <span class="o">{</span>
                    <span class="c"># 获取first set bit</span>
                    <span class="c"># 找到其rmapp, 通过rmapp, 让spte WP</span>
                    rmapp <span class="o">=</span> &amp;slot-&gt;rmap[gfn_offset + __ffs<span class="o">(</span>mask<span class="o">)]</span><span class="p">;</span>
                    __rmap_write_protect<span class="o">(</span>kvm, rmapp, PT_PAGE_TABLE_LEVEL<span class="o">)</span><span class="p">;</span>
                    <span class="c"># clear first set bit</span>
                    /<span class="k">*</span> clear the first <span class="nb">set </span>bit <span class="k">*</span>/
                    mask &amp;<span class="o">=</span> mask - 1<span class="p">;</span>
            <span class="o">}</span>
         <span class="o">}</span> <span class="c"># kvm_mmu_write_protect_pt_mask end</span>
   <span class="o">=&gt;</span> spin_unlock<span class="o">(</span>&amp;kvm-&gt;mmu_lock<span class="o">)</span><span class="p">;</span>

<span class="c"># mark_page_dirty流程</span>

mark_page_dirty
<span class="o">=&gt;</span> mark_page_dirty_in_slot
   <span class="o">=&gt;</span> set_le_bit<span class="o">(</span>gfn, bitmap<span class="o">)</span>
</pre></table></code></div></div><p>将srcu删除，替换成了atomic操作(xchg). 这样可以让 mark_page_dirty 在不加<code class="language-plaintext highlighter-rouge">mmu_lock</code>的场景下执行，虽然<code class="language-plaintext highlighter-rouge">tdp_page_fault</code>在执行<code class="language-plaintext highlighter-rouge">__direct_map</code> 时，还是全程加着<code class="language-plaintext highlighter-rouge">mmu_lock</code></p><p>但是全程在<code class="language-plaintext highlighter-rouge">tdp_page_fault</code>流程中，全程加着<code class="language-plaintext highlighter-rouge">spin_lock(mmu_lock)</code>, 是不是 不合理呢？</p><p>为此 xiaoguangrong 在[6]中提出了fast path，可以让因wp触发的 ept violation 可以在不加<code class="language-plaintext highlighter-rouge">mmu_lock</code>的情况下fix。</p><p>patch 很大，我们简单分析(而且很多还不太明白, 不得不说，什么代码只要带着 shadow pgtable, 就非常…..)</p><h2 id="kvm-mmu-fast-page-fault"><span class="me-2">KVM: MMU: fast page fault</span><a href="#kvm-mmu-fast-page-fault" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>tdp_page_fault
  <span class="o">=&gt;</span> fast_page_fault
     <span class="o">=&gt;</span> some <span class="k">if </span>xxx
        <span class="o">=&gt;</span> goto not fast
     <span class="o">=&gt;</span> fast_pf_fix_direct_spte
        <span class="o">=&gt;</span> get_gfn
        <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>cmpxchg64<span class="o">(</span>sptep, spte, spte | PT_WRITABLE_MASK<span class="o">)</span> <span class="o">==</span> spte<span class="o">)</span>
           <span class="o">=&gt;</span> mark_page_dirty<span class="o">(</span>vcpu-&gt;kvm, gfn<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><p>这里有一些判断条件，只有判断满足一定条件，才会走fast path.条件包含哪些呢? 我们来看下commit message</p><h3 id="commit-message"><span class="me-2">commit message</span><a href="#commit-message" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre>If the the present bit of page fault error code is set, it indicates
the shadow page is populated on all levels, it means what we do is only
modify the access bit which can be done out of mmu-lock

&gt; 如果页面page fault error code的 "present" 位被设置，表示影子页表在所有级
&gt; 别上都已填充，这意味着我们所做的只是修改access位，而这可以在不持有 mmu-lock 
&gt; 的情况下完成。

The tricks in this patch is avoiding the race between fast page fault
path and write-protect path, write-protect path is a read-check-modify
path:

&gt; tricks: 技巧
&gt;
&gt; 这个补丁中的技巧是避免快速页面故障路径和写保护路径之间的竞争。
&gt; write-protect路径是一个read-check-modify 的路径：

read spte, check W bit, then clear W bit. What we do is populating a
identification in spte, if write-protect meets it, it modify the spte
even if the spte is readonly. See the comment in the code to get more
information

&gt; 读取 SPTE，检查 W 位，然后清除 W 位。我们所做的是在 SPTE 中填充一个标识符，
&gt; 如果写保护遇到它，即使 SPTE 是只读的，它也会修改 SPTE。更多信息可以查看代码
&gt; 中的注释。

* Advantage
- it is really fast
  it fixes page fault out of mmu-lock, and uses a very light way to avoid
  the race with other pathes. Also, it fixes page fault in the front of
  gfn_to_pfn, it means no host page table walking.

  它在不持有 MMU 锁的情况下修复页错误，并使用非常轻量的方法来避免与其他路径的竞争。
  此外，它在 gfn_to_pfn 之前修复页错误，这意味着不需要遍历主机页表。

- we can get lots of page fault with PFEC.P = 1 in KVM:
  - in the case of ept/npt
  　after shadow page become stable (all gfn is mapped in shadow page table,
  　it is a short stage since only one shadow page table is used and only a
  　few of page is needed), almost all page fault is caused by write-protect
  　(frame-buffer under Xwindow, migration), the other small part is caused
  　by page merge/COW under KSM/THP.

    &gt; 在影子页表变得稳定之后（所有的 gfn 都已经映射到影子页表中，这个阶段很短，
    &gt; 因为只使用一个影子页表且只需要少量的页），几乎所有的页错误都是由于写保护引
    &gt; 起的（例如在 X 窗口下的帧缓冲区或迁移时）。剩下的一小部分页错误是由于在 
    &gt; KSM（内存合并）或 THP（透明大页）下的页合并/写时复制（COW）导致的。

  We do not hope it can fix the page fault caused by the read-only host
  page of KSM, since after COW, all the spte pointing to the gfn will be
  unmapped.

  &gt; 我们并不期望它能解决由 KSM 的只读主机页引起的页错误，因为在写时复制
  &gt; （COW）之后，所有指向该 gfn 的影子页表条目（spte）都会被取消映射。

- in the case of soft mmu
  - many spurious page fault due to tlb lazily flushed
    &gt; 由于 TLB（翻译后备缓冲区）延迟刷新，导致出现许多虚假的页错误。(out-of-sync)
  - lots of write-protect page fault (dirty bit track for guest pte, shadow
    page table write-protected, frame-buffer under Xwindow, migration, ...)
    &gt; 许多写保护页错误（用于跟踪客户机 PTE 的脏位、影子页表被写保护、X 窗口下的
    &gt; 帧缓冲区、迁移等）。
</pre></table></code></div></div><p>这里提到的，如果P flag is set，那比较容易simple fixed，page fault，之前 已经做过对 fast mmio path 的处理: <code class="language-plaintext highlighter-rouge">EFFC.P=1 &amp;&amp; EFFC.RSV=1</code></p><p>而作者之后要fix的，就是除了上面的其他情况</p><p>对于EPT而言，主要有两个:</p><ul><li>因migration/Xwindow frame-buffer 导致的WP<li>KSM</ul><p>第二种作者不想simple fix, gfn相关的spte 在cow之后，可能会被umap</p><p>影子页表比较复杂，主要有:</p><ul><li>out-of-sync<li>很多的WP page fault<ul><li>track guest page dirty<li>shadow pgtable WP<li>migration<li>Xwindow frame buffer</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre>* Implementation
We can freely walk the page between walk_shadow_page_lockless_begin and
walk_shadow_page_lockless_end, it can ensure all the shadow page is valid.

在 walk_shadow_page_lockless_begin 和 walk_shadow_page_lockless_end 之间，
我们可以自由地遍历页表，这可以确保所有的影子页都是有效的。

In the most case, cmpxchg is fair enough to change the access bit of spte,
but the write-protect path on softmmu/nested mmu is a especial case: it is
a read-check-modify path: read spte, check W bit, then clear W bit. In order
to avoid marking spte writable after/during page write-protect, we do the
trick like below:

在大多数情况下，使用 cmpxchg（比较并交换）来修改影子页表条目（spte）的访问位
已经足够。然而，在softmmu/nested MMU 上的写保护路径是一个特殊情况：
这是一个read-check-modify路径：
read spte，check W bit，然后clear W bit。
为了避免在页写保护之后或期间错误地将 spte 标记为可写，我们采取以下技巧：

      fast page fault path:
            lock RCU
            set identification in the spte
            smp_mb()
            if (!rmap.PTE_LIST_WRITE_PROTECT)
                 cmpxchg + w - vcpu-id
            unlock RCU

      write protect path:
            lock mmu-lock
            set rmap.PTE_LIST_WRITE_PROTECT
                 smp_mb()
            if (spte.w || spte has identification)
                 clear w bit and identification
            unlock mmu-lock

Setting identification in the spte is used to notify page-protect path to
modify the spte, then we can see the change in the cmpxchg.

&gt; 在影子页表条目（spte）中设置标识用于通知写保护路径以修改 spte，
&gt; 这样我们就可以在 cmpxchg 操作中看到变化。

Setting identification is also a trick: it only set the last bit of spte
that does not change the mapping and lose cpu status bits.

&gt; 设置标识也是一种技巧：它仅设置 spte 的最后一位，这不会改变映射，
&gt; 也不会丢失 CPU 状态位。
</pre></table></code></div></div><blockquote><p>NOTE</p><p>patch理解起来较困难，需要进一步学习, 我们下面简单列举下代码</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
遗留问题!!!!!!
!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
</pre></table></code></div></div></blockquote><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>tdp_page_fault
  <span class="o">=&gt;</span> fast_page_fault
     <span class="o">=&gt;</span> fast_pf_fix_direct_spte
        <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>cmpxchg64<span class="o">(</span>sptep, spte, spte | PT_WRITABLE_MASK<span class="o">)</span> <span class="o">==</span> spte<span class="o">)</span>
           <span class="o">=&gt;</span> mark_page_dirty
</pre></table></code></div></div><h2 id="split-retrieval-and-clearing-of-dirty-log"><span class="me-2">split retrieval and clearing of dirty log</span><a href="#split-retrieval-and-clearing-of-dirty-log" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre>There are two problems with KVM_GET_DIRTY_LOG.  First, and less important,
it can take kvm-&gt;mmu_lock for an extended period of time.  Second, its user
can actually see many false positives in some cases.  The latter is due
to a benign race like this:

  1. KVM_GET_DIRTY_LOG returns a set of dirty pages and write protects
     them.
  2. The guest modifies the pages, causing them to be marked ditry.
  3. Userspace actually copies the pages.
  4. KVM_GET_DIRTY_LOG returns those pages as dirty again, even though
     they were not written to since (3).

KVM_GET_DIRTY_LOG 存在两个问题。

首先（虽然不太重要），它可能会长时间持有 kvm-&gt;mmu_lock。其次，在某些情况
下，用户实际上可能会看到许多误报。后者是由于以下良性竞争条件导致的：

  1. KVM_GET_DIRTY_LOG 返回一组脏页并对其进行写保护。
  2. guest 修改了这些页面，使其被标记为脏。
  3. 用户空间实际复制了这些页面。
  4. KVM_GET_DIRTY_LOG 再次将这些页面返回为脏，即使自步骤（3）之后它们并
     未被写入。

This is especially a problem for large guests, where the time between
(1) and (3) can be substantial.  This patch introduces a new
capability which, when enabled, makes KVM_GET_DIRTY_LOG not
write-protect the pages it returns.  Instead, userspace has to
explicitly clear the dirty log bits just before using the content
of the page.  The new KVM_CLEAR_DIRTY_LOG ioctl can operate on a
64-page granularity rather than requiring to sync a full memslot.
This way the mmu_lock is taken for small amounts of time, and
only a small amount of time will pass between write protection
of pages and the sending of their content.

&gt; 这在大型客户机中尤其是个问题，因为步骤（1）和（3）之间的时间可能很长。
&gt; 这个补丁引入了一种新功能，当启用时，使 KVM_GET_DIRTY_LOG 不再写保护它
&gt; 返回的页面。相反，用户空间必须在使用页面内容之前显式清除脏日志位。新
&gt; 的 KVM_CLEAR_DIRTY_LOG ioctl 可以以 64 页的粒度操作，而不需要同步整个
&gt; 内存槽。这样，mmu_lock 只会被短暂持有，并且在页面写保护和发送其内容之
&gt; 间只会经过很短的时间。

This is entirely implemented in generic code, but only users of
kvm_get_dirty_log_protect get the support (that is x86_64, ARM and MIPS).

&gt; 这一功能完全在通用代码中实现，但只有使用 kvm_get_dirty_log_protect 
&gt; 的用户（即 x86_64、ARM 和 MIPS）才能获得支持。
</pre></table></code></div></div><p>主要改动有几个方面:</p><ul><li>增加<code class="language-plaintext highlighter-rouge">KVM_CAP_MANUAL_DIRTY_LOG_PROTECT</code><li>modify <code class="language-plaintext highlighter-rouge">kvm_get_dirty_log_protect</code><li>add <code class="language-plaintext highlighter-rouge">kvm_clear_dirty_log_protect</code></ul><p>首先我们看下CAP部分, 在<code class="language-plaintext highlighter-rouge">Documentation/virtual/kvm/api.txt</code>新增解释:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre>7.18 KVM_CAP_MANUAL_DIRTY_LOG_PROTECT

Architectures: all
Parameters: args[0] whether feature should be enabled or not

With this capability enabled, KVM_GET_DIRTY_LOG will not automatically
clear and write-protect all pages that are returned as dirty.
Rather, userspace will have to do this operation separately using
KVM_CLEAR_DIRTY_LOG.

At the cost of a slightly more complicated operation, this provides better
scalability and responsiveness for two reasons.  First,
KVM_CLEAR_DIRTY_LOG ioctl can operate on a 64-page granularity rather
than requiring to sync a full memslot; this ensures that KVM does not
take spinlocks for an extended period of time.  Second, in some cases a
large amount of time can pass between a call to KVM_GET_DIRTY_LOG and
userspace actually using the data in the page.  Pages can be modified
during this time, which is inefficint for both the guest and userspace:
the guest will incur a higher penalty due to write protection faults,
while userspace can see false reports of dirty pages.  Manual reprotection
helps reducing this time, improving guest performance and reducing the
number of dirty log false positives.

参数：args[0] 指示是否应启用该功能。

启用此功能后，KVM_GET_DIRTY_LOG 将不会自动清除并写保护所有返回为脏
的页面。相反，用户空间需要使用 KVM_CLEAR_DIRTY_LOG 单独执行此操作。

尽管操作稍微复杂了一些，但这提供了更好的可扩展性和响应性，原因有两个。
首先，KVM_CLEAR_DIRTY_LOG ioctl 可以以 64 页的粒度操作，而不需要同步
整个memslot；这确保了 KVM 不会长时间持有自旋锁。其次，在调用 
KVM_GET_DIRTY_LOG 和用户空间实际使用页面中的数据之间，可能会经过很长
时间。在此期间，页面可能被修改，这对客户机和用户空间来说都是低效的：
客户机将因为写保护错误而遭受更高的惩罚，而用户空间可能会看到脏页的错
误报告。手动重新保护有助于缩短这段时间，提高客户机性能并减少脏日志的
误报数量。
</pre></table></code></div></div><p>我们来用图看下为什么要，做get /clear 接口分离:</p><details open=""> <summary>图示展开</summary><ol><li><p>此时迁移两个页，看起来工作的不错:</p><p>第二轮get_dirty_log bitmap, 恰好能表示source target两端页dirty状态</p><p><img src="./pic/get_dirty_log_send_to_page_well.svg" alt="get_dirty_log_send_to_page_well" /></p><li><p>下面的情况，由于脏页似乎比较集中，在migration 线程还未send page2, page2 又被更改了，此时bitmap已经置位。随后，migration线程send page2， 此时source dest page2，相同。</p><p>但是dirty_bitmap中，有page2 bit置位，意味着还需要再次无意义传递一次 page2</p><p><img src="./pic/get_dirty_log_send_to_page_not_well.svg" alt="get_dirty_log_send_to_page_not_well" /></p><li><p>作者想，能不能将get log和clear log, 分开. 由guest决定什么时候，将 bitmap clear掉，避免发送重复的页。如下图:</p><p><img src="./pic/save_page_in_get_and_clear_log.svg" alt="save_page_in_get_and_clear_log" /></p><p>等guest将page send出去之后，再clear掉 dirty_bitmap, 能尽量延迟bitmap的 clear. 岂不是美滋滋。</p><li><p>但是这样似乎有些问题, 中间如果发生了WP，则会丢失该dirty page.</p><p><img src="./pic/save_pages_big_bug.svg" alt="save_pages_big_bug.svg" /></p><li><p>这样来看，clear_dirty_log，还是应该在save page之前，只不过要让窗口越小 越好</p><p><img src="./pic/clear_before_save.svg" alt="clear_before_save" /></p></ol></details><p>代码部分不再展开:</p><p><code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_get_dirty_log</code>, 主要是新增了<code class="language-plaintext highlighter-rouge">manual_dirty_log_protect</code> 处理分支，如下:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>kvm_get_dirty_log_protect
  <span class="o">=&gt;</span> <span class="k">if </span>manual_dirty_log_protect is <span class="nb">true</span>
     <span class="o">=&gt;</span> get dirty_bitmap
  <span class="o">=&gt;</span> <span class="k">else</span>
     <span class="o">=&gt;</span> get dirty_bitmap and clean
  <span class="o">=&gt;</span> copy_to_user<span class="o">(</span>bitmap<span class="o">)</span>
</pre></table></code></div></div><p>新增了一个判断分支，该处理分支，和原来逻辑不同的是，没有clear bitmap</p><p><code class="language-plaintext highlighter-rouge">kvm_clear_dirty_log_protect</code>:</p><p>新增参数数据结构:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">kvm_clear_dirty_log</span> <span class="p">{</span>
       <span class="n">__u32</span> <span class="n">slot</span><span class="p">;</span>
       <span class="n">__u32</span> <span class="n">num_pages</span><span class="p">;</span>
       <span class="n">__u64</span> <span class="n">first_page</span><span class="p">;</span>
       <span class="k">union</span> <span class="p">{</span>
               <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span> <span class="cm">/* one bit per page */</span>
               <span class="n">__u64</span> <span class="n">padding</span><span class="p">;</span>
       <span class="p">};</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>dirty_bitmap: for each bit that is set in the input bitmap, the corresponding page is marked “clean” in KVM’s dirty bitmap.<li>first_page: dirty_bitmap[0]:0 ‘s page, must multiple 64<li>num_pages: mast multiple 64, or first_page + num_pages = dirty_bitmap[end]</ul><p>该数据结构, 用来向kvm传递, 可以传递一个区间到KVM, 让kvm来clear dirty bit。</p><p>clear主要流程如下:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>kvm_vm_ioctl_clear_dirty_log
   =&gt; mutex_lock(&amp;kvm-&gt;slots_lock);
   =&gt; kvm_clear_dirty_log_protect(kvm, log, &amp;flush);
      =&gt; for_each_long in log-&gt;dirty_bitmap[] as mask
         =&gt; p = memslot-&gt;dirty_bitmap[]
         # 与非操作, p = ~mask &amp; p ,
         =&gt; mask &amp;= atomic_long_fetch_andnot(mask, p)
   =&gt; mutex_unlock(&amp;kvm-&gt;slots_lock);
</pre></table></code></div></div><p>##</p><h2 id="相关commitlink"><span class="me-2">相关commit/link</span><a href="#相关commitlink" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>KVM: VMX: Enable EPT feature for KVM<ul><li><code class="language-plaintext highlighter-rouge">1439442c7b257b47a83aea4daed8fbf4a32cdff9</code><li>Sheng Yang(Mon Apr 28 12:24:45 2008)</ul><li>KVM: use SRCU for dirty log<ul><li>b050b015abbef8225826eecb6f6b4d4a6dea7b79<li>Marcelo Tosatti(Wed Dec 23 14:35:22 2009)<li>[1]. <a href="https://lore.kernel.org/kvm/4B375E10.8050805@redhat.com/">convert slotslock to SRCU</a></ul><li>srcu: Implement call_srcu()<ul><li>Peter Zijlstra(Jan 30 2012)<li>https://lkml.org/lkml/2012/1/31/211</ul><li>KVM: Switch to srcu-less get_dirty_log()<ul><li>60c34612b70711fb14a8dcbc6a79509902450d2e<li>Takuya Yoshikawa(Sat Mar 3 14:21:48 2012 +0900)<li><a href="https://lore.kernel.org/kvm/20120303141251.ffe0c0b9482f97f4a1b4dc2b@gmail.com/T/#m101c6b67dad826d484f57364dbc3c35ec04c6380">mail</a></ul><li>dirty_log_perf test<ul><li><a href="https://patchwork.kernel.org/project/linux-kselftest/patch/20201027233733.1484855-6-bgardon@google.com/#23734103">mail</a></ul><li>KVM: MMU: fast page fault<ul><li><a href="https://lore.kernel.org/lkml/4F742951.7080003@linux.vnet.ibm.com/">v1</a><li><a href="https://lore.kernel.org/all/4FFD807D.1020509@redhat.com/">v7</a><li>Xiao Guangrong(Thu, 29 Mar 2012)</ul><li>kvm: split retrieval and clearing of dirty log<ul><li>Paolo Bonzini(28 Nov 2018)<li>2a31b9db153530df4aa02dac8c32837bf5f47019<li>https://patchwork.kernel.org/project/kvm/cover/1543405379-21910-1-git-send-email-pbonzini@redhat.com/</ul><li>KVM: x86: enable dirty log gradually in small chunks<ul><li>Jay Zhou(Thu, 27 Feb 2020)<li>https://lore.kernel.org/all/20200227013227.1401-1-jianjay.zhou@huawei.com/#r</ul></ol><h2 id="附录"><span class="me-2">附录</span><a href="#附录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="virtkvmlockingrst"><span class="me-2">virt/kvm/locking.rst</span><a href="#virtkvmlockingrst" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>NOTE</p><p>在kernel doc <code class="language-plaintext highlighter-rouge">virt/kvm/locking.rst</code>中也有提到:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre>Fast page fault:

Fast page fault is the fast path which fixes the guest page fault out of
the mmu-lock on x86. Currently, the page fault can be fast in one of the
following two cases:

1. Access Tracking: The SPTE is not present, but it is marked for access
   tracking. That means we need to restore the saved R/X bits. This is
   described in more detail later below.

2. Write-Protection: The SPTE is present and the fault is caused by
   write-protect. That means we just need to change the W bit of the spte.

What we use to avoid all the races is the Host-writable bit and MMU-writable bit
on the spte:

- Host-writable means the gfn is writable in the host kernel page tables and in
  its KVM memslot.
- MMU-writable means the gfn is writable in the guest's mmu and it is not
  write-protected by shadow page write-protection.

On fast page fault path, we will use cmpxchg to atomically set the spte W
bit if spte.HOST_WRITEABLE = 1 and spte.WRITE_PROTECT = 1, to restore the saved
R/X bits if for an access-traced spte, or both. This is safe because whenever
changing these bits can be detected by cmpxchg.
</pre></table></code></div></div><p>目前upstream 的x86 fast path fault, 可以在不拿<code class="language-plaintext highlighter-rouge">mmu-lock</code>的情况下， 完成某些 guest page fault 的fix。主要有两种类型</p><ol><li>Access Tracking; SPTE 不是我们仅需要 restore saved R/X bit.(对比xiaoguangrong patch 新增)<li>Write-Protection: 我们仅需要spte change W bit</ol><p>增加了两个spte上的flag:</p><p>Host-writeable: 表示host kernel page table 是writeable的。 MMU-writeable: 表示 gfn 是writeable的，并且 shadow page 并没有用写保护保护起来</p><p>在fast PF path 中， 使用 cmpxchg 来atomically set W bit if spte &amp; (HOST_WRITEABLE | WRITE_PROTECT) == 1</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/live-migration/">live_migration</a>, <a href="/categories/dirty-bitmap/">dirty-bitmap</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/dirty-bitmap/" class="post-tag no-text-decoration" >dirty-bitmap</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=dirty-bitmap%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fkvm-dirty_bitmap%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=dirty-bitmap%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fkvm-dirty_bitmap%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fkvm-dirty_bitmap%2F&text=dirty-bitmap%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/RMM/">[arm] RMM</a><li class="text-truncate lh-lg"> <a href="/posts/sched/">schedule: overflow</a><li class="text-truncate lh-lg"> <a href="/posts/HOWTO-study-Linux-kernel/">How To study Linux kernel and become a committer</a><li class="text-truncate lh-lg"> <a href="/posts/learn-CCA/">[arm] learn CCA</a><li class="text-truncate lh-lg"> <a href="/posts/RME-spec/">[arm] RME(spec)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/live-migration-workflow/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">live migration</h4><div class="text-muted"><p>热迁移简述 热迁移(live migration) 可以在虚拟机正在RUNNING时，对用户透明的从 source host 迁移到dest host. 涉及迁移对象种类 热迁移的流程会大概包含几个对象: cpu 内存 设备 主要工作 而热迁移主要工作是将这几个对象的信息，从原...</p></div></div></a></article><article class="col"> <a href="/posts/Migration-auto-converge-problem/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">[Translate]: Migration auto-converge problem</h4><div class="text-muted"><p>From: &quot;Jason J. Herne&quot; &amp;lt;jjherne@linux.vnet.ibm.com&amp;gt; To: &quot;qemu-devel@nongnu.org qemu-devel&quot; &amp;lt;qemu-devel@nongnu.org&amp;gt;, Christian Borntraeger &amp;lt;borntraeger@de.ibm.com&amp;gt; Subject: [Qemu-...</p></div></div></a></article><article class="col"> <a href="/posts/auto-converge/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">auto-converge</h4><div class="text-muted"><p># 简介 在大型机器，并且系统负载高时热迁移，工作负载往往比热迁移速度更快，从而导致 live migration无法 converge. 这个往往受限于bandwidth, 虽然现在网卡的带宽越来越高。但是虚拟机的核心数量 以及cpu主频，内存带宽也在逐渐增大。 Chegu Vinod 在 2013 年提出了 auto-converge, （但是的场景即使使用了10Gig NICs也...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/auto-converge/" class="btn btn-outline-primary" aria-label="Older" ><p>auto-converge</p></a> <a href="/posts/dirty-ring/" class="btn btn-outline-primary" aria-label="Newer" ><p>dirty-ring</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
