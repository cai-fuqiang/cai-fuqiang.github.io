<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="kernel PML" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="PML &amp;&amp; WP" /><meta property="og:description" content="PML &amp;&amp; WP" /><link rel="canonical" href="/posts/kernel-pml/" /><meta property="og:url" content="/posts/kernel-pml/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-19T09:50:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="kernel PML" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2024-11-19T09:50:00+08:00","datePublished":"2024-11-19T09:50:00+08:00","description":"PML &amp;&amp; WP","headline":"kernel PML","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/kernel-pml/"},"url":"/posts/kernel-pml/"}</script><title>kernel PML | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>kernel PML</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>kernel PML</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1731981000" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 19, 2024 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3919 words" > <em>21 min</em> read</span></div></div></div></header><div class="content"><h2 id="pml--wp"><span class="me-2">PML &amp;&amp; WP</span><a href="#pml--wp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>PML 和 WP 起到的作用是一样的，只不过PML可以达到一种batch WP的效果:</p><p><img src="./pic/pml_write.svg" alt="pml write " /></p><p>PML index始终指向 next PML entry, 每次record PML时，PML index 会dec, 并且check <code class="language-plaintext highlighter-rouge">--PML_index</code>的值, 是否在<code class="language-plaintext highlighter-rouge">[0, 511]</code>范围之内. 当PML index=0时， 如果此时再record PML, 则会触发<code class="language-plaintext highlighter-rouge">--pml_index=0xffff</code>, PML index 则不在 <code class="language-plaintext highlighter-rouge">[0, 511]</code>, 此时会broken当前的write 操作，并VM-exit。</p><p>PML table大小为4096, 每一个entry 大小为8-byte, 保存着 dirty page的PFN.</p><p>其中，<font color="red">红色</font><font color="green">绿色</font>， 两次write 操作在执行时，不会触发VM-exit，而是在write操作过程中，如果 需要dirty EPT entry, 则在PML中新增一个由 PML index指向的entry</p><p>另外，如果该指向该page 的 EPTE 已经mask dirty, 如黑色wrte，则本次写操作， 不会记录PML中。</p><p>我们再来横向比较下 WP 和 PML:</p><div class="table-wrapper"><table><thead><tr><th>比较项<th>WP<th>PML<tbody><tr><td>How To Catch Write operation in VM<td>clear EPTE w bit<td>clear EPTE dirty bit<tr><td>How To non-Cache Write in VM<td>set EPTE w bit<td>set EPTE dirty bit<tr><td>When VM-exit<td>write WP page<td>PML buffer FULL<tr><td>The maximum number of dirty<br />pages that can be captured between <br />a VM-entry and a VM-exit<td>1<td>512</table></div><p>从上面对比图来看，PML 和WP很像</p><ul><li>WP关注<code class="language-plaintext highlighter-rouge">W</code> flag, 而PML关注<code class="language-plaintext highlighter-rouge">D</code> flag, 两者是只关注EPTE中的一个flag<li>write clean page to dirty 在这两种用法中都可能会造成额外的VM-exit用来catch该 write operation。只不过<ul><li>WP: 只能<font color="green">catch one</font><li>PML: <font color="red">**catch 512**</font></ul></ul><p>所以上面的相同不同之处，就导致PML可以比较完美的嵌入到当前的WP dirty log框架中，并且 由于其batch catch的特性，会提升系统性能(见<a href="https://lore.kernel.org/all/1422413668-3509-1-git-send-email-kai.huang@linux.intel.com/">mail list</a>), 大致有4%～5%的性能提升)。</p><p>接下来主要来分析下patch:</p><h2 id="patch-分析"><span class="me-2">patch 分析</span><a href="#patch-分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先一部分patch 是为了解决上面提到的<code class="language-plaintext highlighter-rouge">WP</code>和<code class="language-plaintext highlighter-rouge">PML</code>track dirty page的方式差异(一个是关注D flag, 一个是关注W flag)。</p><h3 id="deference-of-track-dirty-pagewp-vs-pml"><span class="me-2">Deference of Track Dirty Page(WP vs PML)</span><a href="#deference-of-track-dirty-pagewp-vs-pml" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>modify <code class="language-plaintext highlighter-rouge">kvm_arch_mmu_write_protect_pt_masked</code>-&gt;<code class="language-plaintext highlighter-rouge">kvm_arch_mmu_enable_log_dirty_pt_masked</code></p><p>目前针对spte的clear dirty log 有两种方式, <code class="language-plaintext highlighter-rouge">clear W flag(WP)</code> or <code class="language-plaintext highlighter-rouge">clear D flag(PML)</code>, 所以命名也应该微调下（不能再以wp的命名方式命名, 应该更通用写）</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="p">@@ -1059,7 +1059,7 @@</span> int kvm_get_dirty_log_protect(struct kvm *kvm,
 		dirty_bitmap_buffer[i] = mask;
   
 		offset = i * BITS_PER_LONG;
<span class="gd">-		kvm_arch_mmu_write_protect_pt_masked(kvm, memslot, offset,
</span><span class="gi">+		kvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot, offset,
</span> 								mask);
 	}
 
</pre></table></code></div></div><blockquote><p>from <a href="https://lore.kernel.org/all/1422413668-3509-2-git-send-email-kai.huang@linux.intel.com/">patch1</a></p></blockquote><li><p>avoid unnecessary PML record</p><details open=""> <summary>avoid unnecessary PML record details</summary><p>在没有引入PML之前，shadow pgtable中的dirty bit is too “chicken rib”(鸡肋), 或者说毫无用途。 但是引入了PML之后，dirty bit 就类似与W bit，用来”通知 VMX non-root operation”要不要去track 该page, 所以我们需要在不需要track this page 的流程中，mark EPTE’s D flag.</p><p>eg:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="p">@@ -2597,8 +2597,14 @@</span> static int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 		}
 	}
   
<span class="gd">-	if (pte_access &amp; ACC_WRITE_MASK)
</span><span class="gi">+	if (pte_access &amp; ACC_WRITE_MASK) {
</span> 		mark_page_dirty(vcpu-&gt;kvm, gfn);
<span class="gi">+		/*
+		 * Explicitly set dirty bit. It is used to eliminate unnecessary
+		 * dirty GPA logging in case of PML is enabled on VMX.
+		 */
+		spte |= shadow_dirty_mask;
+	}
</span></pre></table></code></div></div><p>因为已经<code class="language-plaintext highlighter-rouge">mark_page_dirty()</code>, 所以没有必要在track this dirty-ed page</p><p>另外还有一个地方，就是在<code class="language-plaintext highlighter-rouge">fast pf fix</code>路径，但是作者认为该路径在开启PML之后，一般不会走到:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="p">@@ -2914,6 +2920,16 @@</span> fast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,
 	 */
 	gfn = kvm_mmu_page_get_gfn(sp, sptep - sp-&gt;spt);
  
<span class="gi">+	/*
+	 * Theoretically we could also set dirty bit (and flush TLB) here in
+	 * order to eliminate the unnecessary PML logging. See comments in
+	 * set_spte. But as in case of PML, fast_page_fault is very unlikely to
+	 * happen so we leave it unchanged. This might result in the same GPA
+	 * to be logged in PML buffer again when the write really happens, and
+	 * eventually to be called by mark_page_dirty twice. But it's also no
+	 * harm. This also avoids the TLB flush needed after setting dirty bit
+	 * so non-PML cases won't be impacted.
</span><span class="err">
</span>   理论上，我们也可以在这里设置脏位（并刷新TLB），以消除不必要的PML日志记录。
   请参阅set_spte中的注释。但是，由于在PML的情况下，fast_page_fault发生的可
   能性非常小，因此我们将其保持不变。这可能会导致在实际写入时，同一GPA被再次
   记录在PML缓冲区中，最后可能会被mark_page_dirty两次调用。但这也没有什么害处。
   这样做还可以避免在设置脏位后需要的TLB刷新，从而不会影响非PML情况。
<span class="err">
</span><span class="gi">+	 */
</span> 	if (cmpxchg64(sptep, spte, spte | PT_WRITABLE_MASK) == spte)
 		mark_page_dirty(vcpu-&gt;kvm, gfn);
</pre></table></code></div></div><p>这里是作者懒么，显然不是，作者很勤奋的写了一大段comment来说明为什么不去做:</p><p>可能性很小，另外，如果在这里增加set dirty bit代码，并且流程真的走到了该分支， 那就需要 TLB flush, 这个代价太大了，并且会影响非PML的情景。</p><p>那第一个场景不是也类似于该场景，需要flush tlb么？但是</p><ul><li><code class="language-plaintext highlighter-rouge">set_spte</code>触发频率高很多<li><code class="language-plaintext highlighter-rouge">set_spte</code>很大概率会modify spte，大概率会走到flush tlb，所以，综合来看，增加的开销不大。</ul><blockquote><p>from <a href="https://lore.kernel.org/all/1422413668-3509-4-git-send-email-kai.huang@linux.intel.com/">patch3</a></p></blockquote></details><li><p>更改原有<code class="language-plaintext highlighter-rouge">set_memory_region</code>的一些逻辑, 大概流程为:</p><details open=""> <summary>set_memory_region change details</summary><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre>kvm_vm_ioctl
<span class="o">=&gt;</span> kvm_vm_ioctl_set_memory_region
   <span class="o">=&gt;</span> kvm_set_memory_region
      <span class="o">=&gt;</span> __kvm_set_memory_region
         <span class="o">=&gt;</span> kvm_arch_commit_memory_region
            <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>change <span class="o">!=</span> KVM_MR_DELETE<span class="o">)</span>
                 kvm_mmu_slot_apply_flags<span class="o">(</span>kvm, new<span class="o">)</span>

kvm_mmu_slot_apply_flags
<span class="o">=&gt;</span> <span class="k">if </span>new flag &amp; KVM_MEM_READONLY
   <span class="c">## 仍然需要 WP</span>
   <span class="o">=&gt;</span> kvm_mmu_slot_remove_write_access
      <span class="k">return</span>
<span class="c">## 开启DIRTY log</span>
<span class="o">=&gt;</span> new-&gt;flags &amp; KVM_MEM_LOG_DIRTY_PAGES 
   <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>kvm_x86_ops-&gt;slot_enable_log_dirty<span class="o">)</span>
      <span class="o">=&gt;</span> kvm_x86_ops-&gt;slot_enable_log_dirty<span class="o">(</span>kvm, new<span class="o">)</span><span class="p">;</span> <span class="c">## vmx_slot_enable_log_dirty</span>
         <span class="c">## handle pages of normal page size </span>
         <span class="o">=&gt;</span> kvm_mmu_slot_leaf_clear_dirty
            <span class="c"># 只查找 page table level</span>
            <span class="o">=&gt;</span> foreach rmmap <span class="k">in </span>memslot-&gt;arch.rmap[PT_PAGE_TABLE_LEVEL - 1]
               <span class="c"># clear dirty means，all page table level in slot will record to PML</span>
               <span class="o">=&gt;</span> flush |<span class="o">=</span> __rmap_clear_dirty<span class="o">(</span>kvm, rmapp<span class="o">)</span>
               <span class="o">=&gt;</span> <span class="k">if </span>flush
                  <span class="o">=&gt;</span> kvm_flush_remote_tlbs
         <span class="c">## handle pages of large page</span>
         <span class="c">## WHY? ===(1)===</span>
         <span class="o">=&gt;</span> kvm_mmu_slot_largepage_remove_write_access
            <span class="c">## level &gt;  PT_PAGE_TABLE_LEVEL</span>
            <span class="o">=&gt;</span> foreach every level i <span class="o">(&gt;</span> PT_PAGE_TABLE_LEVEL<span class="o">)</span>
               <span class="o">=&gt;</span> foreach rmmap <span class="k">in </span>memslot-&gt;arch.rmap[i - PT_PAGE_TABLE_LEVEL]
                  <span class="o">=&gt;</span> flush |<span class="o">=</span> __rmap_write_protect<span class="o">(</span>kvm, rmapp, <span class="nb">false</span><span class="o">)</span>
            <span class="o">=&gt;</span> <span class="k">if </span>flush
               <span class="o">=&gt;</span> kvm_flush_remote_tlbs<span class="o">(</span>kvm<span class="o">)</span>
   <span class="o">=&gt;</span> <span class="k">else</span> 
      <span class="o">=&gt;</span> kvm_mmu_slot_remove_write_access<span class="o">(</span>kvm, new<span class="o">)</span>
         <span class="c">## foreach level, &gt;= PT_PAGE_TABLE_LEVEL</span>
         <span class="o">=&gt;</span> foreach every level i 
            <span class="o">=&gt;</span> foeach rmapp <span class="k">in </span>memslot-&gt;arch.rmap[i - PT_PAGE_TABLE_LEVEL]
               <span class="o">=&gt;</span> flush |<span class="o">=</span> __rmap_write_protect<span class="o">(</span>kvm, rmapp, <span class="nb">false</span><span class="o">)</span>
               <span class="o">=&gt;</span> <span class="k">if </span>flush 
                  <span class="o">=&gt;</span> kvm_flush_remote_tlbs<span class="o">(</span>kvm<span class="o">)</span>

<span class="c">## 关闭DIRTY log</span>
<span class="o">=&gt;</span> <span class="k">else</span> 
   <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>kvm_x86_ops-&gt;slot_disable_log_dirty<span class="o">)</span>
      <span class="o">=&gt;</span> kvm_x86_ops-&gt;slot_disable_log_dirty<span class="o">(</span>kvm, new<span class="o">)</span> <span class="c">## vmx_slot_disable_log_dirty</span>
         <span class="c">## ===(2)===</span>
         <span class="o">=&gt;</span> kvm_mmu_slot_set_dirty
            <span class="o">=&gt;</span> foreach every level i
               <span class="o">=&gt;</span> foreach rmapp <span class="k">in </span>memslot-&gt;arch.rmap[i - PT_PAGE_TABLE_LEVEL]
                  <span class="o">=&gt;</span> flush |<span class="o">=</span> __rmap_set_dirty<span class="o">(</span>kvm, rmapp<span class="o">)</span><span class="p">;</span>
            <span class="o">=&gt;</span> <span class="k">if </span>flush
               <span class="o">=&gt;</span> kvm_flush_remote_tlbs<span class="o">(</span>kvm<span class="o">)</span>
</pre></table></code></div></div><p>我们需要关注两个问题(也是两个和WP不同的点)</p><ol><li><p>当遇到huge page 时，不能简单的clear dirty bit.</p><p><img src="./pic/pml_write_hugepage.svg" alt="pml_write_hugepage" /></p><p>如果<code class="language-plaintext highlighter-rouge">EPT-PMD</code>如果映射了大页，对一个hugepage进行跨”<code class="language-plaintext highlighter-rouge">PAGE_SIZE</code>“访问，则会导致PML中只记录 一个write操作.</p><p>并且和<code class="language-plaintext highlighter-rouge">WP</code>不同的是，由于<code class="language-plaintext highlighter-rouge">PML</code>是类似于”auto batch WP”, 这两次write操作，无法分别进行catch， (但是WP可以), 所以如果我们想<code class="language-plaintext highlighter-rouge">mark_page_dirty(one normal pagesize page)</code>, 就不能让这两次 write操作连续执行下去，所以，这里对大页进行了<code class="language-plaintext highlighter-rouge">WP</code>.</p><blockquote><p>当然，进行了WP之后，还有一些其他的操作，加速对大页中小页的catch。不放在本文讨论。 (之后在分析)</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>++++++++
++++++++
++++++++
遗留问题
++++++++
++++++++
</pre></table></code></div></div></blockquote><li><p>如果是PML, 需要在disable log dirty时，mark all spte dirty. 目的是，避免vcpu再次record PML。</p></ol></details></ul><h2 id="flush-pml-to-dirtymap"><span class="me-2">flush PML to dirtymap</span><a href="#flush-pml-to-dirtymap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>另外一个，主要的改动是, flush PML buffer to dirty_bitmap.主要分为.</p><ul><li><p>主动flush</p><details open=""> <summary>主动flush细节</summary><p>是指vcpu运行时，在每次vm-exit时，主动flush pml buffer</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="p">@@ -7335,6 +7474,16 @@</span> static int vmx_handle_exit(struct kvm_vcpu *vcpu)
 	u32 exit_reason = vmx-&gt;exit_reason;
 	u32 vectoring_info = vmx-&gt;idt_vectoring_info;
   
<span class="gi">+	/*
+	 * Flush logged GPAs PML buffer, this will make dirty_bitmap more
+	 * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before
+	 * querying dirty_bitmap, we only need to kick all vcpus out of guest
+	 * mode as if vcpus is in root mode, the PML buffer must has been
+	 * flushed already.
</span><span class="err">
</span>    这个代码段的目的是刷新保存了修改过的客体物理地址（GPAs）的PML（
    Page Modification Log）缓冲区。这样做的好处是可以使得dirty_bitmap
    （脏位图）more upgated，因为PML缓冲区中的信息会被同步到dirty_bitmap中。
<span class="err">
</span><span class="gi">+	 */
+	if (enable_pml)
+		vmx_flush_pml_buffer(vmx);
+
</span></pre></table></code></div></div><p>这里相当于积极的flush PML， 这样做的好处是，能更大力度保证 dirty_bitmap的真实性。 并且简化了代码，无论是不是<code class="language-plaintext highlighter-rouge">EXIT_REASON_PML_FULL</code> event，都会在这里flush。</p><p>那么我们在看下<code class="language-plaintext highlighter-rouge">EXIT_REASON_PML_FULL</code>callbak 还需不需要额外处理:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_pml_full</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">;</span>
  
        <span class="n">trace_kvm_pml_full</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">);</span>
  
        <span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
          
        <span class="c1">//==(1)== </span>
        <span class="cm">/*
         * PML buffer FULL happened while executing iret from NMI,
         * "blocked by NMI" bit has to be set before next VM entry.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                        <span class="n">cpu_has_virtual_nmis</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
                        <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_UNBLOCK_NMI</span><span class="p">))</span>
                <span class="n">vmcs_set_bits</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span>
                                <span class="n">GUEST_INTR_STATE_NMI</span><span class="p">);</span>
  
        <span class="c1">//==(2)== </span>
        <span class="cm">/*
         * PML buffer already flushed at beginning of VMEXIT. Nothing to do
         * here.., and there's no userspace involvement needed for PML.
         */</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>不是简单return。但是是为了处理 block nmi state, 当正在执行 iret NMI时，因为 PML full event, 触发了vm-exit, 此时，VM 已经是 <code class="language-plaintext highlighter-rouge">INTR_INFO_UNBLOCK_NMI</code>状态。但是处理 PML full event 应该是透明的，guest 并不认为在<code class="language-plaintext highlighter-rouge">iret-&gt;next instruction</code>中间有fault, 认为当前cpu(vcpu) 仍然是block nmi 的状态，所以, 我们需要重新设置 VM 为 block nmi state.</ol><blockquote><p>NOTE</p><p>不知道IRET指令会不会set A/D flag</p></blockquote><ol><li><code class="language-plaintext highlighter-rouge">return 1</code> 表示PML full event已经处理完。无需退回到 userspace(qemu) 处理</ol></details><li><p>notify flush</p><p>是指vcpu正在non-root operation, 其他cpu想要获取该vm最新的dirty_bitmap, 所以需要该vcpu sync this vcpu PML to dirty bitmap.</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>kvm_vm_ioctl_get_dirty_log 
<span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>kvm_x86_ops-&gt;flush_log_dirty<span class="o">)</span>
   <span class="o">=&gt;</span> kvm_x86_ops-&gt;flush_log_dirty<span class="o">(</span>kvm<span class="o">)</span><span class="p">;</span> <span class="c">## vmx_flush_log_dirty</span>
      <span class="o">=&gt;</span> kvm_flush_pml_buffers
         <span class="o">=&gt;</span> kvm_for_each_vcpu<span class="o">(</span>i, vcpu, kvm<span class="o">)</span>
            <span class="o">=&gt;</span> kvm_vcpu_kick<span class="o">(</span>vcpu<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div></ul><h2 id="参考资料"><span class="me-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>KVM: VMX: Page Modification Logging (PML) support<ul><li>Kai Huang(28 Jan 2015)<li>843e4330573cc5261ae260ce0b83dc570d8cdc05<li><a href="https://lore.kernel.org/all/1422413668-3509-1-git-send-email-kai.huang@linux.intel.com/">mail: KVM: VMX: Page Modification Logging (PML) support</a></ul><li>thp: kvm mmu transparent hugepage support<ul><li>Andrea Arcangeli <a href="mailto:aarcange@redhat.com">aarcange@redhat.com</a> (Jan 13 2011)<li>936a5fe6e6148c0b3ea0d792b903847d9b9931a1</ul><li><a href="https://arxiv.org/pdf/2001.09991">Intel Page Modification Logging, a hardware virtualization feature: study and improvement for virtual machine working set estimation</a></ul><h2 id="others"><span class="me-2">others</span><a href="#others" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="kvm-vmx-page-modification-logging-pml-support-patch0-commit翻译"><span class="me-2"><code class="language-plaintext highlighter-rouge">KVM: VMX: Page Modification Logging (PML) support</code> patch0 commit(翻译):</span><a href="#kvm-vmx-page-modification-logging-pml-support-patch0-commit翻译" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre><td class="rouge-code"><pre>This patch series adds Page Modification Logging (PML) support in VMX.

1) Introduction

PML is a new feature on Intel's Boardwell server platfrom targeted to reduce
overhead of dirty logging mechanism.

&gt; PML是英特尔的Broadwell服务器平台上的一项新功能，旨在降低脏页日志记录机制的
&gt; 开销。

The specification can be found at:

http://www.intel.com/content/www/us/en/processors/page-modification-logging-vmm-white-paper.html

Currently, dirty logging is done by write protection, which write protects guest
memory, and mark dirty GFN to dirty_bitmap in subsequent write fault. This works
fine, except with overhead of additional write fault for logging each dirty GFN.
The overhead can be large if the write operations from geust is intensive.

&gt; 目前，脏页日志记录是通过写保护来实现的，即对guest内存进行写保护，并在随后的
&gt; write fault中将脏GFN标记到脏位图中。这种方法基本上可以正常工作，但每次记录
&gt; 一个脏GFN都需要额外的写入故障，带来了较大的开销。如果guest的写入操作非常频繁，
&gt; 这种开销可能会非常大。

PML is a hardware-assisted efficient way for dirty logging. PML logs dirty GPA
automatically to a 4K PML memory buffer when CPU changes EPT table's D-bit from
0 to 1. To do this, A new 4K PML buffer base address, and a PML index were added
to VMCS. Initially PML index is set to 512 (8 bytes for each GPA), and CPU
decreases PML index after logging one GPA, and eventually a PML buffer full
VMEXIT happens when PML buffer is fully logged.

&gt; PML是一种硬件辅助的高效脏页日志记录方法。当CPU将EPT表的D位从0更改为1时，
&gt; PML会自动将脏GPA记录到一个4K的PML内存缓冲区中。为此，在VMCS中添加了一个
&gt; 新的4K PML buffer base address 和一个PML index。最初，PML index 被设置为512
&gt; （每个GPA占用8个字节），然后CPU在记录一个GPA后会减少PML index，最终当PML buffer 被
&gt; 完全记录时，会触发一个PML缓冲区满VMEXIT事件。

With PML, we don't have to use write protection so the intensive write fault EPT
violation can be avoided, with an additional PML buffer full VMEXIT for 512
dirty GPAs. Theoretically, this can reduce hypervisor overhead when guest is in
dirty logging mode, and therefore more CPU cycles can be allocated to guest, so
it's expected benchmarks in guest will have better performance comparing to
non-PML.

&gt; Theoretically : 理论上
&gt;
&gt; 使用PML后，我们不再需要使用写保护，因此可以避免频繁的write fault EPT violation 。
&gt; 相反，只需要在PML缓冲区被完全记录时触发一次PML缓冲区满VMEXIT事件（对于512个脏GPA）。
&gt; 理论上，这可以减少在脏页日志记录模式下运行的客户端的超级管理程序开销，从而可以将
&gt; 更多的CPU周期分配给guest，因此预计在客户端的基准测试中将比非PML情况具有更好的性能。

2) Design

a. Enable/Disable PML

PML is per-vcpu (per-VMCS), while EPT table can be shared by vcpus, so we need
to enable/disable PML for all vcpus of guest. A dedicated 4K page will be
allocated for each vcpu when PML is enabled for that vcpu.

&gt; "由于PML是每个vCPU（每个VMCS）的，而EPT表可以由多个vCPU共享，因此我们需要为客
&gt; 户端的所有vCPU启用/禁用PML。启用PML后，会为每个vCPU分配一个专用的4K页面。"

Currently, we choose to always enable PML for guest, which means we enables PML
when creating VCPU, and never disable it during guest's life time. This avoids
the complicated logic to enable PML by demand when guest is running. And to
eliminate potential unnecessary GPA logging in non-dirty logging mode, we set
D-bit manually for the slots with dirty logging disabled.

&gt; eliminate : 消除，排除
&gt;
&gt; 目前，我们选择在创建VCPU时始终启用PML，并且在客户端的整个生命周期中从不禁用它。
&gt; 这避免了在客户端运行时按需启用PML的复杂逻辑。为了消除 non-dirty logging mode上可
&gt; 能发生的不必要的GPA日志记录，我们手动设置了D位以禁用脏页日志记录的slot。

b. Flush PML buffer

When userspace querys dirty_bitmap, it's possible that there are GPAs logged in
vcpu's PML buffer, but as PML buffer is not full, so no VMEXIT happens. In this
case, we'd better to manually flush PML buffer for all vcpus and update the
dirty GPAs to dirty_bitmap.

&gt; 当用户空间查询 dirty_bitmap 时，可能存在一些已经被记录在 vCPU 的 PML 缓冲区中的 
&gt; GPA，但由于 PML 缓冲区还没有满，所以不会发生 VMEXIT。在这种情况下，我们最好手动
&gt; 地对所有 vCPU 的 PML 缓冲区进行刷新，并将脏 GPA 更新到 dirty_bitmap 中。这样可以
&gt; 确保 dirty_bitmap 中包含了所有的脏 GPA，即使它们还没有引起 VMEXIT。

We do PML buffer flush at the beginning of each VMEXIT, this makes dirty_bitmap
more updated, and also makes logic of flushing PML buffer for all vcpus easier
-- we only need to kick all vcpus out of guest and PML buffer for each vcpu will
be flushed automatically.

&gt; 我们在每次 VMEXIT 的开始都会对 PML 缓冲区进行刷新，这使得 dirty_bitmap 更加及
&gt; 时地反映了脏 GPA 的状态，并且简化了对所有 vCPU 的 PML 缓冲区进行刷新的逻辑 --
&gt; 我们只需要让所有的 vCPU 从客户端中退出，PML 缓冲区就会被自动地刷新。
</pre></table></code></div></div><p>commit message 后面的部分，主要展示了开启PML的性能损耗（大概在0.06%~0.45%之间). (0.06% 是在<code class="language-plaintext highlighter-rouge">--nographic</code>场景下)</p><p>以及和传统的 WP dirty log 相比，大概有(4% ~ 5%) 的提升。(作者的话是说，noticeable performance gain)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/live-migration/">live_migration</a>, <a href="/categories/kernel-pml/">kernel pml</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/kernel-pml/" class="post-tag no-text-decoration" >kernel_pml</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=kernel%20PML%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fkernel-pml%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=kernel%20PML%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fkernel-pml%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fkernel-pml%2F&text=kernel%20PML%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/learn-CCA/">[arm] learn CCA</a><li class="text-truncate lh-lg"> <a href="/posts/RME-spec/">[arm] RME(spec)</a><li class="text-truncate lh-lg"> <a href="/posts/learn-RME/">[arm] learn RME</a><li class="text-truncate lh-lg"> <a href="/posts/virtcca-paper/">[arm] virtCCA</a><li class="text-truncate lh-lg"> <a href="/posts/la57-switch_mode/">[mm:la57] switch to la57</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/live-migration-workflow/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">live migration</h4><div class="text-muted"><p>热迁移简述 热迁移(live migration) 可以在虚拟机正在RUNNING时，对用户透明的从 source host 迁移到dest host. 涉及迁移对象种类 热迁移的流程会大概包含几个对象: cpu 内存 设备 主要工作 而热迁移主要工作是将这几个对象的信息，从原...</p></div></div></a></article><article class="col"> <a href="/posts/Migration-auto-converge-problem/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">[Translate]: Migration auto-converge problem</h4><div class="text-muted"><p>From: &quot;Jason J. Herne&quot; &amp;lt;jjherne@linux.vnet.ibm.com&amp;gt; To: &quot;qemu-devel@nongnu.org qemu-devel&quot; &amp;lt;qemu-devel@nongnu.org&amp;gt;, Christian Borntraeger &amp;lt;borntraeger@de.ibm.com&amp;gt; Subject: [Qemu-...</p></div></div></a></article><article class="col"> <a href="/posts/auto-converge/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">auto-converge</h4><div class="text-muted"><p># 简介 在大型机器，并且系统负载高时热迁移，工作负载往往比热迁移速度更快，从而导致 live migration无法 converge. 这个往往受限于bandwidth, 虽然现在网卡的带宽越来越高。但是虚拟机的核心数量 以及cpu主频，内存带宽也在逐渐增大。 Chegu Vinod 在 2013 年提出了 auto-converge, （但是的场景即使使用了10Gig NICs也...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/dirty-ring/" class="btn btn-outline-primary" aria-label="Older" ><p>dirty-ring</p></a> <a href="/posts/guestperf/" class="btn btn-outline-primary" aria-label="Newer" ><p>guestperf</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
