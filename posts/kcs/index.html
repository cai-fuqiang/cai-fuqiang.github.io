<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="Keyboard Controller Style (KCS) Interface" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="abstract" /><meta property="og:description" content="abstract" /><link rel="canonical" href="/posts/kcs/" /><meta property="og:url" content="/posts/kcs/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-05-06T15:40:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Keyboard Controller Style (KCS) Interface" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2024-05-06T15:40:00+08:00","datePublished":"2024-05-06T15:40:00+08:00","description":"abstract","headline":"Keyboard Controller Style (KCS) Interface","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/kcs/"},"url":"/posts/kcs/"}</script><title>Keyboard Controller Style (KCS) Interface | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Keyboard Controller Style (KCS) Interface</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Keyboard Controller Style (KCS) Interface</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1714981200" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > May 6, 2024 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="9825 words" > <em>54 min</em> read</span></div></div></div></header><div class="content"><h2 id="abstract"><span class="me-2">abstract</span><a href="#abstract" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>This section describes the Keyboard Controller Style (KCS) Interface. The KCS interface is one of the supported BMC to SMS interfaces. The KCS interface is specified solely for SMS messages. SMM messages between the BMC and an SMI Handler will typically require a separate interface, though the KCS interface is designed so that system software can detect if a transaction was interrupted. Any BMC-to-SMI Handler communication via the KCS interface is implementation specific and is not covered by this specification.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>solely: 单独地;
</pre></table></code></div></div><p>本节介绍键盘控制器样式 (KCS) 接口。 KCS 接口是受支持的 BMC 到 SMS 接口之一。 KCS 接口专为 SMS 消息而指定。 BMC 和 SMI 处理程序之间的 SMM 消息通常需要单 独的接口，尽管 KCS 接口的设计使得系统软件可以检测事务是否被中断。 任何通 过 KCS 接口的 BMC 到 SMI 处理程序通信都是特定于实现的，并且不包含在本规范 中。</p></blockquote><p>The KCS Interface is designed to support polled operation. Implementations can optionally provide an interrupt driven from the OBF flag, but this must not prevent driver software from the using the interface in a polled manner. This allows software to default to polled operation. It also allows software to use the KCS interface in a polled mode until it determines the type of interrupt support. Methods for assigning and enabling such an interrupt are outside the scope of this specification.</p><blockquote><p>KCS 接口旨在支持轮询操作。 实现可以选择提供由 OBF flag 驱动的中断，但这不能阻 止驱动程序软件以轮询方式使用接口。 这允许软件默认进行轮询操作。 它还允许软件 以轮询模式使用 KCS 接口，直到确定中断支持的类型。 分配和启用此类中断的方法超 出了本规范的范围.</p></blockquote><h2 id="91-kcs-interfacebmc-luns"><span class="me-2">9.1 KCS Interface/BMC LUNs</span><a href="#91-kcs-interfacebmc-luns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>LUN 00b is typically used for all messages to the BMC through the KCS Interface. LUN 10b is reserved for Receive Message Queue use and should not be used for sending commands to the BMC. Note that messages encapsulated in a Send Message command can use any LUN in the encapsulated portion.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>encapsulated [ɪnˈkæpsjuleɪtɪd] : v. 压缩;概括;简述; adj. 密封的;封装的
</pre></table></code></div></div><p>LUN 00b 通常用于通过 KCS 接口发送至 BMC 的所有消息。 LUN 10b 保留供Receive Message Queue 使用，不应用于向 BMC 发送命令。 请注意，Send Message command 中封装的消息可以 使用封装部分中的任何 LUN。</p></blockquote><h2 id="92-kcs-interface-bmc-request-message-format"><span class="me-2">9.2 KCS Interface-BMC Request Message Format</span><a href="#92-kcs-interface-bmc-request-message-format" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Request Messages are sent to the BMC from system software using a write transfer through the KCS Interface. The message bytes are organized according to the following format specification:</p><blockquote><p>Request Messages 通过 KCS 接口使用写传输从系统软件发送到 BMC。 消息字节 按照以下格式规范组织：</p></blockquote><p><img src="pic/Figure-9.png" alt="Figure-9" /></p><p>Where:</p><ul><li><p><strong>LUN</strong></p><p>Logical Unit Number. This is a sub-address that allows messages to be routed to different ‘logical units’ that reside behind the same physical interface. The LUN field occupies the least significant two bits of the first message byte.</p><blockquote><p>occupy [ˈɑːkjupaɪ]: 占据; 使用，占用</p><p>这是一个子地址，允许消息路由到驻留在同一物理接口后面的不同“逻辑单元”。 LUN 字段占据第一个消息字节的最低有效两位。</p></blockquote><li><p><strong>NetFn</strong></p><p>Network Function code. This provides the first level of functional routing for messages received by the BMC via the KCS Interface. The NetFn field occupies the most significant six bits of the first message byte. Even NetFn values are used for requests to the BMC, and odd NetFn values are returned in responses from the BMC.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>even: 偶数
odd /ɑːd/: 奇数
</pre></table></code></div></div><p>Network Function Code。 这为 BMC 通过 KCS 接口接收的消息提供第一级功能路由。 NetFn 字段占据第一个消息字节的最高有效六位。 偶数 NetFn 值用于向 BMC 发出 请求，奇数 NetFn 值在 BMC 的响应中返回。</p></blockquote><li><p><strong>Cmd</strong></p><p>Command code. This message byte specifies the operation that is to be executed under the specified Network Function.</p><blockquote><p>Command code. 该消息字节指定要在指定Network Function 下执行的操作。</p></blockquote><li><p><strong>Data</strong></p><p>Zero or more bytes of data, as required by the given command. The general convention is to pass data LS-byte first, but check the individual command specifications to be sure.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>convention [kənˈvenʃn]: 协定,协议;约束,约定;惯例
</pre></table></code></div></div><p>根据给定命令的需要，零个或多个字节的数据。 一般约定是首先传递数据 LS-byte ，但 请检查各个命令规范来确定。</p></blockquote></ul><h2 id="93-bmc-kcs-interface-response-message-format"><span class="me-2">9.3 BMC-KCS Interface Response Message Format</span><a href="#93-bmc-kcs-interface-response-message-format" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Response Messages are read transfers from the BMC to system software via the KCS Interface. Note that the BMC only returns responses via the KCS Interface when Data needs to be returned. The message bytes are organized according to the following format specification:</p><blockquote><p>Response Messages 是通过 KCS 接口从 BMC 到系统软件的读取传输。 请注意，BMC 仅在需 要返回数据时才通过 KCS 接口返回响应。 消息字节按照以下格式规范组织：</p></blockquote><p><img src="pic/Figure-9-2.png" alt="Figure-9-2" /></p><p>Where:</p><ul><li><p><strong>LUN</strong></p><p>Logical Unit Number. This is a return of the LUN that was passed in the Request Message.</p><li><p><strong>NetFn</strong></p><p>Network Function. This is a return of the NetFn code that was passed in the Request Message. Except that an odd NetFn value is returned.</p><blockquote class="prompt-tip"><p>注意其返回的NetFn 是偶数. 而 Request Message 中是奇数.</p></blockquote><li><p><strong>Cmd</strong></p><p>Command. This is a return of the Cmd code that was passed in the Request Message.</p><li><p><strong>Completion Code</strong></p><p>The Completion Code indicates whether the request completed successfully or not.</p><blockquote><p>Completion Code 指示请求是否成功完成。</p></blockquote><li><p><strong>Data</strong></p><p>Zero or more bytes of data. The BMC always returns a response to acknowledge the request, regardless of whether data is returned or not.</p><blockquote><p>零个或多个字节的数据。 无论是否返回数据，BMC 都会返回响应来确认请求。</p></blockquote></ul><h2 id="94-logging-events-from-system-software-via-kcs-interface"><span class="me-2">9.4 Logging Events from System Software via KCS Interface</span><a href="#94-logging-events-from-system-software-via-kcs-interface" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The KCS Interface can be used for sending Event Messages from system software to the BMC Event Receiver. The following figures show the format for KCS Interface Event Request and corresponding Event Response messages. Note that only Event Request Messages to the BMC via the KCS Interface have a Software ID field. This is so the Software ID can be saved in the logged event.</p><blockquote><p>KCS 接口可用于将Event Message 从系统软件发送到 BMC Event Receiver。 下图显示了 KCS接口Event Request 和相应 Event Response 消息的格式。 请注意，只有通过 KCS 接口发送至 BMC 的事件请求消息才具有软件 ID 字段。 这样软件 ID 就可以保存在记 录的事件中。</p></blockquote><p><img src="pic/Figure-9-3.png" alt="Figure-9-3" /></p><blockquote><p>designates /ˈdezɪɡneɪts/ 指定；命名；选定，指派，委任</p></blockquote><h2 id="95-kcs-interface-registers"><span class="me-2">9.5 KCS Interface Registers</span><a href="#95-kcs-interface-registers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The KCS Interface defines a set of I/O mapped communication registers. The bit definitions, and operation of these registers follows that used in the Intel 8742 Universal Peripheral Interface microcontroller. The term ‘Keyboard Controller Style’ reflects the fact that the 8742 interface is used as the system keyboard controller interface in PC architecture computer systems.</p><blockquote><p>KCS 接口定义了一组 I/O 映射通信寄存器。 这些寄存器的位定义和操作遵循 Intel 8742 Universal Peripheral 微控制器中使用的定义和操作。 术语“Keyboard Controller Style” 反映了 8742 接口在 PC 架构计算机系统中用作系统键盘控制器接口.</p></blockquote><p>The specification of the KCS Interface registers is given solely with respect to the ‘system software side’ view of the interface in system I/O space. The functional behavior of the management controller to support the KCS Interface registers is specified, but the physical implementation of the interface and the organization of the interface from the management controller side is implementation dependent and is beyond the scope of this specification.</p><blockquote><p>KCS 接口寄存器的规范仅针对系统 I/O 空间中接口的“系统软件端”视图给出。 管理控 制器支持 KCS 接口寄存器的功能行为已被指定，但管理控制器侧接口的物理实现和接口 的组织取决于实现，并且超出了本规范的范围。</p></blockquote><p>On the system side, the registers are mapped to system I/O space and consists of four byte-wide registers.</p><blockquote><p>在系统方面，寄存器映射到系统I/O空间并由四个byte-wide的寄存器组成。</p></blockquote><ul><li><strong>Status Register</strong> - provides flags and status bits for use in various defined operations.<blockquote><p>提供了在各种定义的操作中使用的标志和状态位。</p></blockquote><li><strong>Command Register</strong> - provides port into which ‘Write Control Codes’ may be written.<blockquote><p>提供可以写入“Write Control Codes”的端口。</p></blockquote><li><strong>Data_In</strong> - provides a port into which data bytes and ‘Read Control Codes’ may be written.<blockquote><p>提供一个可以写入数据字节和“Read Control Codes”的端口。</p></blockquote><li><strong>Data_Out</strong> - provides a port from which data bytes may be read.<blockquote><p>提供可以读取数据字节的端口。</p></blockquote></ul><p>The default system base address for an I/O mapped KCS SMS Interface is CA2h. Refer to Appendix C1 - Locating IPMI System Interfaces via SM BIOS Tables for information on using SM BIOS tables for describing optional interrupt usage, memory mapped registers, 32-bit and 16-byte aligned registers, and alternative KCS interface addresses. Software can assume the KCS interface registers are I/O mapped and byte aligned at the default address unless other information is provided.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Appendix [əˈpendɪks]: 附录
</pre></table></code></div></div><p>I/O 映射的 KCS SMS 接口的默认系统基地址是 CA2h。 请参阅附录 C1 - 通过 SM BIOS 表定位 IPMI 系统接口，了解有关使用 SM BIOS 表描述可选中断使用、内存映射寄存器、 32 位和 16 字节对齐寄存器以及备用 KCS 接口地址的信息。 软件可以假定 KCS 接口寄存器已进行 I/O 映射并在默认地址处进行字节对齐，除非提供其他信息</p></blockquote><p><img src="pic/Figure-9-4.png" alt="Figure-9-4" /></p><h2 id="96-kcs-interface-control-codes"><span class="me-2">9.6 KCS Interface Control Codes</span><a href="#96-kcs-interface-control-codes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Control codes are used for ‘framing’ message data transferred across the KCS Interface. Control Codes are used to:</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>frame: n. 框架 v. 表达,指定,拟定
</pre></table></code></div></div><p>Control Code 用于“构建”通过 KCS 接口传输的消息数据。 控制代码用于：</p></blockquote><ul><li>Identify the first and last bytes of a packet.<li>Identify when an error/abort has occurred.<li>Request additional data bytes.</ul><h2 id="97-status-register"><span class="me-2">9.7 Status Register</span><a href="#97-status-register" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>System software always initiates a transfer. If the BMC has a message for SMS, it can request attention by setting the SMS_ATN bit in the status register. System software then detects the flag and initiates the transfer.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>initiates [ɪˈnɪʃieɪts]
</pre></table></code></div></div><p>系统软件总是发起传输。 如果 BMC 有 SMS 消息，则可以通过设置状态寄存器中的 SMS_ATN 位来请求关注。 然后系统软件检测该标志并启动传输。</p></blockquote><p>Other bits in the status register are used to arbitrate access to the command and data registers between the BMC and system software and to indicate the “state” (write, read, error, or idle) of the current transaction. The following tables summarize the functions of the Status Register bits.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>arbitrate [ˈɑːrbɪtreɪt]: v. 仲裁,中断
</pre></table></code></div></div><p>状态寄存器中的其他位用于仲裁 BMC 和系统软件之间对命令和数据寄存器的访问，并指 示当前事务的“状态”（写入、读取、错误或空闲）。 下表总结了状态寄存器位的功能。</p></blockquote><p><img src="pic/Figure-9-5.png" alt="Figure-9-5" /></p><blockquote><ul><li><p><strong>C/D#</strong>:</p><p>Specifies whether the last write was to the Command register or the Data_In register (1=command, 0=data). Set by hardware to indicate whether last write from the system software side was to Command or Data_In register.</p><blockquote><p>指定最后一次写入是写入命令寄存器还是 Data_In 寄存器（1=命令，0=数据）。 由硬件 设置以指示系统软件端的最后一次写入是对 Command 还是 Data_In 寄存器。</p></blockquote><li><p><strong>IBF</strong></p><p>Automatically set to 1 when either the associated Command or Data_In register has been written by system-side software.</p><blockquote><p>当系统端软件写入关联的 Command 或 Data_In 寄存器时，自动设置为 1。</p></blockquote><li><p><strong>OBF</strong></p><p>Set to 1 when the associated Data_Out register has been written by the BMC.</p><blockquote><p>当系统端软件写入关联的 Command 或 Data_In 寄存器时，自动设置为 1。</p></blockquote></ul></blockquote><p>Bits 7:6 are state bits that provide information that is used to ensure that the BMC and system software remain in sync with one another. Following are the possible states and their meaning:</p><blockquote><p>位 7:6 是状态位，提供用于确保 BMC 和系统软件保持彼此同步的信息。 以下是可能 的状态及其含义：</p></blockquote><p><img src="pic/Figure-9-6.png" alt="Figure-9-6" /></p><blockquote><ul><li><p><strong>IDLE_STATE.</strong></p><p>Interface is idle. System software should not be expecting nor sending any data.</p><blockquote><p>接口空闲。 系统软件不应期待也不发送任何数据。</p></blockquote><li><p><strong>READ_STATE.</strong></p><p>BMC is transferring a packet to system software. System software should be in the “Read Message” state.</p><blockquote><p>BMC 正在向系统软件传输数据包。 系统软件应处于“Read Message”状态。</p></blockquote><li><p><strong>WRITE_STATE.</strong></p><p>BMC is receiving a packet from system software. System software should be writing a command to the BMC.</p><blockquote><p>BMC正在接收来自系统软件的数据包。 系统软件应该向 BMC 写入命令。</p></blockquote><li><p><strong>ERROR_STATE.</strong></p><p>BMC has detected a protocol violation at the interface level, or the transfer has been aborted. System software can either use the “Get_Status’ control code to request the nature of the error, or it can just retry the command.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>nature : n. 自然; 性质
</pre></table></code></div></div><p>BMC 检测到接口级别的协议违规，或者传输已中止。 系统软件可以使用“Get_Status” control code 来请求错误的性质，也可以仅重试该命令。</p></blockquote></ul></blockquote><h3 id="971-sms_atn-flag-usage"><span class="me-2">9.7.1 SMS_ATN Flag Usage</span><a href="#971-sms_atn-flag-usage" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The SMS_ATN flag is used to indicate that the BMC requires attention from system software. This could either be because a message was received into the Receive Message Queue and ready for delivery to system software, the Event Message Buffer is full (if the Event Message Buffer is configured to generate an interrupt to system management software), a watchdog pre-timeout occurred, or because of an OEM event. Flags in the BMC identify which conditions are causing the SMS_ATN flag to be set. All conditions must be cleared (i.e. all messages must be flushed) in order for the SMS_ATN bit to be cleared.</p><blockquote><p>SMS_ATN 标志用于指示 BMC 需要系统软件的关注。 这可能是因为消息已接收到接 收消息队列并准备好传送到系统软件、事件消息缓冲区已满（如果事件消息缓冲区 配置为向系统管理软件生成中断）、看门狗预置 发生超时，或由于 OEM 事件。 BMC 中的标志标识哪些条件导致 SMS_ATN 标志被设置。 必须清除所有条件（即必须刷新 所有消息）才能清除 SMS_ATN 位。</p></blockquote><p>The SMS_ATN bit is also used when the KCS interface is interrupt driven, or when OEM events or watchdog pre-timeouts generate a system interrupt. Refer to sections 9.12, KCS Communication and Non-communication Interrupts, 9.13, Physical Interrupt Line Sharing, and 9.14, Additional Specifications for the KCS interface for additional information on the use and requirements for the SMS_ATN bit.</p><blockquote><p>当 KCS 接口是中断驱动时，或者当 OEM 事件或看门狗预超时生成系统中断时， 也会使用 SMS_ATN 位。 有关 SMS_ATN 位的使用和要求的附加信息，请参阅第 9.12 节“KCS 通信和非通信中断”、第 9.13 节“物理中断线路共享”和 9.14 节“KCS 接口 的附加规范”。</p></blockquote><h2 id="98-command-register"><span class="me-2">9.8 Command Register</span><a href="#98-command-register" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The Command register must only be written from the system side when the IBF flag is clear. Only WRITE_START, WRITE_END, or GET_STATUS/ABORT Control Codes are written to the command register.</p><blockquote><p>仅当 IBF 标志清零时，才必须从系统侧写入命令寄存器。 仅 WRITE_START、WRITE_END 或 GET_STATUS/ABORT Control Codes 会写入Control Register。</p></blockquote><h2 id="99-data-registers"><span class="me-2">9.9 Data Registers</span><a href="#99-data-registers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Packets to and from the BMC are passed through the data registers. These bytes contain all the fields of a message, such as the Network Function code, Command Byte, and any additional data required for the Request or Response message.</p><blockquote><p>进出 BMC 的数据包通过Data Register 传递。 这些字节包含消息的所有字段，例如 NetFn、Command Byte 以及Request 或 Response 消息所需的任何附加数据。</p></blockquote><p>The Data_In register must only be written from the system side when the IBF flag is clear. The OBF flag must be set (1) before the Data_Out register can be read (see status register).</p><blockquote><p>仅当 IBF 标志清零时，才必须从系统侧写入 Data_In 寄存器。 在读取 Data_Out 寄存器之前， 必须将 OBF 标志设置为 (1)（请参阅状态寄存器）。</p></blockquote><h2 id="910-kcs-control-codes"><span class="me-2">9.10 KCS Control Codes</span><a href="#910-kcs-control-codes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The following table details the usage of ‘Control Codes’ by the KCS interface.</p><p><img src="pic/Figure-9-7.png" alt="Figure-9-7" /></p><h2 id="911-performing-kcs-interface-message-transfers"><span class="me-2">9.11 Performing KCS Interface Message Transfers</span><a href="#911-performing-kcs-interface-message-transfers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>System Management Software that uses the KCS Interface will typically be running under a multi-tasking operating system. This means transfers with the BMC may be interrupted by higher priority tasks or delayed by other System Management Software processing. The SMS channel handshake is optimized to allow the BMC to continue to perform tasks between data byte transfers with System Management Software. The BMC does not time out data byte transfers on the SMS interface.</p><blockquote><p>使用 KCS 接口的系统管理软件通常在多任务操作系统下运行。 这意味着与 BMC 的传输可能会被更高优先级的任务中断或被其他系统管理软件处理延迟。 SMS 通道握手经过优化，允许 BMC 通过系统管理软件在数据字节传输之间继续执行任务。 BMC 不会使 SMS 接口上的数据字节传输超时。</p></blockquote><p>Request and Response Messages are paired together as a Write Transfer to the BMC to send the request followed by a Read Transfer from the BMC to get the response.</p><blockquote><p>Request 和 Response 消息配对在一起，作为向 BMC 的Write Transfer 以发送请求， 然后从 BMC 进行Read Transfer 以获取响应。</p></blockquote><p>The process, as seen from the system perspective is depicted in Figure 9-6, KCS Interface SMS to BMC Write Transfer Flow Chart, and Figure 9-7, KCS Interface BMC to SMS Read Transfer Flow Chart, below.</p><blockquote><p>从系统角度来看，该过程如图 9-6（KCS 接口 SMS 到 BMC 写入传输流程图）和图 9-7 （KCS 接口 BMC 到 SMS 读取传输流程图）所示。</p></blockquote><p>During the write transfer each write of a Control Code to the command register and each write of a data byte to Data_In will cause IBF to become set, triggering the BMC to read in the corresponding Control Code or data byte.</p><blockquote><p>在写传输期间，每次向命令寄存器写入Control Code 以及每次向 Data_In 写入数据字节都 会导致 IBF 置位，从而触发 BMC 读入相应的 Control Code 或数据字节。</p></blockquote><p>If the KCS interface uses an interrupt, the BMC will write a dummy value of 00h to the output data register after it has updated the status register and read the input buffer. This generates an ‘OBF’ interrupt. The points at which this would occur are shown as “OBF” in Figure 9-6, KCS Interface SMS to BMC Write Transfer Flow Chart, below.</p><blockquote><p>如果KCS接口使用中断，则BMC在更新状态寄存器并读取输入缓冲区后将向输出数据寄存器 写入虚拟值00h。 这会生成“OBF”中断。 发生这种情况的点在下面的图 9-6 KCS 接口 SMS 到 BMC 写入传输流程图中显示为“OBF”。</p></blockquote><p>During the read phase, each write of a READ Control Code to Data_In will cause IBF to become set, causing the BMC to read in the Control Code and write a data byte to Data_Out in response. If the KCS interface uses an interrupt, the write of the data byte to Data_Out will also generate an interrupt. The point at which this would occur during the READ_STATE is shown as “OBF” in Figure 9-7, KCS Interface BMC to SMS Read Transfer Flow Chart, below.</p><blockquote><p>在读取阶段，每次向 Data_In 写入 READ 控制代码都会导致 IBF 置位，从而导致 BMC 读取控制代码并将数据字节写入 Data_Out 作为响应。 如果KCS接口使用中断，则将数 据字节写入Data_Out也会产生中断。 在 READ_STATE 期间发生这种情况的点在下面的图 9-7 KCS 接口 BMC 到 SMS 读取传输流程图中显示为“OBF”。</p></blockquote><p>Note that software does not need to use the Get Status/Abort transaction to return the interface to the IDLE_STATE or handle an error condition. The interface should return to IDLE_STATE on successful completion of any full command/response transaction with the BMC. Thus, since the interface will allow a command transfer to be started or restarted at any time when the input buffer is empty, software could elect to simply retry the command upon detecting an error condition, or issue a ‘known good’ command in order to clear ERROR_STATE.</p><blockquote><p>请注意，软件不需要使用Get Status/Abort translation 来将接口返回到 IDLE_STATE 或处理错误情况。成功完成与 BMC 的任何完整命令/响应事务后，接口应返回 IDLE_STATE。 因此，由于接口将允许在输入缓冲区为空时随时启动或重新启动命令传输，因此软件可以 选择在检测到错误情况时简单地重试该命令，或者发出“known good”命令，以便 清除 ERROR_STATE。</p></blockquote><h2 id="912-kcs-communication-and-non-communication-interrupts"><span class="me-2">9.12 KCS Communication and Non-communication Interrupts</span><a href="#912-kcs-communication-and-non-communication-interrupts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The following lists some general requirements and clarifications to support both KCS communication and KCS non-communication interrupts on the same interrupt line using the OBF signal. A KCS communications interrupt is defined as an OBF-generated interrupt that occurs during the process of sending a request message to the BMC and receiving the corresponding response. This occurs from the start of the write (request) phase of the message (issuing WRITE_START to the command register) through to the normal conclusion of the corresponding read (response) phase of the message. (The conclusion of the communications interval is normally identified by the interface going to IDLE_STATE). KCS communications interrupts are also encountered during the course of processing a GET_STATUS/ABORT control code.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>clarifications [ˌklɛrɪfɪˈkeɪʃənz]: 澄清（法）；净（纯）化；清化（理）；说（阐）明；解释
conclusion [kənˈkluːʒn] 结论; 结果; 结束; 缔结; 达成; 签订; 结局; 推论; 结尾
interval: /ˈɪntərvl/: 间隔；(时间上的)间隙；间歇;
</pre></table></code></div></div><p>下面列出了使用 OBF 信号在同一中断线上支持 KCS 通信和 KCS 非通信中断的一些一 般要求和说明。 KCS通信中断被定义为OBF-generated 的中断，该中断发生在向BMC发送请求消 息并接收相应响应的过程中。 这发生在从消息的写入（请求）阶段（向命令寄存器发出 WRITE_START）开始到消息的相应读取（响应）阶段正常结束之间。 （通信间隔的结束 通常由接口进入 IDLE_STATE 来标识）。 在处理 GET_STATUS/ABORT 控制代码的过程中 也会遇到 KCS 通信中断。</p></blockquote><p>A KCS non-communication interrupt is defined as an OBF-generated interrupt that occurs when the BMC is not in the process of transferring message data or getting error status. This will typically be an interrupt that occurs while the interface is in the IDLE_STATE.</p><blockquote><p>KCS非通信中断被定义为OBF-generated 的中断，当BMC不在传输消息数据或获取错误状态的 过程中时发生。 这通常是接口处于 IDLE_STATE 时发生的中断。</p></blockquote><p>There are several options in the BMC that can be enabled to cause KCS non-communication interrupts as described in the Set BMC Global Enables command, and Get Message Flags commands. These are the watchdog timer pre-timeout interrupt, event message buffer interrupt, receive message queue interrupt, and the OEM interrupts. Software can detect which of the standard interrupts are supported by attempting to enable them using the Set BMC Global Enables command and checking for an error completion code.</p><blockquote><p>BMC 中有多个选项可以启用以导致 KCS 非通信中断，如 Set BMC Global Enables Command,和 Get Message Flags commands中所述。 它们是看门狗定时器预超时中断、事件消息缓冲区中断、 接收消息队列中断和 OEM 中断。 软件可以通过尝试使用 Set BMC Global Enables 命令启用 标准中断并检查错误完成代码来检测支持哪些标准中断。</p></blockquote><h2 id="913-physical-interrupt-line-sharing"><span class="me-2">9.13 Physical Interrupt Line Sharing</span><a href="#913-physical-interrupt-line-sharing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A typical interrupt-driven implementation will assert a physical interrupt line when OBF is asserted. In order to allow a single interrupt line to serve for both communication and non-communication interrupts, the physical interrupt line must be automatically deasserted by the BMC whenever a communication phase begins, even if there is a pending non-communications interrupt to be serviced. This is necessary so the interrupt line can be used for signaling communication interrupts . Once the communication operations have completed (return to idle phase) the controller must re-assert the interrupt line if the non-communications interrupt is still pending.</p><blockquote><p>典型的中断驱动实现将在 OBF 置位时置位物理中断线。 为了允许单个中断线同时服务于 通信和非通信中断，无论何时通信阶段开始，物理中断线都必须由 BMC 自动取消置位，即 使有待处理的非通信中断需要服务。 这是必要的，因此中断线可用于发出通信中断信号。 一旦通信操作完成（返回空闲阶段），如果非通信中断仍待处理，控制器必须重新断言中断 线。</p></blockquote><h2 id="914-additional-specifications-for-the-kcs-interface"><span class="me-2">9.14 Additional Specifications for the KCS interface</span><a href="#914-additional-specifications-for-the-kcs-interface" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>This section lists additional specifications for the KCS interface.</p><ul><li>The BMC must generate an OBF whenever it changes the status to ERROR_STATE. This will ensure that any transition to ERROR_STATE will cause the interrupt handler to run and catch the state.<blockquote><p>每当 BMC 将状态更改为 ERROR_STATE 时，都必须生成 OBF。 这将确保任何到 ERROR_STATE 的转换都会导致中断处理程序运行并捕获状态。</p></blockquote><li>The BMC generates an OBF upon changing the status to IDLE_STATE. An IPMI 1.5 implementation is allowed to share this interrupt with a pending KCS non-communication interrupt, or it elect to always generate a separate OBF interrupt for non-communications interrupts.<blockquote><p>BMC 在状态更改为 IDLE_STATE 时生成 OBF。 IPMI 1.5 实现允许与待处理的 KCS 非通信中断共享此中断，或者选择始终为非通信中断生成单独的 OBF 中断。</p></blockquote><li><p>A BMC implementation that elects to always generate a separate non-communications interrupt must wait for the OBF interrupt that signals entering the IDLE_STATE to be cleared before it asserts an OBF interrupt for the non-communications interrupt.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>elects /ɪˈlekts/: 选举; 选择; 决定
</pre></table></code></div></div><p>选择始终生成单独的非通信中断的 BMC 实现必须等待信号进入 IDLE_STATE 的 OBF 中断被清除，然后才能为非通信中断断言 OBF 中断。</p></blockquote><li>IPMI v1.5 systems are allowed to generate a single OBF that covers both the last communications interrupt (when the BMC status goes to IDLE_STATE) and a pending non-communications interrupt. I.e. it is not required to generate a separate OBF interrupt for the non-communications interrupt if a non-communications interrupt was pending at the time the BMC status goes to IDLE_STATE. In order to support this, an IPMI v1.5 KCS interface implementation must set SMS_ATN for all standard (IPMI defined) non-communication interrupt sources.<blockquote><p>IPMI v1.5 系统允许生成单个 OBF，该 OBF 涵盖最后的通信中断（当 BMC 状态进入 IDLE_STATE 时）和待处理的非通信中断。 IE。 如果 BMC 状态进入 IDLE_STATE 时 非通信中断处于待处理状态，则不需要为非通信中断生成单独的 OBF 中断。 为了支 持这一点，IPMI v1.5 KCS 接口实现必须为所有标准（IPMI 定义）非通信中断源设置 SMS_ATN。</p></blockquote><li>For IPMI v1.5, the BMC must set the SMS_ATN flag if any of the standard message flags become set. This includes Receive Message Available, Event Message Buffer Full (if the Event Message Buffer Full condition is intended to be handled by System Management Software), and Watchdog Timer pre-timeout flags, as listed in the Get Message Flags command. This is independent of whether the corresponding interrupt is enabled or not.<blockquote><p>对于 IPMI v1.5，如果设置了任何标准消息标志，BMC 必须设置 SMS_ATN 标志。 这包括接收消息可用、事件消息缓冲区已满（如果事件消息缓冲区已满条件旨在由系统 管理软件处理）和看门狗定时器预超时标志，如获取消息标志命令中列出的。 这与相应 的中断是否启用无关。</p></blockquote><li>The BMC must change the status to ERROR_STATE on any condition where it aborts a command transfer in progress. For example, if the BMC had an OEM command that allowed the KCS interface to be asynchronously reset via IPMB, the KCS interface status should be put into the ERROR_STATE and OBF set, not IDLE_STATE, in order for software to be notified of the change. However, the BMC does not change the status to the ERROR_STATE, but to the IDLE_STATE, when the BMC executes the Get Status/Abort control code from SMS I/F, even if the Get Status/Abort control code is used to abort a transfer.<blockquote><p>在任何中止正在进行的命令传输的情况下，BMC 都必须将状态更改为 ERROR_STATE。 例如，如果 BMC 有一个 OEM 命令允许通过 IPMB 异步重置 KCS 接口，则应将 KCS 接口状态设置为 ERROR_STATE 和 set OBF， 而不是 IDLE_STATE ，以便向软件 通知更改。 然而，当 BMC 从 SMS I/F 执行 Get Status/Abort 控制代码时，BMC 不会将状态更改为 ERROR_STATE，而是更改为 IDLE_STATE，即使 Get Status/Abort 控制代码用于中止传输 。</p></blockquote><li><p>A cross-platform driver must be able to function without handling any of the OEM bits. Therefore, enabling SMS_ATN on OEM interrupts/states must not be enabled by default, but must be explicitly enabled either by the Set BMC Global Enables command or by an OEM-defined command.</p><blockquote><p>跨平台驱动程序必须能够在不处理任何 OEM 位的情况下运行。 因此，默认情况下不 得启用 OEM 中断/状态上的 SMS_ATN，而必须通过 Set BMC Global Enables 命令或 OEM 定义的命令显式启用。</p></blockquote><li>The SMS_ATN bit will remain set until all standard interrupt sources in the BMC have been cleared by the Clear Message Flags command, or by a corresponding command. For example, the Read Message command can automatically clear the Receive Message Queue interrupt if the command empties the queue.<blockquote><p>SMS_ATN 位将保持设置状态，直到 BMC 中的所有标准中断源已被Clear Message Flag command 或相应的命令清除。 例如，如果读取消息命令清空队列，则该命令可以自动 清除接收消息队列中断。</p></blockquote><li>A KCS interface implementation that allows its interrupt to be shared with other hardware must set SMS_ATN whenever it generates a KCS interrupt. A system will typically report whether it allows an interrupt to be shared or not via resource usage configuration reporting structures such as those in ACPI.<blockquote><p>允许与其他硬件共享其中断的 KCS 接口实现必须在生成 KCS 中断时设置 SMS_ATN。 系统通常会通过资源使用配置报告结构（例如 ACPI 中的报告结构）来报告是否允许共 享中断。</p></blockquote><li><p>OEM non-communications interrupts should be disabled by default. They must be returned to the disabled state whenever the controller or the system is powered up or reset. This is necessary to allow a generic driver to be used with the controller. A driver or system software must be explicitly required to enable vendor-specific non- communications interrupt sources in order for them to be used. OEM non-communications interrupt sources must not contribute to SMS_ATN when they are disabled.</p><li><p>The OEM 0, 1, and 2 flags that are returned by the Get Message Flags command may also cause the SMS_ATN flag to be set. A platform or system software must not enable these interrupts/flags unless there is a corresponding driver that can handle them. Otherwise, a generic cross-platform driver could get into a situation where it would never be able to clear SMS_ATN.</p><li><p>It is recommended that any OEM generated non-communications interrupts cause at least one of the OEM flags in the Get Message Flags to become set. This will enable improving system efficiency by allowing a cross- platform driver to pass the value of the Get Message Flags to an OEM extension, saving the OEM extension software from having to issue an additional command to determine whether it has an anything to process.</p><li><p>It is recommended that an OEM that uses the OEM flags sets the SMS_ATN flag if one or more of the OEM flags (OEM 0, OEM 1, or OEM 2) becomes set, especially if those flags can be the source of a KCS non- communications interrupt. The driver can use SMS_ATN as the clue to execute the Get Message Flags command and pass the data along to an OEM extension routine.</p><li><p>OEM non-communications interrupts may elect to either share the IDLE_STATE OBF interrupt with the non- communications interrupt OBF, or generate a separate non-communications OBF interrupt. If the OEM non- communications interrupt implementation shares the IDLE_STATE OBF interrupt, the OEM non- communications interrupt must also set SMS_ATN.</p><blockquote><p>OEM 非通信中断可以选择与非通信中断 OBF 共享 IDLE_STATE OBF 中断， 或者生成单独的非通信 OBF 中断。 如果 OEM 非通信中断实现共享 IDLE_STATE OBF 中断，则 OEM 非通信中断还必须设置 SMS_ATN。</p></blockquote></ul><h2 id="915-kcs-flow-diagrams"><span class="me-2">9.15 KCS Flow Diagrams</span><a href="#915-kcs-flow-diagrams" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The following flow diagrams have been updated from corresponding diagrams in the original IPMI v1.0, rev. 1.1 specification. This information applies to the following flow diagrams:</p><blockquote><p>以下流程图已根据原始 IPMI v1.0 修订版中的相应图表进行了更新。 1.1 规范。 此信息适用于以下流程图：</p></blockquote><ul><li>All system software wait loops should include error timeouts. For simplicity, such timeouts are not shown explicitly in the flow diagrams. A five-second timeout or greater is recommended.<blockquote><p>所有系统软件等待循环都应包括错误超时。 为简单起见，流程图中未明确显示此类超时。 建议设置五秒或更长的超时时间。</p></blockquote><li>The phase values represent state information that could be kept across different activations of an interrupt handler, and corresponding entry points. Based on the ‘phase’ the interrupt handler would branch to the corresponding point when an OBF interrupt occurred. The information may also be useful for error reporting and handling for both polled- and interrupt-driven drivers. Note that other state may need to be kept as well. For example, during the ‘wr_data’ phase, the handler may also need to preserve a byte counter in order to track when the last byte of the write was to be sent.<blockquote><p>phase 值表示可以在中断处理程序的不同activations 和相应的入口点之间保存的状态信息。 当 OBF 中断发生时，中断处理程序将根据“phase”分支到相应的点。 该信息对于 轮询驱动驱动程序和中断驱动驱动程序的错误报告和处理也可能有用。 请注意， 可能还需要保留其他状态。 例如，在“wr_data” phase ，处理程序可能还需要保留字 节计数器，以便跟踪写入的最后一个字节何时发送。</p></blockquote><li>The symbol of a circle with an arrow and the text ‘OBF’ inside the circle represents the points where the BMC would write a dummy data byte to the output buffer in order to create an OBF interrupt. The label above the circle indicates where an interrupt handler would branch to when the OBF interrupt occurs under in the corresponding phase. An interrupt handler would exit upon completing the step that occurs before where the OBF interrupt symbol points.<blockquote><p>带箭头的圆圈符号和圆圈内的文本“OBF”代表 BMC 将dummy data byte 写入输出缓冲区 以创建OBF 中断的点。圆圈上方的标签表示在相应阶段发生 OBF 中断时中断处理程序 将分支到的位置。中断处理程序将在完成 OBF 中断符号指向之前发生的步骤后退出。</p></blockquote></ul><p><img src="pic/Figure-9-8.png" alt="Figure-9-8" /></p><ul><li>wr_start OBF<blockquote><p>BMC sets status to WRITE_STATE immediately after receiving any control code in the command register unless it needs to force an ERROR_STATE. The status is set before reading the control code from the input buffer.</p><p>In the unlikely event that an asynchronous interrupt occurs after clearing OBF the interrupt handler may spin waiting for IBF=0.</p><blockquote><p>BMC 在接收到命令寄存器中的任何控制代码后立即将状态设置为 WRITE_STATE，除非需要强制 ERROR_STATE。 在从输入缓冲区读取Control Code 之前设置状态。</p><p>万一在清除 OBF 后发生异步中断，中断处理程序可能会旋转等待 IBF=0。</p></blockquote></blockquote><li><p>wr_data OBF</p><blockquote><p>BMC updates state after receiving data byte in DATA_IN, but before reading the byte out of the input buffer. I.e. it changes state while IBF=1</p><blockquote><p>BMC 在接收 DATA_IN 中的数据字节之后、从输入缓冲区读取该字节之前更新状态。 IE。 当 IBF=1 时它改变状态</p></blockquote></blockquote><li><p>before READ</p><blockquote><p>The BMC sets state to READ_STATE before reading data byte from data register. This ensures state change to READ_STATE occurs while IBF=1</p><blockquote><p>在从data register 读取数据字节之前，BMC 将状态设置为 READ_STATE。 这确保在 IBF=1 时发生状态更改为 READ_STATE</p></blockquote></blockquote></ul><p><img src="pic/Figure-9-9.png" alt="Figure-9-9" /></p><ul><li>read OBF<blockquote><p>This OBF is normally caused by the BMC returning a data byte for the read operation. After the last data byte, the BMC sets the state to IDLE_STATE while IBF=1 and then reads the input buffer to check the control code = READ. The status will be set to ERROR_STATE if the control code is not READ. The BMC then writes a dummy data byte to the output buffer to generate an interrupt so the driver can see the status change.</p><blockquote><p>此 OBF 通常是由 BMC 返回读操作的数据字节引起的。 在最后一个数据字节之后，当 IBF=1 时，BMC 将状态设置为 IDLE_STATE，然后读取输入缓冲区以检查控制代码 = READ。 如果控制代码未读取，状态将设置为 ERROR_STATE。 然后，BMC 将虚拟数据字节写入输出缓 冲区以生成中断，以便驱动程序可以看到状态更改。</p></blockquote><p>Note that software must track that it has received an interrupt from ‘IDLE_STATE’ while it is still in the ‘read’ phase in order to differentiate it from a non-communication interrupt. If the BMC needs to set the status to ERROR_STATE it will do so before writing a dummy 00h byte to the output buffer . (The BMC always places a dummy byte in the output buffer whenever it sets the status to ERROR_STATE.)</p><blockquote><p>请注意，软件必须跟踪它在仍处于“read” phase 时已从“IDLE_STATE”接收到中断， 以便将其与非通信中断区分开来。 如果 BMC 需要将状态设置为 ERROR_STATE，它将在将 dummy 00h byte 写入输出缓冲区之前执行此操作。 （每当 BMC 将状态设置为 ERROR_STATE 时，BMC 总是在输出缓冲区中放置一个 dummy byte。）</p></blockquote></blockquote><li><p>Read dummy data byte from DATA_OUT</p><blockquote><p>The BMC must wait for software to read the output buffer before writing OBF to generate a non-communications interrupt. That is, if there are any pending interrupts while in IDLE_STATE, but OBF is already set, it must hold off the interrupt until it sees OBF go clear. Softw are must be careful, since missing any read of the output buffer will effectively disable interrupt generation. It may be a prudent safeguard for a driver to poll for OBF occassionallyw hen waiting for an interrupt from the IDLE state.</p><blockquote><p>BMC 必须等待软件读取输出缓冲区后才能写入 OBF 以产生非通信中断。 也就是说， 如果处于 IDLE_STATE 时有任何挂起的中断，但 OBF 已设置，则必须推迟中断，直到看到 OBF 清除为止。 软件必须小心，因为错过任何输出缓冲区的读取将有效地禁用中断生成。 对于驱动程序来说，在等待来自 IDLE 状态的中断时偶尔轮询 OBF 可能是一种谨慎的保护措施。</p></blockquote><p>Note that for IPMI v1.5, the last OBF interrupt is allowed to be shared with a pending non-communications interrupt. See text.</p><blockquote><p>请注意，对于 IPMI v1.5，允许最后一个 OBF 中断与待处理的非通信中断共享。 见正文。</p></blockquote></blockquote></ul><p><img src="pic/Figure-9-10.png" alt="Figure-9-10" /></p><h2 id="916-write-processing-summary"><span class="me-2">9.16 Write Processing Summary</span><a href="#916-write-processing-summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The following summarizes the main steps write transfer from system software to the BMC:</p><ul><li>Issue a ‘WRITE_START’ control code to the Command register to start the transaction.<li>Write data bytes (NetFn, Command, Data) to Data_In.<li>Issue an ‘WRITE_END’ control code then the last data byte to conclude the write transaction.</ul><h2 id="917-read-processing-summary"><span class="me-2">9.17 Read Processing Summary</span><a href="#917-read-processing-summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The following summarizes the main steps for a read transfer from the BMC to system software:</p><ul><li>Read Data_Out when OBF set<li>Issue READ command to request additional bytes<li>If READ_STATE (after IBF = 0), repeat previous two steps.</ul><h2 id="918-error-processing-summary"><span class="me-2">9.18 Error Processing Summary</span><a href="#918-error-processing-summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The following summarizes the main steps by which system software processes KCS Interface errors:</p><ul><li>Issue a ‘GET_STATUS/ABORT’ control code to the Command register. Wait for IBF=0. State should be WRITE_STATE.<li>If OBF=1, Clear OBF by reading Data_Out register.<li>Write 00h to data register, wait for IBF=0. State should now be READ_STATE.<li>Wait for OBF=1. Read status from Data_Out<li>Conclude by writing READ to data register, wait for IBF=0. State should be IDLE.</ul><h2 id="919-interrupting-messages-in-progress"><span class="me-2">9.19 Interrupting Messages in Progress</span><a href="#919-interrupting-messages-in-progress" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>If, during a message transfer, the system software wants to abort a message it can do so by the following methods:</p><blockquote><p>如果在消息传输过程中，系统软件想要中止消息，可以通过以下方法来完成：</p></blockquote><ol><li>Place another “WRITE_START” command into the Command Register (a WRITE_START Control Code is always legal). The BMC then sets the state flags to “WRITE_STATE” and sets its internal flags to indicate that the stream has been aborted.<blockquote><p>将另一个“WRITE_START”命令放入命令寄存器（WRITE_START 控制代码始终合法）。 然后，BMC 将状态标志设置为“WRITE_STATE”，并设置其内部标志以指示流已被中止。</p></blockquote><li>Send a “GET_STATUS/ABORT” request. This is actually the same as #1 above but is explicitly stated to indicate that this command will cause the current packet to be aborted. This command allows a stream to be terminated and the state to be returned to IDLE without requiring a complete BMC request and response transfer.<blockquote><p>发送“GET_STATUS/ABORT”请求。 这实际上与上面的 #1 相同，但明确指出该命令将 导致当前数据包中止。 该命令允许终止流并将状态返回到 IDLE，而不需要完整的 BMC 请求和响应传输。</p></blockquote></ol><h2 id="920-kcs-driver-design-recommendations"><span class="me-2">9.20 KCS Driver Design Recommendations</span><a href="#920-kcs-driver-design-recommendations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>A generic, cross-platform driver that supports the interrupt-driven KCS interface is not required to handle interrupts other than the interrupt signal used for IPMI message communication with the BMC. The message interrupt may be shared with other BMC interrupt sources, such as the watchdog timer pre-timeout interrupt, the event message buffer full interrupt, and OEM interrupts.</p><li><p>A cross-platform driver should use the Get BMC Global Enables and Set BMC Global Enables commands in a ‘read-modify-write’ manner to avoid modifying the settings of any OEM interrupts or flags.</p><li><p>It is recommended that cross-platform driver software provide a ‘hook’ that allows OEM extension software to do additional processing of KCS non-communication interrupts. It is highly recommended that the driver execute the Get Message Flags command whenever SMS_ATN remains set after normal processing and provide the results to the OEM extension software.</p><li><p>The driver cannot know the whether the pre-existing state of any OEM interrupts or flags is correct. Therefore, a driver that supports OEM extensions should allow for an OEM initialization routine that can configure the OEM flags/interrupts before KCS OBF-generated interrupts are enabled.</p><li><p>It is recommended that cross-platform drivers or software make provision for BMC implementations that may miss generating interrupts on a command error condition by having a timeout that will activate the driver or software in case an expected interrupt is not received.</p><li><p>A driver should be designed to allow for the possibility that an earlier BMC implementation does not set the SMS_ATN flag except when there is data in the Receive Message Queue. If the driver cannot determine whether SMS_ATN is supported for all enabled standard flags or not, it should issue a Get Message Flags command whenever it gets a KCS non-communication interrupt.</p><li><p>A driver or system software can test for whether the Watchdog Timer pre-timeout and/or Event Message Buffer Full flags will cause SMS_ATN to become set. This is accomplished by disabling the associated interrupts (if enabled) and then causing a corresponding action that sets the flag. This is straightforward by using the watchdog timer commands in conjunction with the Set BMC Global Enables and Get Message Flags commands.</p><p>For example, to test for the Event Message Buffer Full flag setting SMS_ATN, first check to see if the Event Message Buffer feature is implemented by attempting to enable the event message buffer using the Set and Get BMC Global Enables command. If the feature is not implemented, an error completion code will be returned. Next, disable event logging and use the watchdog timer to generate an SMS/OS ‘no action’ timeout event, then see if the SMS_ATN becomes set. If so, use the Get Message Flags command to verify that the Event Message Buffer Full flag is the only one set (in case an asynchronous message came in to the Receive Message Queue during the test.) The pre-timeout interrupt can be testing in a similar manner.</p><li><p>It is possible (though not recommended) for a BMC implementation to include proprietary non- communication interrupt sources that do not set SMS_ATN. These sources must not be enabled by default. It is recommended that a generic cross-platform driver have provisions for OEM extensions that get called whenever a non-communication interrupt occurs. It is recommended that the extension interface provides the last reading of the KCS flags so that an OEM extension can see the state of SMS_ATN.</p><li><p>Software should be aware that IPMI v1.0 implementations were not required to set SMS_ATN for all non- communication interrupts. If a BMC implementation does not set SMS_ATN for all non-communication interrupts, it must generate a separate OBF interrupt for non-communication interrupts. A controller that does not set SMS_ATN for all non-communication interrupts is not allowed to use the same OBF interrupt to signal the both completion of communications and a non-communications interrupt.</p><li><p>Regardless of whether the IDLE_STATE OBF interrupt is shared with a pending non-communications interrupt, software drivers must examine SMS_ATN after clearing OBF. If SMS_ATN is asserted the driver must process the non-communications interrupt sources.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/ipmi-spec/">ipmi_spec</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/ipmi/" class="post-tag no-text-decoration" >ipmi</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Keyboard%20Controller%20Style%20(KCS)%20Interface%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fkcs%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Keyboard%20Controller%20Style%20(KCS)%20Interface%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fkcs%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fkcs%2F&text=Keyboard%20Controller%20Style%20(KCS)%20Interface%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/dirty-tracking/">dirty tracking</a><li class="text-truncate lh-lg"> <a href="/posts/vfio/">vfio</a><li class="text-truncate lh-lg"> <a href="/posts/host-bridge/">host-bridge is pci device BUT NOT pci bridge</a><li class="text-truncate lh-lg"> <a href="/posts/wbinvd-emulate/">emulate wbinvd</a><li class="text-truncate lh-lg"> <a href="/posts/pci_bridge/">qemu brige migration</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-hot-upgrade/">qemu_hot_upgrade</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/apic-timer/">apic-timer</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-rate/">dirty rate</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-bitmap/">dirty-bitmap</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/virtual-machine-control-structures/" class="btn btn-outline-primary" aria-label="Older" ><p>VIRTUAL MACHINE CONTROL STRUCTURES</p></a> <a href="/posts/pgcacher/" class="btn btn-outline-primary" aria-label="Newer" ><p>pgcacher</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-hot-upgrade/">qemu_hot_upgrade</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/apic-timer/">apic-timer</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-rate/">dirty rate</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-bitmap/">dirty-bitmap</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
