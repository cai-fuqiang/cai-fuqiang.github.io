<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="一文搞懵IO虚拟化之 – virtio" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="overflow virtio: ABSTRACTION API virtio-vring virtqueue ops vring vring struct vring notify sample of handle VirtIO why virtio is so efficient" /><meta property="og:description" content="overflow virtio: ABSTRACTION API virtio-vring virtqueue ops vring vring struct vring notify sample of handle VirtIO why virtio is so efficient" /><link rel="canonical" href="/posts/virtio/" /><meta property="og:url" content="/posts/virtio/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-06-05T09:21:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="一文搞懵IO虚拟化之 – virtio" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2025-06-05T09:21:00+08:00","datePublished":"2025-06-05T09:21:00+08:00","description":"overflow virtio: ABSTRACTION API virtio-vring virtqueue ops vring vring struct vring notify sample of handle VirtIO why virtio is so efficient","headline":"一文搞懵IO虚拟化之 – virtio","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/virtio/"},"url":"/posts/virtio/"}</script><title>一文搞懵IO虚拟化之 -- virtio | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>一文搞懵IO虚拟化之 -- virtio</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>一文搞懵IO虚拟化之 -- virtio</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1749086460" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jun 5, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="4443 words" > <em>24 min</em> read</span></div></div></div></header><div class="content"><ul><li><a href="">overflow</a><li><a href="">virtio: ABSTRACTION API</a><li><a href="">virtio-vring</a><ul><li><a href="">virtqueue ops</a><li><a href="">vring</a><ul><li><a href="">vring struct</a><li><a href="">vring notify</a><li><a href="">sample of handle VirtIO</a></ul></ul><li><a href="">why virtio is so efficient</a></ul><h2 id="overflow"><span class="me-2">overflow</span><a href="#overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>virtio 起源于 2008 年的 <code class="language-plaintext highlighter-rouge">virtio: Towards a De-Facto Standard For Virtual I/O Devices</code>该论 文<sup>1,2</sup>, 而其诞生的背景是, Linux 内核作为guest支持高达8种虚拟化系统:</p><ul><li>Xen<li>KVM<li>VMware 的 VMI<li>IBM 的 System p<li>IBM 的 System z<li>User Mode Linux<li>lguest<li>IBM 的遗留 iSeries</ul><p>而之后，可能还会出现新的系统。每个platform都希望拥有自己的块设备, 网络和控制台驱 动程序, 有的时候还需要一个 boutique framebuffer, USB controller, host filesystem and virtual kitchen sink controller…另外，它们中很少有对驱动程序进行任何显著的 优化，并且提供了很多重复的但是往往略有不同的功能机。更重要的是，no-one seems particularly delighted with their drivers, or having to maintain them.(大家对维护 这个都没有热情). 所以，当时需要一个统一标准, 高效的半虚拟化设备来替代它们。</p><p>而2006年KVM出现后, 需求又更加迫切，因为KVM当时还没有一个虚拟化设备模型。使用模拟设备 性能非常受限。Rusty Russell 团队认为可以创建一个公通用，高效能在多种虚拟机和平台 运行的virtio IO 机制.</p><p>最终, 作者设计了两个完整的API:</p><ul><li>virtio-vring（传输层)<ul><li>NOTE: 往往定制化的传输机制会让自己的通用性更差:<ul><li>针对某个hyperisor 或者架构<li>甚至经常为每一种设备单独定制</ul><p>所以, virtio-vring的实现并不激进或者革命性。</p></ul><li>Linux API for virtual I/O devices.<ul><li>device probing<ul><li>提供feature negotiation来保证 device和driver之间的 向前/向后兼容.</ul><li>device configuration</ul></ul><h2 id="virtio-abstraction-api"><span class="me-2">virtio: ABSTRACTION API</span><a href="#virtio-abstraction-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>作者设计了一个抽象层:</p><ul><li>通用的驱动程序<li>一系列函数指针</ul><p>函数指针如下:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">//from 6.15.0-rc6</span>
<span class="k">struct</span> <span class="nc">virtio_config_ops</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span>
                    <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">generation</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">);</span>
        <span class="n">u8</span> <span class="p">(</span><span class="o">*</span><span class="n">get_status</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_status</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">status</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">);</span>
        <span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_features</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">finalize_features</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">);</span>

        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">bus_name</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">);</span>

        <span class="c1">// 老版本代码，下面的成员在virtqueue_ops</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">find_vqs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nvqs</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vqs</span><span class="p">[],</span>
                        <span class="k">struct</span> <span class="nc">virtqueue_info</span> <span class="n">vqs_info</span><span class="p">[],</span>
                        <span class="k">struct</span> <span class="nc">irq_affinity</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">del_vqs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">synchronize_cbs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_vq_affinity</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
                               <span class="k">const</span> <span class="k">struct</span> <span class="nc">cpumask</span> <span class="o">*</span><span class="n">cpu_mask</span><span class="p">);</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="nc">cpumask</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_vq_affinity</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span>
                                                 <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">get_shm_region</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span>
                               <span class="k">struct</span> <span class="nc">virtio_shm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">,</span> <span class="n">u8</span> <span class="n">id</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disable_vq_and_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_vq_after_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><p>最初的驱动, 主要包括以下功能:</p><ul><li><strong><em>features</em></strong>:<ul><li>get_features()<li>finalize_features()</ul><p>features bit 举例: 指示网络设备是否支持校验和卸载的 VIRTIO_NET_F_CSUM 特性位。</p><p>具体的协商步骤如下:</p><ol><li>driver 调用 get_features() 获取devices 的feature<li>driver 在上面的集合中选择自己版本支持的features<li>driver call finalize_features() to writeback subset features to devices</ol><p>如果需要renegotiate 只能reset设备.</p><li><strong><em>PCI configuration space</em></strong>:<ul><li>get()<li>set()</ul><p>配置空间内容和具体的虚拟设备强相关，另外，可能包含一些特定的配置字段, 这些配置字段可能受features控制。例如，网络设备如果有VIRTIO_NET_F_MAC features bit(host 希望设备有特定的mac地址)，配置空间中才包含该配置字段.</p><li><strong><em>PCI configuration space: STATUS bits</em></strong><ul><li>get_status()<li>set_status()</ul><p>该字段由guest来表示当前设备的探测状态。例如当达到<code class="language-plaintext highlighter-rouge">VIRTIO_CONFIG_S_DEVICE_OK</code> 状态时，表示guest已经完成device features probe. 此时host可以评估guest可以 支持哪些feature。</p><li><strong><em>devices reset</em></strong><ul><li>reset()</ul><p>重置设备: configuration space 和 status. 另外, 当执行reset操作时，缓冲区不应该被 覆盖，可以用来尝试在guest中恢复driver。</p></ul><p>通过上面的接口设计，做到了configuration API和driver分离，另外和trasnport相关API 也是一套独立的接口，所以其三者相互分离的。</p><blockquote><p>原文:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>The explicit separation of drivers, transport and configura-
tion represents a change in thinking from current implemen-
tations. 
</pre></table></code></div></div></blockquote><h2 id="virtio-vring"><span class="me-2">virtio-vring</span><a href="#virtio-vring" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="virtqueue-ops"><span class="me-2">virtqueue ops</span><a href="#virtqueue-ops" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然configuration API 很重要, 但是对性能的关键部分是实际的IO机制。作者将其 抽象为virtqueue. 而virtqueue的本质是一个由 driver (guest) produce buffer, 由 devices(host) consume buffer的队列。每个buffer 可以由多个只读，或者可读写的离散 的数据段组成的数组。virtqueue ops如下:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">virtqueue_ops</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="nc">scatterlist</span> <span class="n">sg</span><span class="p">[],</span>
                   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_num</span><span class="p">,</span>
                   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_num</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kick</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disable_cb</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_cb</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li><strong><em>add_buf</em></strong>: add a new buffer to avail queue, 其中<code class="language-plaintext highlighter-rouge">data</code>参数是一个token，当buffer已经 被consume时返回该值，用来标识该buffer. （是不是有点乱，这和vring的并行consume 有关, 下面会讲到)<li><strong><em>get_buf</em></strong>: gets a used buffer. len 用来指示 driver侧向buffer中填充了多少有效 数据. 而返回值则是返回的<code class="language-plaintext highlighter-rouge">add_buf()</code>的data参数(cookie). 上面也提到主要 的原因是 ` buffers are not necessarily used in order`<li><strong><em>kick</em></strong>: 在缓冲区被加入到队列时，用来notify 对方(host devices). 另外，可以添加 多个buffer后，在发一次kick。（batching)<li><p><strong><em>enable_cb,disable_cb</em></strong>:</p><p>启用禁用callback.</p><p>disable_cb 这相当于禁用中断。driver 会为每一个virtiqueue注册一个callback, 而这 些会在唤醒服务线程之前禁用掉这个回调(<font color="red">???啥服务线程<sup>1, todo</sup></font>). 从而减少vmm和guest的交互。</p><p>而enable_cb则表示开启中断（启用回调), 通常会driver处理完队列中的所有的待处理的请求 后调用。(used queue)</p></ul><h3 id="vring"><span class="me-2">VRING</span><a href="#vring" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="vring-struct"><span class="me-2">vring struct</span><a href="#vring-struct" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>介绍完相关的API之后，我们来看下用于transport 具体的数据结构. 该数据结构分为三部 分:</p><ul><li><strong><em>descriptor array</em></strong>: 管理所有的descriptor<li><strong><em>avail ring</em></strong>: guest driver 用来指示哪些desc 已经准备好了，可以被 host device 使用<li><strong><em>used ring</em></strong>: host device 用来指示哪些 desc 已经被used, 可以被 guest driver 获取 数据，然后free.</ul><p>我们结合 virtio-pci configuration space，来看下vring在configuration space的哪个 地方配置，还有其具体的数据结构:</p><p><img src="./pic/vring_overflow.svg" alt="vring_overflow" /></p><ul><li><p>配置空间中的comm configuration cap 中指示了<code class="language-plaintext highlighter-rouge">virtio_pci_comm_cfg</code> 结构在BAR空间 中的位置和offset, 该数据结构用来指示每个virtqueue的相关信息，其中包含其中包括 vring 的base address(<code class="language-plaintext highlighter-rouge">queue_desc</code>).</p><blockquote><p>NOTE</p><p>在支持多队列的场景下, <code class="language-plaintext highlighter-rouge">virtio_pci_comm_cfg.queue_select</code> 是一个可读写字段， 写该字段相当于一个select 操作。例如将该字段写1，然后在对<code class="language-plaintext highlighter-rouge">virtio_pci_comm_cfg.queue_desc</code> 执行写操作相当于配置<code class="language-plaintext highlighter-rouge">virtqueue 1</code>的 vring base address.</p></blockquote><li>queue_desc 指向的地址包含上面提到的三个数据结构。其虽然连续，但是为了优化 cacheline，每个数据结构中间可能会有padding field.<li><code class="language-plaintext highlighter-rouge">vring_avail</code>, <code class="language-plaintext highlighter-rouge">vring_used</code>中都包含一个idx，但是没有head, tail区分。两者需要结合来表示 整个队列的状态</ul><h4 id="vring-data-transport-external-consume"><span class="me-2">vring data transport external consume</span><a href="#vring-data-transport-external-consume" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>我们知道, 在guest mode中运行程序是有额外代价的，这个代价主要源于 host emulation, 有些emulation 是异步的(一般的IO device emulation), 这些emulation的动作会放到非 vcpu thread, 而有些emulation 是同步的, 常见的是 VM-EXIT, 这些VM-EXIT event有些是 主动的，有些是被动的，但是均会让guest trap到host.</p><p>而对于模拟设备的虚拟化尤其如此: WHY ? 我们看下图.</p><p><img src="./pic/PCIe_res.svg" alt="pcie resource" /></p><p>对于CPU而言, 和IO 虚拟化相关的操作主要有几下几个:</p><ul><li>访问 <font color="red"><strong>内存</strong></font> 中的ringbuffer，以及 ringbuffer 指向的相关数据.<li>通过MMIO PIO, 访问设备资源(一般是<font color="red"><strong>bar</strong></font> 指向的ioport, 或者 MMIO), 这些资源包括, 队列相关信息:<ul><li>ring.head,tail(ringbuffer base addr只会在初始化的时候配置)<li>doorbell</ul><li>设备向cpu notify(interrupt)</ul><p>而哪些会造成VM-exit呢? 准确的说，都有可能造成，但是一般的memory access可以控制 (假如某个地址触发ept violation), KVM 建立映射之后，一般不会取消映射，也就是下次 访问该地址所在的page不会再触发vm-exit.除非触发内核的某些内存管理功能, 如swap, ksm等。所以这些操作带来的影响很小.</p><p>那剩下的就是 MMIO/PIO 访问 <code class="language-plaintext highlighter-rouge">ring.head,tail</code>, <code class="language-plaintext highlighter-rouge">doorbell</code>, <code class="language-plaintext highlighter-rouge">interrupt</code>, 其中doorbell和interrupt都属于notify, 这个没有办法避免(但是也可以优化， 下个章节会讲)。那最终剩余<code class="language-plaintext highlighter-rouge">ring.head</code>, <code class="language-plaintext highlighter-rouge">ring.tail</code>能不能优化。一个很明显 的方法，是将其转移到内存中。</p><blockquote><p>NOTE</p><p>一般的物理设备都会将ring.head,tail 放到 device register上，不清楚其放在 设备上的好处。在chatgpt过程中，其提到, 可能是一些缓存一致性和 order问题.</p><p>但是仔细想想, 缓存一致性可以用 <code class="language-plaintext highlighter-rouge">Strong Uncacheable (UC)</code> 的内存类型避免, 虽然在执行atomic相关操作时(一般是多个cpu当作 producer 操作ring.head), 会造成比较严重的性能问题. (UC lock , another word bus lock, 总之会锁数 据总线). 而至于乱序, 也可以靠内存屏障解决. 所以，有知道的大佬可以帮忙 解答下.</p></blockquote><p>ok, 我们在来回顾virtio 的ring.idx:</p><ul><li>vring_desc.idx<li>vring_avail.idx</ul><p>其均在内存中。<font color="red"><strong>那在整个的数据传输过程中, 只剩余两个方向的 notify 会触发VM-exit了 !!</strong></font></p><h4 id="vring-notify"><span class="me-2">vring notify</span><a href="#vring-notify" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>notify的目的是, 当自己作为 producer 产生了数据，需要让对方(<code class="language-plaintext highlighter-rouge">[device &lt;-&gt; driver]</code>)处理时, 通知对方来感知这一行为。对于consume 来说, 这是被动的。 这里有一种主动的方式, 就是关闭notify, 由consume 侧一直循环观测 producer 的行为，看其是否产生了数据。这种称为poll。</p><p>对于两者而言, poll 的优点是延迟低, 但是需要消耗更多的计算资源.(如果不消耗 大量的计算资源的话，可能就适得其反).</p><p>而notify的好处是, 消耗较少的计算资源。但是坏处也很明显 : 延迟高. 并且会 打断当前的执行流程。</p><blockquote><p>NOTE</p><p>我们这里简单思考下: 在notify方式中，之所以消耗的计算资源少，是因为不使用计算资 源来轮训 producer的状态, 将该计算资源分配给别的任务，所以当notify 来临时，会打 断当前的执行流。而打断过程的上下文切换是延迟的一部分原因。另一部分是, 当前执行 的上下文不允许被打断(常见的是关中断), 所以, 需要等待该上下文可以被打断时（开中 断），再触发notify. 这样就造成了更大的延迟。</p></blockquote><p>无论在物理环境，还是在虚拟环境中, notify 有两个方向:</p><ul><li>driver-&gt;device : 设备特定<li>device-&gt;driver : interrupt</ul><p>但是两者的代价又不相同, 如下图:</p><p><img src="./pic/physical_vm_notify.svg" alt="physical vm notify" /></p><p>在物理机上，两个方向的notify 均由纯硬件逻辑实现, 所以其notify的传输速度非常快. 而在虚拟机环境中, 两个方向的notify均需要 host 去模拟，另外更糟心的是两个方向的 notify 均会造成vm exit。严重影响guest vcpu的执行效率.</p><ul><li>driver-&gt;device: MMIO write: vmexit to trap into host emulation<li>device-&gt;driver: 在virtio提出时, 中断虚拟化未支持完全(hardware), 并不能在cpu处于guest mode (<code class="language-plaintext highlighter-rouge">VMX Non-root operation</code>)时，注入 virq, 但是又为 了保证尽量减少中断延迟，于是需要kick vcpu. 也就是强制打断该vcpu，使其产生 vmexit (一般的做法是send ipi to this cpu, 让vcpu因 <code class="language-plaintext highlighter-rouge">receive external interrupt</code>而 vmexit.</ul><p>所以, 基于这一差距, 作者设计出一套 notify-less(inspired by tickless) 的优化。而在之后更新的virtio协议的更高版本, 也在持续优化这方面。</p><h4 id="sample-of-handle-virtio"><span class="me-2">sample of handle VirtIO</span><a href="#sample-of-handle-virtio" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>我们下面主要展示下, 在实际的数据传输时，vring, desc array 中的 数据流动.</p><hr /><p>在看图之前，我们先列举一些点:</p><ul><li><p>初始状态</p><p>假设vring大小为5, 并且初始状态下:</p><ul><li>所有的desc都是free的<li>vring_avail.idx = 0<li>vring_used.idx = 0</ul><p>guest, host会自己保存一个idx，该idx主要用来自己作为消费者，上次”消费”到哪了:</p><ul><li>guest: last_used_idx = 0<li>host: last_used_idx = 1</ul><li><p>region of data residency</p><p>在desc从vring desc freelist中移除后, desc会驻留在vring中，但是这里，我们 额外抽象出三个区域, 用来表示当前数据处理到哪个阶段:</p><ul><li>guest driver从 vring desc freelist取出desc，并准备其buffer<li>host driver 从avail vring 中获取到数据，并且正在将这些数据发送到IO后端<li>guest driver 从used vring中收到数据，并且正在唤醒 iowait 相关task</ul><p><strong>这样<code class="language-plaintext highlighter-rouge">avail vring</code>中保存的仅是<code class="language-plaintext highlighter-rouge">HOST DEVICE</code>未处理的数据, 而 <code class="language-plaintext highlighter-rouge">used vring</code> 保存的 仅是<code class="language-plaintext highlighter-rouge">GUEST driver</code>未处理的数据</strong>.</p><li><p>vring full &amp;&amp; vring empty</p><p>我们来思考下:</p><ol><li><p>vring full 在处理流程中需要谁来关心，另外，怎么判断整个的 vring是 full状态.</p><p><br /><br /><br /><br /> 思考中 <br /><br /><br /><br /></p><details> <summary>个人理解的答案</summary><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>A: 只有guest driver 其需要关心vring full, 因为其最终控制着 vring desc freelist 
   的申请和释放.

   另外, 怎么判断vring是否满也显而易见, 就是看vring desc freelist 中是否还有free
   的成员。

   所以vring full并不是指avail vring full, 或者 used vring full, 而就是表示所有
   的desc正在处理，没有归还到 vring desc freelist 中.
</pre></table></code></div></div></details><li><p>vring empty</p><p>这里就不卖官司了. vring empty 需要落实到每个vring上(avail, used). 而且只有 consumer角色需要关心这些:</p><ul><li>guest driver: used vring is empty ?<li>host device: avail vring is empty ?</ul><details> <summary>题外话，可以先略过</summary><blockquote><p>NOTE</p><p>这里先跑题说些别的:</p><p>队列是否empty ? 这个判断条件需要 driver/device 在设备正常工作后一直判断 …</p><p>所以这里有两种方式实现:</p><ul><li>poll…<li>NOTIFY</ul><p>我们知道，poll的好处是延迟低，但是cpu 消耗高。而notify的好处是 cpu消耗低， 但是延迟稍微高一些. 但是在虚拟化场景下, notify 往往会造成vm-exit，从而带来 很大的额外开销.</p><p>这里先剧透下, 在整个的IO transport 过程中，virtio 优化的非常彻底，只有 notify 会造成vm-exit。所以，virtio 针对notify 也提出一些优化点. 总结成一个 单词 notify-less(inspired by tickless)</p></blockquote></details></ol></ul><p>ok, 了解完上述点后，我们来看下面的图:</p><hr /><p><img src="./pic/vring1.svg" alt="vring1" /></p><p>这是一个初始状态图，</p><ul><li>所有的desc都在 vring desc FREELIST中。<li>所有的idx(包括last_xxx_idx)都是0。</ul><hr /><p><img src="./pic/vring2.svg" alt="vring2" /></p><ol><li>guest virtio driver收到blk 层的IO request, 从vring desc FREELIST中 申请了一个desc a, 并初始化a<li>初始化好a后，将a 放到 avail vring中. 此时, <code class="language-plaintext highlighter-rouge">avail_vring.idx=++0=1</code></ol><hr /><p><img src="./pic/vring3.svg" alt="vring3" /></p><p>guest driver收到了大量的IO 请求，此时将 vring desc FREELIST 的desc都申请完了, 此时vring 是 <strong>full</strong> 状态, 另外，guest driver 将所有的 desc均初始化完成, 并存放到vring此时:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>i = 4
while i--:
  avail_vring.idx++

avail_vring.idx is 5
</pre></table></code></div></div><hr /><p><img src="./pic/vring4.svg" alt="vring4" /></p><ol><li><p>host driver 通过某种途径感知到 avail vring中可能有东西(poll,notify), 于是比较 了下 <code class="language-plaintext highlighter-rouge">[last_avail_idx(0), avail_idx(5)]</code>发现确实有5个数据需要处理。</p><p>于是， 从avail vring中将所有的desc 拿出来处理（每个desc的处理可以并行执行), 并将这些io request 转换成对后端的请求。</p><p>此时last_avail_idx 0-&gt;5.</p><li>e,c,d 这三个请求率先完成, 将其存放到used vring中，此时 used_idx 0-&gt;3.<li>b, a 这两个请求也完成了，将其也存放到 used vring 中, 此时 used_idx 3-&gt;5.</ol><hr /><p><img src="./pic/vring5.svg" alt="vring5" /></p><ol><li><p>guest driver也通过某种途径感知到 used vring中可能有东西(poll, notify(interrupt)), 于是比较了下<code class="language-plaintext highlighter-rouge">[last_used_idx(0), used_idx(5)]</code>, 发现确实有5个io request 已经完 成，需要唤醒正在iowait的进程。</p><p>首先处理c，d两个数据。此时， last_used_idx 0-&gt;2</p><li>处理完c, d两个数据后，正要准备处理剩余的数据时, 和因c, d io request阻塞的进程均被 唤醒，而且释放了该io buffer, 此时将desc 归还到 vring desc FREELIST中<li>继续处理剩余的b,a e三个io request, 此时 last_used_idx 2-&gt;5<li>guest 中因virtqueue中的io request 阻塞的进程都被唤醒，并将desc 全都归还到 vring desc FREELIST中.</ol><hr /><p>至此, guest 请求的5个io 均完成。</p><h2 id="why-virtio-is-so-efficient"><span class="me-2">why virtio is so efficient</span><a href="#why-virtio-is-so-efficient" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="其他笔记"><span class="me-2">其他笔记</span><a href="#其他笔记" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>avail<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Note that there is padding such as to place this structure on a page separate
from the available ring and descriptor array: this gives nice cache behavior
and acknowledges that each side need only ever write to one part of the
virtqueue structure.
</pre></table></code></div></div><li>suppress notifications<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>Note the vring_used flags and the vring_avail flags: these
are currently used to suppress notifications. For example,
the used flags field is used by the host to tell the guest that
no kick is necessary when it adds buffers: as the kick requires
a vmexit, this can be an important optimization, and the
KVM implementation uses this with a timer for network
transmission exit mitigation. Similarly, the avail flags field
is used by the guest network driver to advise that further
interrupts are not required (i.e., disable_cb and enable_cb
set and unset this bit).
</pre></table></code></div></div></ol><h2 id="参考链接"><span class="me-2">参考链接</span><a href="#参考链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><a href="https://www.ozlabs.org/~rusty/virtio-spec/virtio-paper.pdf">virtio: Towards a De-Facto Standard For Virtual I/O Devices</a><li><a href="https://zhuanlan.zhihu.com/p/68154666">virtio 虚拟化系列之一：从 virtio 论文开始</a><li><a href="https://www.mail-archive.com/kvm-devel@lists.sourceforge.net/msg00847.html">what it is that makes the Qemu hardware emulation so slow</a></ol><h2 id="todo"><span class="me-2">TODO</span><a href="#todo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><p><code class="language-plaintext highlighter-rouge">the virtqueue callback might disable further callbacks before waking a service thread.</code></p><p>service thread ?? what ??</p></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/virt/">virt</a>, <a href="/categories/io-virt/">io_virt</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/io-virt/" class="post-tag no-text-decoration" >io_virt</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E4%B8%80%E6%96%87%E6%90%9E%E6%87%B5IO%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%20--%20virtio%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fvirtio%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E4%B8%80%E6%96%87%E6%90%9E%E6%87%B5IO%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%20--%20virtio%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fvirtio%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fvirtio%2F&text=%E4%B8%80%E6%96%87%E6%90%9E%E6%87%B5IO%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%20--%20virtio%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/js-comm-webset/">[js] js common webset</a><li class="text-truncate lh-lg"> <a href="/posts/smmu-operation/">Smmu Operation</a><li class="text-truncate lh-lg"> <a href="/posts/2-the-translation-process/">[smmu] 2. The Translation Process</a><li class="text-truncate lh-lg"> <a href="/posts/smmu-security-extensions/">[smmu] Security Extensions</a><li class="text-truncate lh-lg"> <a href="/posts/learn_the_architecture_gicv3v4/">[arm] gic</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/virtio-notify/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1749463800" data-df="ll" > Jun 9, 2025 </time><h4 class="pt-0 my-2">virtio notify</h4><div class="text-muted"><p>virtio feature : VIRTIO_RING_F_EVENT_IDX 我们这里抽象下，先定义一个producer, consumer的模型, 将 event_idx定义为head，将vring.idx定义为tail, 即 1 2 consumer modify head producer modify tail(和vring.idx一样，表示producer下次要存储数据的位置...</p></div></div></a></article><article class="col"> <a href="/posts/iommu/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1737697740" data-df="ll" > Jan 24, 2025 </time><h4 class="pt-0 my-2">iommu</h4><div class="text-muted"><p>what is iommu IOMMU 顾名思义，就是让IO 的MMU, 可以允许IO request 进行类似于 CPU 侧MMU根据页表映射 而完成地址转换的行为。 而IO request 主要包含哪些呢? DMA request interrupt 而iommu 的作用就是完成这些request的重映射, 如下图所示: CPU 侧 request 通过CPU M...</p></div></div></a></article><article class="col"> <a href="/posts/vfio/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1737795600" data-df="ll" > Jan 25, 2025 </time><h4 class="pt-0 my-2">vfio</h4><div class="text-muted"><p>vfio qemu vfio_realize =&amp;gt; vfio_attach_device =&amp;gt; VFIOIOMMUClass-&amp;gt;attach_device : vfio_iommu_legacy_class_init : iommufd_cdev_attach vfio_iommu_leg...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/ebpf/" class="btn btn-outline-primary" aria-label="Older" ><p>Ebpf</p></a> <a href="/posts/virtio-notify/" class="btn btn-outline-primary" aria-label="Newer" ><p>virtio notify</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
