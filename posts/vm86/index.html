<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="vm86" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="FROM intel sdm chapter 21 8086 emulation" /><meta property="og:description" content="FROM intel sdm chapter 21 8086 emulation" /><link rel="canonical" href="/posts/vm86/" /><meta property="og:url" content="/posts/vm86/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-04-22T10:30:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="vm86" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2024-04-22T10:30:00+08:00","datePublished":"2024-04-22T10:30:00+08:00","description":"FROM intel sdm chapter 21 8086 emulation","headline":"vm86","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/vm86/"},"url":"/posts/vm86/"}</script><title>vm86 | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>vm86</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>vm86</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1713753000" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Apr 22, 2024 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="11076 words" > <em>61 min</em> read</span></div></div></div></header><div class="content"><blockquote><p>FROM intel sdm <code class="language-plaintext highlighter-rouge">chapter 21 8086 emulation</code></p></blockquote><h2 id="abstract"><span class="me-2">abstract</span><a href="#abstract" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>IA-32 processors (beginning with the Intel386 processor) provide two ways to execute new or legacy programs that are assembled and/or compiled to run on an Intel 8086 processor:</p><blockquote><p>IA-32处理器(起始于intel386处理器)提供了两种来执行new/legacy 程序,这些程序被 assembled(组装?) and/or compiled(编译) 以在intel 8086处理器上运行.</p></blockquote><ul><li>Real-address mode.<li>Virtual-8086 mode.</ul><p>Figure 2-3 shows the relationship of these operating modes to protected mode and system management mode (SMM).</p><blockquote><p>Figure 2-3 展示了这些操作模式和 保护模式以及 SMM 的关系</p></blockquote><p><img src="pic/figure-2-3.png" alt="figure-2-3" /></p><p>When the processor is powered up or reset, it is placed in the real-address mode. This operating mode almost exactly duplicates the execution environment of the Intel 8086 processor, with some extensions. Virtually any program assembled and/or compiled to run on an Intel 8086 processor will run on an IA-32 processor in this mode.</p><blockquote><p>当处理器被 power up 或者 reset, 他处于 real-address mode. 这种操作模式几乎 完全复制了Intel 8086处理器的执行环境，并进行了一些扩展。实际上，任何在 Intel 8086 处理器上组装和/或编译的程序都可以在此模式下在 IA-32 处理器上运行.</p></blockquote><p>When running in protected mode, the processor can be switched to virtual-8086 mode to run 8086 programs. This mode also duplicates the execution environment of the Intel 8086 processor, with extensions. In virtual-8086 mode, an 8086 program runs as a separate protected-mode task. Legacy 8086 programs are thus able to run under an operating system (such as Microsoft Windows*) that takes advantage of protected mode and to use protected-mode facilities, such as the protected-mode interrupt- and exception-handling facilities. Protected-mode multitasking permits multiple virtual-8086 mode tasks (with each task running a separate 8086 program) to be run on the processor along with other non-virtual-8086 mode tasks.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>take advantage of : 利用
facility  [fəˈsɪləti] : 组件, 设施, 特色, 天赋, 才能
</pre></table></code></div></div><p>当运行在保护模式下时，处理器可以切换到virtual-8086模式来运行8086程序。该模式还 复制了Intel 8086 处理器的执行环境，并进行了扩展。在virtual-8086 模式下，8086 程 序作为单独的保护模式任务运行。 因此，传统 8086 程序能够在利用保护模式的操作系统 （例如 Microsoft Windows*）下运行并使用保护模式facilities(组件, 设施)，例如保护 模式中断和异常处理facilities。 保护模式多任务处理允许多个virtual-8086 模式task （每个任务运行一个单独的 8086 程序）与其他 non-virtual-8086 模式任务一起在处理器 上运行。</p></blockquote><p>This section describes both the basic real-address mode execution environment and the virtual-8086-mode execution environment, available on the IA-32 processors beginning with the Intel386 processor.</p><blockquote><p>本节介绍基于 real-address 模式执行环境和virtual-8086 模式执行环境，可在从 Intel386 处理器开始的 IA-32 处理器上使用。</p></blockquote><h2 id="211-real-address-mode"><span class="me-2">21.1 REAL-ADDRESS MODE</span><a href="#211-real-address-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The IA-32 architecture’s real-address mode runs programs written for the Intel 8086, Intel 8088, Intel 80186, and Intel 80188 processors, or for the real-address mode of the Intel 286, Intel386, Intel486, Pentium, P6 family, Pentium 4, and Intel Xeon processors.</p><blockquote><p>IA-32 架构的实地址模式运行为 Intel 8086、Intel 8088、Intel 80186 和 Intel 80188 处理器编写的程序，或为 Intel 286、Intel386、Intel486、Pentium、 P6 系列、Pentium 4 和 英特尔至强处理器, 实地址模式编写的程序.</p></blockquote><p>The execution environment of the processor in real-address mode is designed to duplicate the execution environment of the Intel 8086 processor. To an 8086 program, a processor operating in real-address mode behaves like a high-speed 8086 processor. The principal features of this architecture are defined in Chapter 3, “Basic Execution Environment”, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.</p><blockquote><p>real-address模式下处理器的执行环境旨在复制Intel 8086处理器的执行环境。 对于 8086 程序来说，运行在实地址模式下的处理器的行为类似于高速 8086 处理器。 该架构的主要功能在 itnel sdm Volume 1 Chapter 3 “Basic Execution Environment”</p></blockquote><p>The following is a summary of the core features of the real-address mode execution environment as would be seen by a program written for the 8086:</p><blockquote><p>以下是为 8086 编写的程序所看到的实地址模式执行环境的核心功能的摘要：</p></blockquote><ul><li>The processor supports a nominal 1-MByte physical address space (see Section 21.1.1, “Address Translation in Real-Address Mode”, for specific details). This address space is divided into segments, each of which can be up to 64 KBytes in length. The base of a segment is specified with a 16-bit segment selector, which is shifted left by 4 bits to form a 20-bit offset from address 0 in the address space. An operand within a segment is addressed with a 16-bit offset from the base of the segment. A physical address is thus formed by adding the offset to the 20-bit segment base (see Section 21.1.1, “Address Translation in Real-Address Mode”).<blockquote><p>处理器支持标称 1 MB 物理地址空间（有关具体细节，请参见第 21.1.1 节”实地址模式 下的地址转换”）。 该地址空间分为多个段，每个段的长度最多可达 64 KB。 段的基址由 16 位段选择器指定，该段选择器左移 4 位，形成距地址空间中地址 0 的 20 位偏移量。 段内的操作数通过距段基址的 16 位偏移量进行寻址。 因此，通过将偏移量添 加到 20 位段基址来形成物理地址（请参见第 21.1.1 节“实地址模式下的地址转换”）。</p></blockquote><li>All operands in “native 8086 code” are 8-bit or 16-bit values. (Operand size override prefixes can be used to access 32-bit operands.)<blockquote><p>“native 8086 代码”中的所有操作数都是 8 位或 16 位值。（操作数大小覆盖前缀 可用于访问 32 位操作数。）</p></blockquote><li>Eight 16-bit general-purpose registers are provided: AX, BX, CX, DX, SP, BP, SI, and DI. The extended 32 bit registers (EAX, EBX, ECX, EDX, ESP, EBP, ESI, and EDI) are accessible to programs that explicitly perform a size override operation.<blockquote><p>提供 8 个 16 位通用寄存器：AX、BX、CX、DX、SP、BP、SI 和 DI。 扩展的 32 位寄存器（EAX、EBX、ECX、EDX、ESP、EBP、ESI 和 EDI）可供显式执行大小覆盖 操作的程序访问。</p></blockquote><li>Four segment registers are provided: CS, DS, SS, and ES. (The FS and GS registers are accessible to programs that explicitly access them.) The CS register contains the segment selector for the code segment; the DS and ES registers contain segment selectors for data segments; and the SS register contains the segment selector for the stack segment.<blockquote><p>提供了四个段寄存器：CS、DS、SS 和 ES。 （FS 和 GS 寄存器可供显式访问它们的 程序访问。）CS 寄存器包含代码段的段选择器； DS和ES寄存器包含数据段的段选择器； SS 寄存器包含堆栈段的段选择器。</p></blockquote><li>The 8086 16-bit instruction pointer (IP) is mapped to the lower 16-bits of the EIP register. Note this register is a 32-bit register and unintentional address wrapping may occur.<blockquote><p>unintentional: [ˌʌnɪnˈtenʃənl] 无意的; 非故意的; 偶然的</p><p>8086 16 位指令指针（IP）映射到 EIP 寄存器的低 16 位。 请注意，该寄存器是 32 位寄存器，可能会发生 unintentional address wrapping</p><blockquote class="prompt-warning"><p>unintentional address wrapping 在 “21.1.1 Address Translation in Real-Address Mode” 有介绍</p></blockquote></blockquote><li>The 16-bit FLAGS register contains status and control flags. (This register is mapped to the 16 least significant bits of the 32-bit EFLAGS register.)<blockquote><p>16 位标志寄存器包含状态和控制标志。（该寄存器映射到 32 位 EFLAGS 寄存器的 16 个最低有效位。）</p></blockquote><li>All of the Intel 8086 instructions are supported (see Section 21.1.3, “Instructions Supported in Real-Address Mode”).<blockquote><p>支持所有 Intel 8086 指令（请参见第 21.1.3 节“instruction supported in real- address mode”）。</p></blockquote><li>A single, 16-bit-wide stack is provided for handling procedure calls and invocations of interrupt and exception handlers. This stack is contained in the stack segment identified with the SS register. The SP (stack pointer) register contains an offset into the stack segment. The stack grows down (toward lower segment offsets) from the stack pointer. The BP (base pointer) register also contains an offset into the stack segment that can be used as a pointer to a parameter list. When a CALL instruction is executed, the processor pushes the current instruction pointer (the 16 least-significant bits of the EIP register and, on far calls, the current value of the CS register) onto the stack. On a return, initiated with a RET instruction, the processor pops the saved instruction pointer from the stack into the EIP register (and CS register on far returns). When an implicit call to an interrupt or exception handler is executed, the processor pushes the EIP, CS, and EFLAGS (low-order 16-bits only) registers onto the stack. On a return from an interrupt or exception handler, initiated with an IRET instruction, the processor pops the saved instruction pointer and EFLAGS image from the stack into the EIP, CS, and EFLAGS registers.<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>invocations [ˌɪnvəʊˈkeɪʃənz]: 调用; 启用; 祈祷
procedure  [prəˈsiːdʒə(r)] : 程序, 步骤, 手续, 手术
</pre></table></code></div></div><p>提供了一个 16 位宽的堆栈来处理procedure calls以及中断和异常处理程序的调用。 该堆栈包含在由 SS 寄存器标识的堆栈段中。 SP（堆栈指针）寄存器包含堆栈段的偏 移量。 堆栈从堆栈指针向下增长（朝向较低的段偏移量）。 BP（基指针）寄存器还 包含堆栈段的偏移量，可用作指向参数列表的指针。 当执行 CALL 指令时，处理器将 当前指令指针（EIP 寄存器的 16 个最低有效位，以及far all 时 CS 寄存器的当前值） 推送到堆栈上。 在使用 RET 指令启动的返回时，处理器将保存的指令指针从堆栈pop 到 EIP 寄存器（以及远返回时的 CS 寄存器）。 当执行对中断或异常处理程序的隐式 调用时，处理器会将 EIP、CS 和 EFLAGS（仅限低位 16 位）寄存器压入堆栈。 从使用 IRET 指令启动的中断或异常处理程序返回时，处理器将保存的指令指针和 EFLAGS image 从堆栈pop到 EIP、CS 和 EFLAGS 寄存器中。</p></blockquote><li>A single interrupt table, called the “interrupt vector table” or “interrupt table,” is provided for handling interrupts and exceptions (see Figure 21-2). The interrupt table (which has 4-byte entries) takes the place of the interrupt descriptor table (IDT, with 8-byte entries) used when handling protected-mode interrupts and exceptions. Interrupt and exception vector numbers provide an index to entries in the interrupt table. Each entry provides a pointer (called a “vector”) to an interrupt- or exception-handling procedure. See Section 21.1.4, “Interrupt and Exception Handling”, for more details. It is possible for software to relocate the IDT by means of the LIDT instruction on IA-32 processors beginning with the Intel386 processor.<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>by means of: 通过
take the place of: 取代, 代替
</pre></table></code></div></div><p>提供了一个称为“中断向量表”或“中断表”的中断表来处理中断和异常（见图 21-2）。 中断表（具有 4-byte 条目）取代了处理保护模式中断和异常时使用的中断描述符表 （IDT，具有 8-byte条目）。 中断和异常向量号提供中断表中条目的索引。 每个条 目都提供一个指向interrupt &amp;&amp; exception-handling procedure 的指针（称为“向量”）。 更多详细信息，请参见第 21.1.4 节”中断和异常处理”。 从 Intel386 处理器开始， 软件可以通过 IA-32 处理器上的 LIDT 指令来重新定位 IDT。</p></blockquote><li>The x87 FPU is active and available to execute x87 FPU instructions in real-address mode. Programs written to run on the Intel 8087 and Intel 287 math coprocessors can be run in real-address mode without modification.<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>coprocessors: 辅助处理器, 协处理器
</pre></table></code></div></div><p>x87 FPU 处于活动状态，可在实地址模式下执行 x87 FPU 指令。 为在 Intel 8087 和 Intel 287 数学协处理器上运行而编写的程序无需修改即可在实地址模式下 运行。</p></blockquote></ul><p>The following extensions to the Intel 8086 execution environment are available in the IA-32 architecture’s real-address mode. If backwards compatibility to Intel 286 and Intel 8086 processors is required, these features should not be used in new programs written to run in real-address mode.</p><blockquote><p>Intel 8086 执行环境的以下扩展可在 IA-32 架构的实地址模式下使用。如果需要向后兼 容 Intel 286 和 Intel 8086 处理器，则不应在为在实地址模式下运行而编写的新程序中 使用这些功能。</p></blockquote><ul><li>Two additional segment registers (FS and GS) are available.<li>Many of the integer and system instructions that have been added to later IA-32 processors can be executed in real-address mode (see Section 21.1.3, “Instructions Supported in Real-Address Mode”).<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>integer [ˈɪntɪdʒər]: 整数
</pre></table></code></div></div><p>许多已添加到后续 IA-32 处理器中的整数和系统指令都可以在实地址模式下执行 （请参见第 21.1.3 节“实地址模式支持的指令”）。</p></blockquote><li>The 32-bit operand prefix can be used in real-address mode programs to execute the 32-bit forms of instructions. This prefix also allows real-address mode programs to use the processor’s 32-bit general-purpose registers.<blockquote><p>32 位操作数前缀可用于实地址模式程序来执行 32 位形式的指令。 该前缀还允 许实地址模式程序使用处理器的 32 位通用寄存器。</p></blockquote><li>The 32-bit address prefix can be used in real-address mode programs, allowing 32-bit offsets. Many of the integer and system instructions that have been added to later IA-32 processors can be executed in real-address mode (see Section 21.1.3, “Instructions Supported in Real-Address Mode”).<blockquote><p>32位地址前缀可用于实地址模式程序，允许32位偏移。 许多已添加到后续 IA-32 处理器中的整数和系统指令都可以在实地址模式下执行（请参见第 21.1.3 节 “实地址模式支持的指令”）。</p></blockquote></ul><p>The following sections describe address formation, registers, available instructions, and interrupt and exception handling in real-address mode. For information on I/O in real-address mode, see Chapter 19, “Input/Output”, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. a 32-bit register and unintentional address wrapping may occur.</p><blockquote><p>以下部分描述了实地址模式下的地址形成、寄存器、可用指令以及中断和异常处理。 有关实地址模式下 I/O 的信息，请参阅intel sdm 第 1 卷第 19 章“Input/Output”。 可能会发生 32 位寄存器和unintentional address wrapping。</p></blockquote><h3 id="2111-address-translation-in-real-address-mode"><span class="me-2">21.1.1 Address Translation in Real-Address Mode</span><a href="#2111-address-translation-in-real-address-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In real-address mode, the processor does not interpret segment selectors as indexes into a descriptor table; instead, it uses them directly to form linear addresses as the 8086 processor does. It shifts the segment selector left by 4 bits to form a 20-bit base address (see Figure 21-1). The offset into a segment is added to the base address to create a linear address that maps directly to the physical address space.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>interpret  [ɪnˈtɜːprət]: 解释, 说明; 把...理解为
</pre></table></code></div></div><p>在实地址模式下，处理器不会将段选择器解释为描述符表的索引； 相反，它像 8086 处理 器一样直接使用它们来形成线性地址。 它将段选择子左移 4 位，形成 20 位基地址 （见图 21-1）。 段中的偏移量被添加到基地址以创建直接映射到物理地址空间的线性地址。</p></blockquote><p>When using 8086-style address translation, it is possible to specify addresses larger than 1 MByte. For example, with a segment selector value of FFFFH and an offset of FFFFH, the linear (and physical) address would be 10FFEFH (1 megabyte plus 64 KBytes). The 8086 processor, which can form addresses only up to 20 bits long, truncates the high-order bit, thereby “wrapping” this address to FFEFH. When operating in real-address mode, however, the processor does not truncate such an address and uses it as a physical address. (Note, however, that for IA-32 processors beginning with the Intel486 processor, the A20M# signal can be used in real-address mode to mask address line A20, thereby mimicking the 20-bit wrap-around behavior of the 8086 processor.) Care should be take to ensure that A20M# based address wrapping is handled correctly in multiprocessor based system.</p><blockquote><p>当使用 8086 类型的地址转换时，可以指定大于 1 MB 的地址。 例如，如果段选择器值 为 FFFFH，偏移量为 FFFFH，则线性（物理）地址将为 10FFEFH（1 兆字节加 64 KB）。</p><blockquote class="prompt-tip"><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>0xffff&lt;&lt;4 + 0xffff 
  = 64K * 16 + 64k 
  = 1M-byte + 64K 
  = 0x10ffef
</pre></table></code></div></div></blockquote><p>8086 处理器只能形成最多 20 位长的地址，它会截断高位，从而将该地址“包装”为 FFEFH。 然而，当在实地址模式下运行时，处理器不会截断此类地址并将其用作物理地址。 （但请 注意，对于从 Intel486 处理器开始的 IA-32 处理器，可以在实地址模式下使用 A20M# 信号来maks address line A20，从而模仿 8086 处理器的 20 位wrap-around行为。 ）应注 意确保在基于多处理器的系统中正确处理基于 A20M# 的address wrapping</p></blockquote><p><img src="pic/real-address-mode-address-translation.png" alt="real-address-mode-address-translation" /></p><p>The IA-32 processors beginning with the Intel386 processor can generate 32-bit offsets using an address override prefix; however, in real-address mode, the value of a 32-bit offset may not exceed FFFFH without causing an exception.</p><blockquote><p>从Intel386处理器开始的IA-32处理器可以使用address override prefix生成32位偏移量； 然而，在实地址模式下，32位偏移量的值不能超过FFFFH而不引起异常。</p></blockquote><p>For full compatibility with Intel 286 real-address mode, pseudo-protection faults (interrupt 12 or 13) occur if a 32- bit offset is generated outside the range 0 through FFFFH.</p><blockquote><p>为了与 Intel 286 实地址模式完全兼容，如果在 0 到 FFFFH 范围之外生成 32 位偏移， 则会发生 pseudo-protection (伪保护故障（中断 12 或 13）。</p></blockquote><h3 id="2112-registers-supported-in-real-address-mode"><span class="me-2">21.1.2 Registers Supported in Real-Address Mode</span><a href="#2112-registers-supported-in-real-address-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The register set available in real-address mode includes all the registers defined for the 8086 processor plus the new registers introduced in later IA-32 processors, such as the FS and GS segment registers, the debug registers, the control registers, and the floating-point unit registers. The 32-bit operand prefix allows a real-address mode program to use the 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESP, EBP, ESI, and EDI).</p><blockquote><p>实地址模式下可用的寄存器集包括为 8086 处理器定义的所有寄存器以及后来的 IA-32 处理器中引入的新寄存器，例如 FS 和 GS 段寄存器、调试寄存器、 控制寄存器和浮点寄存器。 32 位操作数前缀允许实地址模式程序使用 32 位通用 寄存器（EAX、EBX、ECX、EDX、ESP、EBP、ESI 和 EDI）。</p></blockquote><h3 id="2113-instructions-supported-in-real-address-mode"><span class="me-2">21.1.3 Instructions Supported in Real-Address Mode</span><a href="#2113-instructions-supported-in-real-address-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The following instructions make up the core instruction set for the 8086 processor. If backwards compatibility to the Intel 286 and Intel 8086 processors is required, only these instructions should be used in a new program written to run in real-address mode.</p><blockquote><p>以下指令构成了 8086 处理器的核心指令集。 如果需要向后兼容 Intel 286 和 Intel 8086 处理器，在编写为在实地址模式下运行的新程序中仅使用这些指令。</p></blockquote><ul><li>Move (MOV) instructions that move operands between general-purpose registers, segment registers, and between memory and general-purpose registers.<li>The exchange (XCHG) instruction.<li>Load segment register instructions LDS and LES.<li>Arithmetic instructions ADD, ADC, SUB, SBB, MUL, IMUL, DIV, IDIV, INC, DEC, CMP, and NEG.<li>Logical instructions AND, OR, XOR, and NOT.<li>Decimal instructions DAA, DAS, AAA, AAS, AAM, and AAD.<blockquote><p>decimal [ˈdesɪml] :十进制</p></blockquote><li>Stack instructions PUSH and POP (to general-purpose registers and segment registers).<li>Type conversion instructions CWD, CDQ, CBW, and CWDE.<blockquote><p>conversion : 转换, 转变</p></blockquote><li>Shift and rotate instructions SAL, SHL, SHR, SAR, ROL, ROR, RCL, and RCR.<blockquote><p>rotate [ˈroʊteɪt]: 旋转</p></blockquote><li>TEST instruction.<li>Control instructions JMP, Jcc, CALL, RET, LOOP, LOOPE, and LOOPNE.<li>Interrupt instructions INT n, INTO, and IRET.<li>EFLAGS control instructions STC, CLC, CMC, CLD, STD, LAHF, SAHF, PUSHF, and POPF.<li>I/O instructions IN, INS, OUT, and OUTS.<li>Load effective address (LEA) instruction, and translate (XLATB) instruction.<li>LOCK prefix.<li>Repeat prefixes REP, REPE, REPZ, REPNE, and REPNZ.<li>Processor halt (HLT) instruction.<li>No operation (NOP) instruction.</ul><p>The following instructions, added to later IA-32 processors (some in the Intel 286 processor and the remainder in the Intel386 processor), can be executed in real-address mode, if backwards compatibility to the Intel 8086 processor is not required.</p><blockquote><p>如果不需要向后兼容 Intel 8086 处理器，则添加到后来的 IA-32 处理器（一些在 Intel 286 处理器中，其余在 Intel386 处理器中）的以下指令可以在实地址模式下执行。</p></blockquote><ul><li>Move (MOV) instructions that operate on the control and debug registers.<li>Load segment register instructions LSS, LFS, and LGS.<li>Generalized multiply instructions and multiply immediate data.<blockquote><p>Generalized [ˈdʒenrəlaɪzd] : 广义的</p></blockquote><li>Shift and rotate by immediate counts.<li>Stack instructions PUSHA, PUSHAD, POPA, POPAD, and PUSH immediate data.<li>Move with sign extension instructions MOVSX and MOVZX.<li>Long-displacement Jcc instructions.<blockquote><p>displacement: 移位;取代</p></blockquote><li>Exchange instructions CMPXCHG, CMPXCHG8B, and XADD.<li>String instructions MOVS, CMPS, SCAS, LODS, and STOS.<li>Bit test and bit scan instructions BT, BTS, BTR, BTC, BSF, and BSR; the byte-set-on condition instruction SETcc;and the byte swap (BSWAP) instruction.<li>EFLAGS control instructions PUSHF and POPF.<li>ENTER and LEAVE control instructions.<li>BOUND instruction.<li>CPU identification (CPUID) instruction.<li>System instructions CLTS, INVD, WINVD, INVLPG, LGDT, SGDT, LIDT, SIDT, LMSW, SMSW, RDMSR, WRMSR, RDTSC, and RDPMC.</ul><p>Execution of any of the other IA-32 architecture instructions (not given in the previous two lists) in real-address mode result in an invalid-opcode exception (#UD) being generated.</p><blockquote><p>在实地址模式下执行任何其他 IA-32 架构指令（前两个列表中未给出）都会导致生成 invaild-opcode 异常 (#UD)。</p><h3 id="2114-interrupt-and-exception-handling"><span class="me-2">21.1.4 Interrupt and Exception Handling</span><a href="#2114-interrupt-and-exception-handling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></blockquote><p>When operating in real-address mode, software must provide interrupt and exception-handling facilities that are separate from those provided in protected mode. Even during the early stages of processor initialization when the processor is still in real-address mode, elementary real-address mode interrupt and exception-handling facilities must be provided to ensure reliable operation of the processor, or the initialization code must ensure that no interrupts or exceptions will occur.</p><blockquote><p>当在实地址模式下运行时，软件必须提供与保护模式下提供的中断和异常处理设施分开 的facilities。 即使在处理器初始化的早期阶段，当处理器仍处于实地址模式时， 也必须提供基本实地址模式中断和异常处理设施，以确保处理器的可靠运行， 或者必须保证初始化代码没有中断或触发异常。</p></blockquote><p>The IA-32 processors handle interrupts and exceptions in real-address mode similar to the way they handle them in protected mode. When a processor receives an interrupt or generates an exception, it uses the vector number of the interrupt or exception as an index into the interrupt table. (In protected mode, the interrupt table is called the interrupt descriptor table (IDT), but in real-address mode, the table is usually called the interrupt vector table, or simply the interrupt table.) The entry in the interrupt vector table provides a pointer to an interrupt- or exception-handler procedure. (The pointer consists of a segment selector for a code segment and a 16-bit offset into the segment.) The processor performs the following actions to make an implicit call to the selected handler:</p><blockquote><p>IA-32 处理器在实地址模式下处理中断和异常的方式与在保护模式下处理中断和异常的方 式类似。 当处理器接收到中断或生成异常时，它使用中断或异常的向量号作为中断表的索引。 （在保护模式下，中断表称为中断描述符表（IDT），但在实地址模式下，该表通常称为中断 向量表，或简称为中断表。）中断向量表中的条目提供 指向中断或异常处理程序的指针。 （指针由代码段的段选择器和段中的 16 位偏移量组成。）处理器执行以下操作以隐式调用 所选处理程序：</p></blockquote><ol><li>Pushes the current values of the CS and EIP registers onto the stack. (Only the 16 least-significant bits of the EIP register are pushed.)<li>Pushes the low-order 16 bits of the EFLAGS register onto the stack.<li>Clears the IF flag in the EFLAGS register to disable interrupts.<li><p>Clears the TF, RF, and AC flags, in the EFLAGS register.</p><li>Transfers program control to the location specified in the interrupt vector table.</ol><p>An IRET instruction at the end of the handler procedure reverses these steps to return program control to the interrupted program. Exceptions do not return error codes in real-address mode. The interrupt vector table is an array of 4-byte entries (see Figure 21-2). Each entry consists of a far pointer to a handler procedure, made up of a segment selector and an offset. The processor scales the interrupt or exception vector by 4 to obtain an offset into the interrupt table. Following reset, the base of the interrupt vector table is located at physical address 0 and its limit is set to 3FFH. In the Intel 8086 processor, the base address and limit of the interrupt vector table cannot be changed. In the later IA-32 processors, the base address and limit of the inter- rupt vector table are contained in the IDTR register and can be changed using the LIDT instruction.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>reverses [rɪˈvɜːsɪz] : 反转
</pre></table></code></div></div><p>处理程序末尾的 IRET 指令反转这些步骤，将程序控制权返回给被中断的程序。 在实地址模式下，异常不会返回错误代码。 中断向量表是一个 4 字节条目的数组 （见图 21-2）。 每个条目都包含一个指向处理程序过程的远指针， 该指针由段选择器和偏移量组成。 处理器将中断或异常向量 乘 4 以获得中断表 中的偏移量。 复位后，中断向量表的基址位于物理地址 0，其限制设置为 3FFH。 在Intel 8086处理器中，中断向量表的基地址和限制是不能改变的。 在后来的 IA-32 处理器中，中断向量表的基址和限制包含在 IDTR 寄存器中，并且可以使用 LIDT 指令进行更改。</p></blockquote><p>(For backward compatibility to Intel 8086 processors, the default base address and limit of the interrupt vector table should not be changed.)</p><blockquote><p>（为了向后兼容 Intel 8086 处理器，不应更改中断向量表的默认基址和限制。）</p></blockquote><p><img src="pic/interrupt_vector_table_in_real_address_mode.png" alt="interrupt_vector_table_in_real_address_mode" /></p><p>Table 21-1 shows the interrupt and exception vectors that can be generated in real-address mode and virtual-8086 mode, and in the Intel 8086 processor. See Chapter 6, “Interrupt and Exception Handling”, for a description of the exception conditions.</p><blockquote><p>表 21-1 显示了在实地址模式和虚拟 8086 模式以及 Intel 8086 处理器中可以生成的中 断和异常向量。有关异常情况的描述，请参见第 6 章“interrupt and exception handling”。</p></blockquote><h2 id="212-virtual-8086-mode"><span class="me-2">21.2 VIRTUAL-8086 MODE</span><a href="#212-virtual-8086-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Virtual-8086 mode is actually a special type of a task that runs in protected mode. When the operating-system or executive switches to a virtual-8086-mode task, the processor emulates an Intel 8086 processor. The execution environment of the processor while in the 8086-emulation state is the same as is described in Section 21.1, “Real-Address Mode” for real-address mode, including the extensions. The major difference between the two modes is that in virtual-8086 mode the 8086 emulator uses some protected-mode services (such as the protected-mode interrupt and exception-handling and paging facilities).</p><blockquote><p>Virtual-8086 模式实际上是一种在保护模式下运行的特殊任务类型。 当操作系统 或执行程序切换到虚拟 8086 模式任务时，处理器将模拟 Intel 8086 处理器。 处理器在 8086 仿真状态下的执行环境与第 21.1 节“real address mode”中描述的实 地址模式相同，包括扩展。 两种模式之间的主要区别在于，在虚拟 8086 模式下， 8086 仿真器使用一些保护模式服务（例如保护模式中断、异常处理和分页功能）。</p></blockquote><p>As in real-address mode, any new or legacy program that has been assembled and/or compiled to run on an Intel 8086 processor will run in a virtual-8086-mode task. And several 8086 programs can be run as virtual-8086-mode tasks concurrently with normal protected-mode tasks, using the processor’s multitasking facilities.</p><blockquote><p>concurrently [kənˈkʌrəntli]: 同时</p><p>与实地址模式一样，任何已组装和/或编译以在 Intel 8086 处理器上运行的new/legacy程序 都将在虚拟 8086 模式任务中运行。 使用处理器的多任务处理功能，多个 8086 程序可以作 为虚拟 8086 模式任务与正常保护模式任务同时运行。</p></blockquote><p><img src="pic/Table_21_1_rmode_exp_and_intr.png" alt="Table_21_1_rmode_exp_and_intr" /></p><blockquote><p>NOTE:</p><p>In the real-address mode, vector 13 is the segment overrun exception. In protected and virtual-8086 modes, this exception covers all general-protection error conditions, including traps to the virtual-8086 monitor from virtual-8086 mode.</p><blockquote><p>在实地址模式下，向量13是段溢出异常。 在受保护模式和虚拟 8086 模式下， 此异常涵盖所有general-proctection错误情况，包括从virtual-8086 模式到virtual-8086 监视器的陷阱。</p></blockquote></blockquote><h3 id="2121-enabling-virtual-8086-mode"><span class="me-2">21.2.1 Enabling Virtual-8086 Mode</span><a href="#2121-enabling-virtual-8086-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The processor runs in virtual-8086 mode when the VM (virtual machine) flag in the EFLAGS register is set. This flag can only be set when the processor switches to a new protected-mode task or resumes virtual-8086 mode via an IRET instruction.</p><blockquote><p>当 EFLAGS 寄存器中的 VM（虚拟机）标志被设置时，处理器以virtual-8086 模式运行。 仅当处理器切换到新的protected-mode task 或通过 IRET 指令恢复虚拟 8086 模式时， 才能设置此标志。</p></blockquote><p>System software cannot change the state of the VM flag directly in the EFLAGS register (for example, by using the POPFD instruction). Instead it changes the flag in the image of the EFLAGS register stored in the TSS or on the stack following a call to an interrupt- or exception-handler procedure. For example, software sets the VM flag in the EFLAGS image in the TSS when first creating a virtual-8086 task.</p><blockquote><p>系统软件无法直接更改 EFLAGS 寄存器中 VM 标志的状态（例如，通过使用 POPFD 指令）。 相反，它会在调用中断或异常处理程序过程后更改存储在 TSS 或堆栈中的 EFLAGS 寄存器映像中的标志。 例如，当首次创建虚拟 8086 任务时，软件会在 TSS 的 EFLAGS image中设置 VM 标志。</p></blockquote><p>The processor tests the VM flag under three general conditions:</p><ul><li>When loading segment registers, to determine whether to use 8086-style address translation.<blockquote><p>当加载段寄存器时，确定是否使用8086风格的地址转换。</p></blockquote><li>When decoding instructions, to determine which instructions are not supported in virtual-8086 mode and which instructions are sensitive to IOPL<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>sensitive: 敏感
</pre></table></code></div></div><p>解码指令时，确定哪些指令在 virtual-8086 模式下不支持以及哪些指令对 IOPL sensitive</p></blockquote><li>When checking privileged instructions, on page accesses, or when performing other permission checks. (Virtual-8086 mode always executes at CPL 3.)<blockquote><p>检查特权指令、页面访问或执行其他权限检查时。 （虚拟 8086 模式始终在 CPL 3 上执行。）</p></blockquote></ul><h3 id="2122-structure-of-a-virtual-8086-task"><span class="me-2">21.2.2 Structure of a Virtual-8086 Task</span><a href="#2122-structure-of-a-virtual-8086-task" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A virtual-8086-mode task consists of the following items:</p><ul><li>A 32-bit TSS for the task.<li>The 8086 program.<li>A virtual-8086 monitor.<li>8086 operating-system services.</ul><p>The TSS of the new task must be a 32-bit TSS, not a 16-bit TSS, because the 16-bit TSS does not load the most-significant word of the EFLAGS register, which contains the VM flag. All TSS’s, stacks, data, and code used to handle exceptions when in virtual-8086 mode must also be 32-bit segments.</p><blockquote><p>新任务的 TSS 必须是 32 位 TSS，而不是 16 位 TSS，因为 16 位 TSS 不加载 EFLAGS 寄存器的最高有效字，该寄存器包含 VM 标志。 在虚拟 8086 模式下用于处 理异常的所有 TSS、堆栈、数据和代码也必须是 32 位段。</p><blockquote class="prompt-tip"><p>RFLAGS.VM (Bit 17)</p></blockquote></blockquote><p>The processor enters virtual-8086 mode to run the 8086 program and returns to protected mode to run the virtual- 8086 monitor.</p><blockquote><p>处理器进入虚拟8086模式以运行8086程序，并返回到保护模式以运行虚拟8086 monitor。</p></blockquote><p>The virtual-8086 monitor is a 32-bit protected-mode code module that runs at a CPL of 0. The monitor consists of initialization, interrupt- and exception-handling, and I/O emulation procedures that emulate a personal computer or other 8086-based platform. Typically, the monitor is either part of or closely associated with the protected-mode general-protection (#GP) exception handler, which also runs at a CPL of 0. As with any protected-mode code module, code-segment descriptors for the virtual-8086 monitor must exist in the GDT or in the task’s LDT. The virtual-8086 monitor also may need data-segment descriptors so it can examine the IDT or other parts of the 8086 program in the first 1 MByte of the address space. The linear addresses above 10FFEFH are available for the monitor, the operating system, and other system software.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>closely: 紧密的, 接近的
examine [ɪɡˈzæmɪn]: 检查审查
</pre></table></code></div></div><p>virtual-8086 monitor是一个 32 位保护模式code module，运行于 CPL 0 。监视器由初始化、 中断和异常处理以及模拟个人计算机或其他 8086-based platform 的 I/O 模拟程序组成。 通常，监视器是受保护模式通用保护 (#GP) 异常处理程序的一部分或与之密切相关，该异 常处理程序也在 CPL 为 0 时运行。与任何受保护模式代码模块一样， virtual-8086 监视器 必须存在于 GDT 或任务的 LDT 中。 virtual-8086 监视器还可能需要数据段描述符， 以便它可以检查地址空间前 1 MB 中的 IDT 或 8086 程序的其他部分。 10FFEFH 以上的线 性地址可供显示器、操作系统和其他系统软件使用。</p></blockquote><p>The 8086 operating-system services consists of a kernel and/or operating-system procedures that the 8086 program makes calls to. These services can be implemented in either of the following two ways:</p><blockquote><p>8086 操作系统服务由 8086 程序调用的内核和/或操作系统过程组成。 这些服务可以通过 以下两种方式实现：</p></blockquote><ul><li>They can be included in the 8086 program. This approach is desirable for either of the following reasons:<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>desirable [dɪˈzaɪərəbl]: 可取的
</pre></table></code></div></div><p>它们可以包含在 8086 程序中。 由于以下任一原因，这种方法是可取的：</p></blockquote><ul><li>The 8086 program code modifies the 8086 operating-system services.<blockquote><p>8086程序代码修改8086操作系统服务。</p></blockquote><li>There is not sufficient development time to merge the 8086 operating-system services into main operating system or executive.<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>sufficient  [səˈfɪʃnt] : 足够的
</pre></table></code></div></div><p>没有足够的开发时间将 8086 操作系统服务合并到主操作系统或执行程序中。</p></blockquote></ul><li>They can be implemented or emulated in the virtual-8086 monitor. This approach is desirable for any of the following reasons:<blockquote><p>它们可以在virtual-8086 监视器中实现或模拟。 由于以下任一原因，这种方法是可取的：</p></blockquote><ul><li>The 8086 operating-system procedures can be more easily coordinated among several virtual-8086 tasks.<blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>coordinateda  [koʊˈɔːrdɪneɪtɪd] : 使协调; 使相配合;
</pre></table></code></div></div><p>8086 操作系统程序可以更轻松地在多个虚拟 8086 任务之间进行协调。</p></blockquote><li>Memory can be saved by not duplicating 8086 operating-system procedure code for several virtual-8086 tasks.<blockquote><p>通过不为多个虚拟 8086 任务复制 8086 操作系统过程代码，可以节省内存。</p></blockquote><li>The 8086 operating-system procedures can be easily emulated by calls to the main operating system or executive.<blockquote><p>通过调用主操作系统或执行程序可以轻松模拟 8086 操作系统程序。</p></blockquote></ul></ul><p>The approach chosen for implementing the 8086 operating-system services may result in different virtual-8086- mode tasks using different 8086 operating-system services.</p><blockquote><p>选择用于实现 8086 操作系统服务的方法可能会因使用不同 8086 操作系统服务的 导致virtual-8086-mode task 不同</p></blockquote><h3 id="2123-paging-of-virtual-8086-tasks"><span class="me-2">21.2.3 Paging of Virtual-8086 Tasks</span><a href="#2123-paging-of-virtual-8086-tasks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Even though a program running in virtual-8086 mode can use only 20-bit linear addresses, the processor converts these addresses into 32-bit linear addresses before mapping them to the physical address space. If paging is being used, the 8086 address space for a program running in virtual-8086 mode can be paged and located in a set of pages in physical address space. If paging is used, it is transparent to the program running in virtual-8086 mode just as it is for any task running on the processor.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>done B, before done A: done B, 然后在 done A
</pre></table></code></div></div><p>即使在virtual-8086 模式下运行的程序只能使用 20 位线性地址，处理器也会将这些地址 转换为 32 位线性地址，然后再将它们映射到物理地址空间。 如果正在使用分页，则可 以对在虚拟 8086 模式下运行的程序的 8086 地址空间进行分页并将其定位在物理地址空 间中的一组页面中。 如果使用分页，则它对于在虚拟 8086 模式下运行的程序是透明的， 就像对于处理器上运行的任何任务一样。</p></blockquote><p>Paging is not necessary for a single virtual-8086-mode task, but paging is useful or necessary in the following situations:</p><blockquote><p>对于单个虚拟 8086 模式任务来说，分页不是必需的，但在以下情况下分页是有用 或必要的：</p></blockquote><ul><li>When running multiple virtual-8086-mode tasks. Here, paging allows the lower 1 MByte of the linear address space for each virtual-8086-mode task to be mapped to a different physical address location.<blockquote><p>运行多个虚拟 8086 模式任务时。 这里，分页允许将每个虚拟 8086 模式任务的线性 地址空间的低 1 MB 映射到不同的物理地址位置。</p></blockquote><li>When emulating the 8086 address-wraparound that occurs at 1 MByte. When using 8086-style address translation, it is possible to specify addresses larger than 1 MByte. These addresses automatically wraparound in the Intel 8086 processor (see Section 21.1.1, “Address Translation in Real-Address Mode”). If any 8086 programs depend on address wraparound, the same effect can be achieved in a virtual-8086-mode task by mapping the linear addresses between 100000H and 110000H and linear addresses between 0 and 10000H to the same physical addresses.<blockquote><p>当模拟 1 MB 处发生的 8086 address-wraparound时。 当使用 8086 类型的地址转 换时，可以指定大于 1 MB 的地址。 这些地址在 Intel 8086 处理器中自动 wraparound （请参见第 21.1.1 节“实地址模式下的地址转换”）。如果任何8086程序依赖于address wraparound, 则通过将100000H和110000H之间的线性地址以及0和10000H之间的线性地址映 射到相同的物理地址，可以在虚拟8086模式任务中实现相同的效果。</p></blockquote><li>When sharing the 8086 operating-system services or ROM code that is common to several 8086 programs running as different 8086-mode tasks.<blockquote><p>当共享作为不同 8086 模式任务运行的多个 8086 程序所共用的 8086 操作系统服务或 ROM 代码时。</p></blockquote><li>When redirecting or trapping references to memory-mapped I/O devices.<blockquote><p>当重定向或捕获对 memory-mapped I/O 设备的引用时。</p></blockquote></ul><h3 id="2124-protection-within-a-virtual-8086-task"><span class="me-2">21.2.4 Protection within a Virtual-8086 Task</span><a href="#2124-protection-within-a-virtual-8086-task" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Protection is not enforced between the segments of an 8086 program. Either of the following techniques can be used to protect the system software running in a virtual-8086-mode task from the 8086 program:</p><blockquote><p>enforced [ɪnˈfɔːst]: 强迫的, 强制性的</p><p>8086 程序的段之间不强制执行保护。 可以使用以下任一技术来保护在 virtual-8086 模式任务中运行的系统软件免受 8086 程序的影响：</p></blockquote><ul><li>Reserve the first 1 MByte plus 64 KBytes of each task’s linear address space for the 8086 program. An 8086 processor task cannot generate addresses outside this range.<blockquote><p>为 8086 程序保留每个任务的前 1 MB 加上 64 KB 的线性地址空间。 8086 处理器task 无法生成此范围之外的地址。</p></blockquote><li>Use the U/S flag of page-table entries to protect the virtual-8086 monitor and other system software in the virtual-8086 mode task space. When the processor is in virtual-8086 mode, the CPL is 3. Therefore, an 8086 processor program has only user privileges. If the pages of the virtual-8086 monitor have supervisor privilege, they cannot be accessed by the 8086 program.<blockquote><p>使用页表条目的 U/S 标志来保护virtual-8086 monitor和virtual-8086 模式任务 空间中的其他系统软件。 当处理器处于virtual-8086模式时，CPL为3。因此， 8086处理器程序仅具有用户权限。 如果虚拟 8086 监视器的页面具有管理员权限， 则 8086 程序无法访问它们。</p></blockquote></ul><h3 id="2125-entering-virtual-8086-mode"><span class="me-2">21.2.5 Entering Virtual-8086 Mode</span><a href="#2125-entering-virtual-8086-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Figure 21-3 summarizes the methods of entering and leaving virtual-8086 mode. The processor switches to virtual-8086 mode in either of the following situations:</p><blockquote><p>图21-3总结了进入和离开虚拟8086模式的方法。 在以下任一情况下，处理器会切换到 虚拟 8086 模式：</p></blockquote><ul><li>Task switch when the VM flag is set to 1 in the EFLAGS register image stored in the TSS for the task. Here the task switch can be initiated in either of two ways:<blockquote><p>当任务的 TSS 中存储的 EFLAGS 寄存器映像中的 VM 标志设置为 1 时，进行任务切 换。 这里可以通过两种方式启动任务切换：</p></blockquote><ul><li>A CALL or JMP instruction.<li>An IRET instruction, where the NT flag in the EFLAGS image is set to 1.<blockquote><p>IRET, with EFLAGS image ‘s NT flag == 1</p></blockquote></ul><li>Return from a protected-mode interrupt or exception handler when the VM flag is set to 1 in the EFLAGS register image on the stack.<blockquote><p>当堆栈上 EFLAGS 寄存器映像中的 VM 标志设置为 1 时，从保护模式中断或异常处理 程序返回。</p></blockquote></ul><p>When a task switch is used to enter virtual-8086 mode, the TSS for the virtual-8086-mode task must be a 32-bit TSS. (If the new TSS is a 16-bit TSS, the upper word of the EFLAGS register is not in the TSS, causing the processor to clear the VM flag when it loads the EFLAGS register.) The processor updates the VM flag prior to loading the segment registers from their images in the new TSS. The new setting of the VM flag determines whether the processor interprets the contents of the segment registers as 8086-style segment selectors or protected-mode segment selectors. When the VM flag is set, the segment registers are loaded from the TSS, using 8086-style address translation to form base addresses.</p><blockquote><p>当使用任务切换进入virtual-8086模式时，virtual-8086模式任务的TSS必须是32位TSS。 （如果新的TSS是16位TSS，则EFLAGS寄存器的高位不在TSS中，导致处理器在加载EFLAGS寄 存器时清除VM标志。）处理器在加载之前更新VM标志 该段将image注册到新的 TSS 中。 VM 标志的新设置确定处理器是否将段寄存器的内容解释为 8086 型段选择器或保护模式 段选择器。 当VM标志被设置时，段寄存器从TSS加载，使用8086类型的地址转换来形成基 地址。</p><blockquote class="prompt tip"><p>否则, 段寄存器的值将在段选择子 indicate 的 段描述符中加载</p></blockquote></blockquote><p>See Section 21.3, “Interrupt and Exception Handling in Virtual-8086 Mode”, for information on entering virtual- 8086 mode on a return from an interrupt or exception handler.</p><blockquote><p>有关从中断或异常处理程序返回时进入虚拟 8086 模式的信息，请参见第 21.3 节 “虚拟 8086 模式中的中断和异常处理”。</p></blockquote><p><img src="pic/enter_and_leaving_v8086.png" alt="enter_and_leaving_v8086" /></p><h3 id="2126-leaving-virtual-8086-mode"><span class="me-2">21.2.6 Leaving Virtual-8086 Mode</span><a href="#2126-leaving-virtual-8086-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The processor can leave the virtual-8086 mode only through an interrupt or exception. The following are situations where an interrupt or exception will lead to the processor leaving virtual-8086 mode (see Figure 21-3):</p><blockquote><p>处理器只能通过中断或异常离开虚拟 8086 模式。 以下是中断或异常将导致处理器离 开虚拟 8086 模式的情况（见图 21-3）：</p></blockquote><ul><li>The processor services a hardware interrupt generated to signal the suspension of execution of the virtual-8086 application. This hardware interrupt may be generated by a timer or other external mechanism. Upon receiving the hardware interrupt, the processor enters protected mode and switches to a protected-mode (or another virtual-8086 mode) task either through a task gate in the protected-mode IDT or through a trap or interrupt gate that points to a handler that initiates a task switch. A task switch from a virtual-8086 task to another task loads the EFLAGS register from the TSS of the new task. The value of the VM flag in the new EFLAGS determines if the new task executes in virtual-8086 mode or not.<blockquote><p>处理器处理硬件中断，该中断产生用于作为暂停执行虚拟 8086 应用程序的信号。 该硬件中断可以由定时器或其他外部机制产生。 收到硬件中断后，处理器进入保 护模式并且切换到一个 protected-mode task(或者 另一个 virtual-8086 mode task). 方式有两种, 要么通过保护模式 IDT 中的任务门或通过指向handler的陷阱或中断门, 该handler 会发起一个task switch. 从virtual-8086 任务到另一个任务的任务切换会 从新任务的 TSS 加载 EFLAGS 寄存器。新 EFLAGS 中 VM 标志的值决定新任务是否以 virtual-8086 模式执行。</p></blockquote><li>The processor services an exception caused by code executing the virtual-8086 task or services a hardware interrupt that “belongs to” the virtual-8086 task. Here, the processor enters protected mode and services the exception or hardware interrupt through the protected-mode IDT (normally through an interrupt or trap gate) and the protected-mode exception- and interrupt-handlers. The processor may handle the exception or interrupt within the context of the virtual 8086 task and return to virtual-8086 mode on a return from the handler procedure. The processor may also execute a task switch and handle the exception or interrupt in the context of another task.<blockquote><p>处理器为执行 virtual-8086 任务的代码引起的异常提供服务，或者为“属于”virtual-8086 任务的硬件中断提供服务。 这里，处理器进入保护模式并通过保护模式IDT（通常通过中 断或陷阱门）以及保护模式异常和中断处理程序来处理异常或硬件中断。 处理器可以在虚拟8086任务的上下文中处理异常或中断，并在从处理程序过程返回时 返回到虚拟8086模式。 处理器还可以执行任务切换并在另一个任务的上下文中处理异常 或中断。</p></blockquote><li><p>The processor services a software interrupt generated by code executing in the virtual-8086 task (such as a software interrupt to call a MS-DOS* operating system routine). The processor provides several methods of handling these software interrupts, which are discussed in detail in Section 21.3.3, “Class 3—Software Interrupt Handling in Virtual-8086 Mode”. Most of them involve the processor entering protected mode, often by means of a general-protection (#GP) exception. In protected mode, the processor can send the interrupt to the virtual-8086 monitor for handling and/or redirect the interrupt back to the application program running in virtual-8086 mode task for handling.</p><blockquote><p>处理器为 virtual-8086 任务中执行的代码生成的软件中断提供服务（例如调用 MS-DOS* 操作系统例程的软件中断）。 处理器提供了几种处理这些软件中断的方法， 这些方法在第 21.3.3 节“Class 3—Software Interrupt Handling in Virtual-8086 Mode”中详细讨论。其中大多数涉及处理器进入保护模式，通常是通过通用保护（#GP） 异常的方式。 在保护模式下，处理器可以将中断发送到virtual-8086监视器以进行处 理和/或将中断重定向回以virtual-8086模式任务运行的应用程序以进行处理。</p></blockquote><p>IA-32 processors that incorporate the virtual mode extension (enabled with the VME flag in control register CR4) are capable of redirecting software-generated interrupts back to the program’s interrupt handlers without leaving virtual-8086 mode. See Section 21.3.3.4, “Method 5: Software Interrupt Handling”, for more information on this mechanism.</p><blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>incorporate /ɪnˈkɔːpəreɪt/: 合并,包含
</pre></table></code></div></div><p>包含虚拟模式扩展（通过控制寄存器 CR4 中的 VME 标志启用）的 IA-32 处理器能够将软件生成的中断重定向回程序的中断处理程序，而无需离开虚拟 8086 模式。 有关此机制的更多信息，请参见第 21.3.3.4 节“方法 5：software interrupt handling”。</p></blockquote><li><p>A hardware reset initiated by asserting the RESET or INIT pin is a special kind of interrupt. When a RESET or INIT is signaled while the processor is in virtual-8086 mode, the processor leaves virtual-8086 mode and enters real-address mode.</p><blockquote><p>通过置位 RESET 或 INIT 引脚启动的硬件复位是一种特殊类型的中断。 当处理器 处于虚拟 8086 模式时发出 RESET 或 INIT 信号时，处理器将离开虚拟 8086 模式 并进入实地址模式。</p></blockquote><li>Execution of the HLT instruction in virtual-8086 mode will cause a general-protection (GP#) fault, which the protected-mode handler generally sends to the virtual-8086 monitor. The virtual-8086 monitor then determines the correct execution sequence after verifying that it was entered as a result of a HLT execution.<blockquote><p>在虚拟 8086 模式下执行 HLT 指令将导致general-protection (GP#) fault，保 护模式处理程序通常会将其发送到 virtual-8086 监视器。 然后，virtual-8086 监视 器在验证它是作为 HLT 执行的结果输入后确定正确的执行顺序。</p></blockquote></ul><p>See Section 21.3, “Interrupt and Exception Handling in Virtual-8086 Mode”, for information on leaving virtual-8086 mode to handle an interrupt or exception generated in virtual-8086 mode.</p><p>有关离开 virtual-8086 模式以处理 virtual-8086 模式中生成的中断或异常的信息， 请参见第 21.3 节 “Virtual-8086 模式下的中断和异常处理”。</p><h3 id="2127-sensitive-instructions"><span class="me-2">21.2.7 Sensitive Instructions</span><a href="#2127-sensitive-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When an IA-32 processor is running in virtual-8086 mode, the CLI, STI, PUSHF, POPF, INT n, and IRET instructions are sensitive to IOPL. The IN, INS, OUT, and OUTS instructions, which are sensitive to IOPL in protected mode, are not sensitive in virtual-8086 mode.</p><blockquote><p>当 IA-32 处理器运行在virtual-8086 模式下时，CLI、STI、PUSHF、POPF、INT n 和 IRET 指令对 IOPL 敏感。 IN、INS、OUT 和 OUTS 指令在保护模式下对 IOPL 敏感， 但在virtual-8086 模式下不敏感。</p></blockquote><p>The CPL is always 3 while running in virtual-8086 mode; if the IOPL is less than 3, an attempt to use the IOPL-sensitive instructions listed above triggers a general-protection exception (#GP). These instructions are sensitive to IOPL to give the virtual-8086 monitor a chance to emulate the facilities they affect.</p><blockquote><p>在virtual-8086 模式下运行时，CPL 始终为 3； 如果 IOPL 小于 3，则尝试使用上面列出 的 IOPL 敏感指令会触发一般保护异常 (#GP)。 这些指令对 IOPL 敏感，使virtual-8086 监视器有机会模拟它们影响的facilities。</p></blockquote><h3 id="2128-virtual-8086-mode-io"><span class="me-2">21.2.8 Virtual-8086 Mode I/O</span><a href="#2128-virtual-8086-mode-io" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>NULL</p><h2 id="213-interrupt-and-exception-handling-in-virtual-8086-mode"><span class="me-2">21.3 INTERRUPT AND EXCEPTION HANDLING IN VIRTUAL-8086 MODE</span><a href="#213-interrupt-and-exception-handling-in-virtual-8086-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>NULL</p><h2 id="214-protected-mode-virtual-interrupts"><span class="me-2">21.4 PROTECTED-MODE VIRTUAL INTERRUPTS</span><a href="#214-protected-mode-virtual-interrupts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>NULL</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/intel-sdm/">intel_sdm</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/virt/" class="post-tag no-text-decoration" >virt</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=vm86%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fvm86%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=vm86%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fvm86%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fvm86%2F&text=vm86%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/eevdf-paper/">schedule: Directory</a><li class="text-truncate lh-lg"> <a href="/posts/sched-weight/">schedule: weight</a><li class="text-truncate lh-lg"> <a href="/posts/stride_sched_paper/">[论文翻译] Lottery and Stride Scheduling: Flexible Proportional-Share Resource Management</a><li class="text-truncate lh-lg"> <a href="/posts/RMM/">[arm] RMM</a><li class="text-truncate lh-lg"> <a href="/posts/sched/">schedule: overflow</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/sched/">sched</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/drain-pasid/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1745329860" data-df="ll" > Apr 22, 2025 </time><h4 class="pt-0 my-2">drain pasid</h4><div class="text-muted"><p>PASID 简介 PASID overflow PASID 全称Process Address Space ID, PASID 同 requester ID结合，共同确定该request 所映射的地址空间。所以 PASID 和 ASID 类似, 均标识一个地址映射关系。但是ASID 用于 标识CPU 侧的memory request，而PASID 则标识PCIe end point 的D...</p></div></div></a></article><article class="col"> <a href="/posts/pml/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1713841200" data-df="ll" > Apr 23, 2024 </time><h4 class="pt-0 my-2">protected-mode memory management</h4><div class="text-muted"><p>29.3.6 Page-Modification Logging When accessed and dirty flags for EPT are enabled, software can track writes to guest-physical addresses using a feature called page-modification logging. 当启用了...</p></div></div></a></article><article class="col"> <a href="/posts/proctected-mode/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1713841200" data-df="ll" > Apr 23, 2024 </time><h4 class="pt-0 my-2">protected-mode memory management</h4><div class="text-muted"><p>FROM intel sdm CHAPTER 3 PROTECTED-MODE MEMORY MANAGEMENT abstract This chapter describes the Intel 64 and IA-32 architecture’s protected-mode memory management facilities, including the phys...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/async-pf-gup-change/" class="btn btn-outline-primary" aria-label="Older" ><p>async pf -- GUP change</p></a> <a href="/posts/enter-protect-mode/" class="btn btn-outline-primary" aria-label="Newer" ><p>when load control register during in switching rmode 2 pmode</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/sched/">sched</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
