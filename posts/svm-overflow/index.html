<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="svm" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="文章主要来自AMD sdm `15 Secure Virtual Machine" /><meta property="og:description" content="文章主要来自AMD sdm `15 Secure Virtual Machine" /><link rel="canonical" href="/posts/svm-overflow/" /><meta property="og:url" content="/posts/svm-overflow/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-03-03T13:30:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="svm" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2025-03-03T13:30:00+08:00","datePublished":"2025-03-03T13:30:00+08:00","description":"文章主要来自AMD sdm `15 Secure Virtual Machine","headline":"svm","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/svm-overflow/"},"url":"/posts/svm-overflow/"}</script><title>svm | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>svm</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>svm</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1740979800" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Mar 3, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5990 words" > <em>33 min</em> read</span></div></div></div></header><div class="content"><blockquote><p>文章主要来自AMD sdm `15 Secure Virtual Machine</p></blockquote><h2 id="overflow"><span class="me-2">overflow</span><a href="#overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>SVM 提供了由硬件扩展，旨在实现高效, 经济的虚拟机系统。其功能主要分为 virtualization support 和 security support, 概述如下:</p><ul><li>virtualization support<ul><li>memory<ul><li>guest/host tagged TLB<li>External (DMA) access protection for memory<li>Nested paging support</ul><li>interrupt virtualization<ul><li>Intercepting physical interrupt delivery<li>virtual interrupts<li>Sharing a physical APIC<li>Direct interrupt delivery</ul><li>CPU virtualization: guest mode &amp;&amp; host mode<ul><li>switch<li>intercept: ability to intercept selected instructions or events· in the guest</ul></ul><li>securitry support<ul><li>Attestation: SKINIT<li>Encrypted memory: SEV, SEV-ES<li>Secure Nested Paging: SEV-SNP<h2 id="cpu"><span class="me-2">CPU</span><a href="#cpu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="enabling-svm"><span class="me-2">Enabling SVM</span><a href="#enabling-svm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></ul></ul><p>虚拟化扩展指令</p><ul><li>VMRUN<li>VMLOAD<li>VMSAVE<li>CLGI<li>VMMCALL<li>INVLPGA</ul><p>执行需要<code class="language-plaintext highlighter-rouge">EFER.SVME</code> 被设置为1, 否则执行这些指令将会产生<code class="language-plaintext highlighter-rouge">#UD</code>.</p><p>另外</p><ul><li>SKINIT<li>STGI</ul><p>指令执行需要</p><ul><li>EFER.SVME 设置为1<li>CPUID Fn8000_0001_ECX[SKINIT] 设置为1</ul><p>否则执行也会产生<code class="language-plaintext highlighter-rouge">#UD</code></p><p>在使能SVM之前，如那件需要如下判断SVM是否能被enable.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>if (CPUID Fn8000_0001_ECX[SVM] == 0)
    return SVM_NOT_AVAIL;

if (VM_CR.SVMDIS == 0)
    return SVM_ALLOWED;

if (CPUID Fn8000_000A_EDX[SVML]==0)
    return SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE
// the user must change a platform firmware setting to enable SVM
else 
    return SVM_DISABLED_WITH_KEY;
// SVMLock may be unlockable; consult platform firmware or TPM to obtain the key.
</pre></table></code></div></div><h3 id="vmcb"><span class="me-2">VMCB</span><a href="#vmcb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>VMCB中即包括了guest上下文，也包括了用于vmm控制guest的配置信息。主要包括:</p><ul><li>在guest 中要拦截的一些列的instruction or event<li>各种控制位用于指定guest 的execution envirionment，或指示在运行来宾代码之前需要采 取的特殊操作，以及<li>guest processor state (例如, 控制寄存器)</ul><p>VMCB位于内存中, 某些指令和事件会根据vmcb构建guest上下文，或者将guest上下文writeback回vmcb，完成host和 guest之间的切换, 我们下面详细介绍</p><h4 id="vmrun-and-vmexit"><span class="me-2">VMRUN and #VMEXIT</span><a href="#vmrun-and-vmexit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>使用VMRUN指令操作数需指定一个VMCB地址, 即<code class="language-plaintext highlighter-rouge">rAX</code>, 在<code class="language-plaintext highlighter-rouge">VMRUN</code>时, 会从<code class="language-plaintext highlighter-rouge">rAX</code>指向的VMCB 内存中，先将当前cpu状态保存下来，然后再将部分字段load到当前CPU的上下文， 将全部cpu 状态load后，就相当于进入guest了。</p><p>具体操作是:</p><ul><li>remember VMCB address(rAX) for next #VMEXIT<li>save host state -&gt; <code class="language-plaintext highlighter-rouge">VM_HSAVE_PA</code> MSR<li>load control information<ul><li>intercept vector<li>TSC offset<li>interrupt control<li>EVENTINJ field<li>ASID</ul><li>load guest state<ul><li>ES, CS…<li>GDTR IDTR<li>CRxxx</ul></ul><p><strong>此时，cpu context 已经是guest</strong></p><ul><li>execute command store in TLB_CONTROL<li><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  IF (EVENTINJ.V)
   cause exception/interrupt in guest
  else
jump to first guest instruction
</pre></table></code></div></div><p>上面的某些信息，在这个过程中会替换掉当前host的上下文, 如GDTR. 但是某些字段是 不属于cpu context的, 例如<code class="language-plaintext highlighter-rouge">control information</code>, 这部分就相当于专门的cpu cache。 目的是:</p></ul><p>vmcb中的这些字段在guest中可能会频繁访问，例如, intercept INTR control field, 在每次外部中断到来时, 都会使用该字段。为了加速, 虚拟机运行时的性能，在VMRUN指令 执行时，会将<code class="language-plaintext highlighter-rouge">VMCB</code>中的大部分字段，加载到cpu内部的cache中.</p><p>如下图:</p><p><img src="./pic/VMCB.svg" alt="VMCB overflow" /></p><p>从上图可知:</p><ul><li>VMCB的cache以该VMCB在内存中的base physical address为tag, 在VMRUN时，会将 VMCB load到memory<li>当intecept 某些events时，可能会从触发 <code class="language-plaintext highlighter-rouge">#VMEXIT</code>. 这时，会将VMCB cache writeback 到memory<li>VMCB cache，并不是cache了 VMCB 全部, 包括:<ul><li>interrupt shadow<li>Event injection: 事件注入相关信息，在 <code class="language-plaintext highlighter-rouge">VMRUN</code> 时, 获取一次，并在进入guest之前，注入该event, 在之后guest运行过程中，不再需要这个字段, 所以这个信息没有必要cache<li>TLB Control: 和上同理<li>RFLAGS, RIP, RSP, RAX: CPU: CPU 上下文信息, 这些信息在#VMEXIT后，很可能会改变，并且 这些字段是load 到cpu context的。所以没有必要cache.(猜测)</ul></ul><p>另外, 在<code class="language-plaintext highlighter-rouge">VMRUN</code>和<code class="language-plaintext highlighter-rouge">#VMEXIT</code>时，需要save，load host state。这些CPU也做了相应的 类似于VMCB的cache。手册中的描述如下:</p><blockquote><p>Processor implementations may store only part or none of host state in the memory area pointed to by VM_HSAVE_PA MSR and may store some or all host state in hidden on-chip memory. Different implementations may choose to save the hidden parts of the host’s segment registers as well as the selectors. For these reasons, software must not rely on the format or contents of the host state save area, nor attempt to change host state by modifying the contents of the host save area.</p></blockquote><p>大致的意思是, 处理器可能会store 部分或者不会store 由 VM_HSAVE_PA MSR 指向的 host state, 并可能将部分或全部主机状态store 在 on-chip memory中。不同的实现 可能会选择保存主机段寄存器的隐藏部分以及选择器。因此，软件不能依赖于主机状态 保存区域的格式或内容，也不能通过修改主机保存区域的内容来尝试更改主机状态。</p><p>所以，guest host上下文切换，主要涉及 <code class="language-plaintext highlighter-rouge">VMCB -- VM_HSAVE_PA</code> 中包含的上下文 内容的切换, 但是某些event只需要简单处理后，又继续返回guest执行。这样就没有 必要切换一些寄存器。（使用guest的即可)</p><p>另外在大部分的场景下，在多次<code class="language-plaintext highlighter-rouge">VMRUN</code>, <code class="language-plaintext highlighter-rouge">#VMEXIT</code>期间, <code class="language-plaintext highlighter-rouge">VMCB</code>中的很多字段并没有改变。 为了加速guest, host的切换. <code class="language-plaintext highlighter-rouge">SVM</code>支持控制某些字段在<code class="language-plaintext highlighter-rouge">VMRUN</code>时才会load.</p><p>上面提到的两种情况，amd通过如下方式解决:</p><ul><li>VMCB clean Bits<li>VMLOAD, VMSAVE</ul><h5 id="vmcb-clean-bits"><span class="me-2">VMCB Clean Bits</span><a href="#vmcb-clean-bits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><blockquote><p>该功能在amd spec <code class="language-plaintext highlighter-rouge">15.15 VMCB State Caching</code>章节中有详细讲述</p></blockquote><p>首先该功能在VMCB 新增了 <code class="language-plaintext highlighter-rouge">VMCB Clean field</code>(VMCB offset 0C0h, bit 31:0), 这些bit决定了在<code class="language-plaintext highlighter-rouge">VMRUN</code>时，需要load哪些register. 每个bit可能代表某个或 某组寄存器。该bit设置为0时，需要处理器去load VMCB到cache。 但是这些bit是hint, 因此processor可能会忽略掉厚谢被设置为1的bits，无条件 的从VMCB 中load。另外，当clear bits 设置为0时，总是需要load。</p><p>所以这样就需要vmm判断，在上次 <code class="language-plaintext highlighter-rouge">#VMEXIT</code>到本次<code class="language-plaintext highlighter-rouge">VMRUN</code>之间，有哪些字段改变了. 从而使用<code class="language-plaintext highlighter-rouge">VMCB clean field</code>完成高效的guest/host切换。</p><p>有一些场景需要VMCB clear field都被设置为0, 如下:</p><ul><li>该guest第一次 run<li>guest 被切到另一个cpu上运行<li>hypervisor将 guest VMCB 切到另一个物理地址</ul><p>上面提到过，VMCB cache时根据VMCB的physical address 作为tag去match. 当CPU 发现<code class="language-plaintext highlighter-rouge">VMRUN</code>指定的 VMCB physical address 和 cache中所有的 条目都不匹配时， 会将VMCB clean field 都当作zero.</p><p>VMCB Clean field 具体字段如下:</p><p><img src="pic/VMCB_CLEAN_FIELD.png" alt="VMCB_CLEAN_FIELD" /></p><h5 id="vmload-vmclean"><span class="me-2">VMLOAD, VMCLEAN</span><a href="#vmload-vmclean" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>在<code class="language-plaintext highlighter-rouge">VMRUN</code>包括<code class="language-plaintext highlighter-rouge">#VMEXIT</code>过程中，即使<code class="language-plaintext highlighter-rouge">VMCB Clean Bits</code>都设置为0, cpu也不会 将所有的字段全部load/save, 需要通过额外的指令</p><ul><li>VMLOAD<li>VMSAVE</ul><p>这些字段包括:</p><ul><li>FS, GS, TR, LDTR (including all hidden state)<li>KernelGsBase<li>STAR, LSTAR, CSTAR, SFMASK<li>SYSENTER_CS, SYSENTER_ESP, SYSENTER_EIP</ul><p>这样做的目的是，为了快速的完成guest和host的切换, 来处理一些简单的event, 虽然在实际的KVM代码中，并没有这样做。</p><blockquote class="prompt-info"><p>NOTE</p><p>可以参照SVM的代码, <code class="language-plaintext highlighter-rouge">svm_vcpu_enter_exit</code>中关于vmload和vmsave 指令的使用.</p><p>kvm选择在<code class="language-plaintext highlighter-rouge">VMRUN</code>之前，无条件的执行<code class="language-plaintext highlighter-rouge">VMLOAD guest vmcb</code>，在 <code class="language-plaintext highlighter-rouge">#VMEXIT</code>时，<code class="language-plaintext highlighter-rouge">VMSAVE guest vmcb</code>, <code class="language-plaintext highlighter-rouge">VMLOAD host save area</code><sup>2</sup></p><p>但是手册中并未找到关于<code class="language-plaintext highlighter-rouge">MSR_VM_HSAVE_PA</code>指向的<code class="language-plaintext highlighter-rouge">host state</code> 的格式。所以, 这里猜测<code class="language-plaintext highlighter-rouge">host state</code>格式和<code class="language-plaintext highlighter-rouge">vmcb</code>相同.</p></blockquote><h3 id="intercept"><span class="me-2">intercept</span><a href="#intercept" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>关于cpu虚拟化中，比重最大的部分，就是intercept。host通过 intercept guest中 的敏感行为，trap到host，然后由vmm进行emulate后，再次进入guest。</p><p>intercept operation主要分为两类:</p><ul><li>Exception intercept:<li>instruction intercept:</ul><p>当发生了intercept时，需要将VMEXIT的reasion，还有一些其他的信息 传递到host, 这些信息被写在:</p><ul><li>EXITCODE: intercept的原因<li>EXITINTINFO: 当guest想要使用 IDT deliver interrupt or exception 时发生了intercept，这时需要有一个地方保存着该信息， 以便处理完该event之后，再次向guest注入 interrupt/exception<li>EXITINFO1, EXITINFO2: 提供了某些intercept的额外信息</ul><p>intercept就意味着需要保存guest state，并切换到host state，那该从哪个点保存 guest state呢?</p><p>这个和host上触发exception or interrupt的需求是一样的，都需要保存一个上下文 切换到另一个上下文, 而host上触发excp/intr 是发生在指令边界处. (在 <a href="#interrupt-and-exception-context-switch">interrupt and exception context switch</a> 章节中介绍了host触发excp/intr的逻辑)</p><p>而 intercept 的逻辑也是这样，也是在指令边际处来切换. 但是其和host 上切换逻辑 不同的是:</p><div class="table-wrapper"><table><thead><tr><th>不同点<th>host<th>guest intercept<tbody><tr><td>是否切换<td>根据当前cpu的状态<td>结合cpu状态以及vmcb control field<tr><td>切换信息量<td>fewer register and non-visible state<td>more register and non-visible state<tr><td>切换信息方式<td>stack-&gt;cpu<td>cache – vmcb – host state</table></div><p>所以综合来看，intercept的整体要复杂, 其代价更大, 所以现在虚拟化主要的优化方式， 就是在硬件中emulate，减少vmm intercept.</p><p>关于intercept的细节有很多。不同的intercept event的触发条件，相关control field， 以及EXITCODE/EXITINFO 均不同，我们不再这里描述。</p><h2 id="memory"><span class="me-2">memory</span><a href="#memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>内存虚拟化我们这里主要关注两部分</p><ul><li>nested page Table<li>TLB</ul><h2 id="interrupt"><span class="me-2">interrupt</span><a href="#interrupt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="background"><span class="me-2">background</span><a href="#background" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这里的interrupt虚拟化，囊括了异常和中断，其中异常的处理要简单些，我们来比较下:</p><div class="table-wrapper"><table><thead><tr><th>中断<th>异常<tbody><tr><td>中断的产生源是可能是software，也可能是hardware<td>异常产生源是cpu<tr><td>中断处理，需要cpu和apic的配合<td>异常完全是cpu自己的逻辑<tr><td>cpu需要判断当前的状态<br />来决定是处理中断还是pending中断<td>异常一旦发生，就需要立即处理<tr><td>在一个中断将要被处理时，<br />还有其他pending的中断, <br />这就意味着，硬件需要根据配置<br />来将多个中断连续处理<td>当异常被处理之前，不会有pending的异常</table></div><p>从上面来看，中断处理涉及的组件更多，处理细节也更复杂. 所以针对中断优化要更 多一些。</p><p>在介绍SVM的中断虚拟化之前，我们以比较复杂的中断为例，看看硬件处理中断需要完 成哪些步骤:</p><p><img src="./pic/hardware_handle_interrupt.svg" alt="hardware handle interrupt" /></p><ol><li>IO Device 将中断发送到中断控制器<li>中断控制器和CPU进行交互(可屏蔽中断的处理逻辑), 根据配置依次向cpu deliver 中断<li>CPU侧会根据自己的状态，在某些时刻接收中断<li>接收中断后, cpu根据IDT完成中断的处理。</ol><p>我们来设想下，如果我们要将hardware的中断直接注入到guest中(终极目标:完全bypas vmm)，那就意味着，中断处理链上的所有组件都要被虚拟化.</p><p>我们接下来看下, hardware emulate 了哪些部分，是怎么emulate的。</p><h3 id="overflow-1"><span class="me-2">overflow</span><a href="#overflow-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了能够给guest注入中断/异常，SVM支持event injection 机制(这里的event是对interrupt 和exception的统称)。可以让cpu在执行VMRUN后，在进入guest之前，由硬件触发对event的 处理流程（例如根据IDT进行上下文切换). 这样就避免了对 VMM 进行纯软件层面的模拟，大大 减少了复杂度.</p><p>而为了进一步优化中断的处理, SVM 先后引入了:</p><ul><li>virtual interrupt: 引入虚拟中断, 在guest状态下引入对虚拟中断的评估逻辑。<li>AVIC: 引入对apic的虚拟化, 引入apic虚拟化后，大大增加了guest中处理中断的 能力。可以尽量避免vmm参与virtual interrupt emulate.</ul><h3 id="event-injection"><span class="me-2">event injection</span><a href="#event-injection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们先来看下event inject的实现:</p><p>event injection 具体实现是在VMCB中引入 <font color="red"><strong>`EVENTINJ`</strong></font> 字段, VMM可以设置该字段的某些field，来完成event inject. 在guest 代码执行之前，插入了中断 代码的执行。</p><p>实现注入在guest来看是透明的, 正常发生的。但是有一些例外:</p><ul><li><p>Inject event 接受 intercept check. (但是如果在delivery 该inject event时，触发了 第二个异常, 这个异常受限于exception intercept)</p><blockquote><p>也就是说，当前VMCB中配置了 intercept #PF，如果本次注入的是#PF, 本次注入将不会被 intercept, 但是如果 #PF 的IDT handler配置的有问题，则会产生#GP<sup>待考证</sup> 异常, 该异常可能会被intercept</p></blockquote><li><p>injected NMI 将不会阻塞未来的 NMIs delivery</p><blockquote><p>该限制是为了防止guest可以block host的NMI delivery</p></blockquote><li><p>如果VMM注入了一个guest mode可能发生的 event(e.g.,在guest位于64-bit mode 时注入#BR), 该event inject将会fail，并且guest state 将不会发生改变。本次VMRUN 也会立即退出， error code为<code class="language-plaintext highlighter-rouge">VMEXIT_INVALID</code></p><li><p>使用vector 3 /4 来injecting exception(Type=3) 就像使用INT3 INTO 指令发起trap一样， 处理器需要在dispatch to handler 之前，检查IDT 中的 DPL</p><li><p>software interrupt 将不会在不支持<code class="language-plaintext highlighter-rouge">NextRIP</code>字段的被正确注入。(CPUID Fn8000_000A_EDX[NRIPS] = 1) VMM应该在<code class="language-plaintext highlighter-rouge">NextRIP</code>不支持的情况下，模拟对software interrupt 的event injection.</p><li> <font color="lightgray">ICEBP TODO</font></ul><p><code class="language-plaintext highlighter-rouge">EVENTINJ</code> 字段:</p><p><img src="pic/EVENTINJ_field.png" alt="EVENTINJ_field" /></p><ul><li><strong><em>VECTOR</em></strong>: event IDT vector, 如果 <strong><em>TYPE</em></strong> 是2, 则忽略该字段(因为NMI是固定的vector)<li><p><strong><em>TYPE</em></strong>: 指定exception或者interrupt的类型. 支持的类型如下:</p><div class="table-wrapper"><table><thead><tr><th>value<th>Type<tbody><tr><td>0<td>INTR(external or virtual interrupt)<tr><td>2<td>NMI<tr><td>3<td>Exception<tr><td>4<td>software interrupt</table></div><li><strong><em>EV</em></strong> (error code valid): 如果为1，则需要将error code push到stack上。<li><strong><em>ERRORCODE</em></strong>: ^^<li><strong><em>V</em></strong>(vaild): 表明该event是否要inject到guest.</ul><p>如果<code class="language-plaintext highlighter-rouge">EVENTINJ</code>配置的有问题, VMRUN 则会以error code <code class="language-plaintext highlighter-rouge">VMEXIT_INVALID</code> 退出， 例如下面配置:</p><ul><li>TYPE设置了除上面展示的其他的值<li>指定TYPE=3(exception), 但是该vector不可能是expception(例如vector 2, 是NMI)</ul><font color="red" size="5"><strong>总结</strong></font><p>event inject 只是将interrupt delivery by IDT的逻辑虚拟化到硬件了. VMM可以只注入 一个vector，硬件自动完成，对这个vector的后续处理.</p><font color="blue"><strong>SVM TODO</strong></font><p>event inject 机制这对于异常来说这个机制已经足够了, 注入异常流程大概是:</p><p><img src="./pic/inject_exception.svg" alt="inject exception" /></p><p>通过上面来看注入异常的出发点，是guest执行了某些指令, 因为某些原因<code class="language-plaintext highlighter-rouge">#VMEXIT</code>, host intercept后, 会来判断该条指令的emulate 需不需要inject exception，如果需要 则inject exception. 这套流程，完全契合inject exception，而且很难找出优化的空间. 因为其是完全串行，sync的处理流程。</p><blockquote class="prompt-tips"><p>NOTE</p><p>其实我们从另一个角度来思考，虽然异常注入的流程不好再优化，那其实可以优化异常 产生, 也就是host可以更好的从硬件层面更好的emulate guest指令的执行环境, 使其 更少的vmexit。（例如NPT, 引入npt后，大大减少了#PF异常的产生). 但这部分不是 中断虚拟化的范畴。（当然，本身也没有那么严格的界限，但是为了避免混乱, 我们这 里放到 CPU虚拟化的章节中介绍)</p></blockquote><p>而对于中断而言，event injection 完成的是整个链条中哪部分处理呢?</p><p><img src="./pic/event_inject.svg" alt="event inject" /></p><p>从上图来看，event inject主要完成CPU 接收events(interrupt or expection)之后的一些流程, 即<code class="language-plaintext highlighter-rouge">handle interrupt vector</code>(也就是主要完成从当前guest上下文-&gt;中断上下文切换).</p><p>所以中断而言，离终极目标还有很长一段距离。</p><h3 id="virtual-interrupt"><span class="me-2">virtual interrupt</span><a href="#virtual-interrupt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>virtual interrupt是对event inject的进一步升级, 在guest中执行中断评估逻辑, guest有能力 在 指令边界处识别并处理中断(virtual), 这就意味着，我们需要虚拟化出一套可以用于虚拟 中断执行的资源。我们先来看cpu这边关于物理中断准备了哪些资源:</p><p><img src="./pic/handle_interrupt_hardware_support.svg" alt="handle interrupt hardware support" /></p><ul><li><p><strong><em>CR8/TPR</em></strong>: 用来指定当前cpu可以处理的最低中断优先级, 如果pending的中断没有TPR大， CPU不处理该中断</p><blockquote><p>CR8虽然是CPU的寄存器, 但是最终映射于LAPIC的CR8, 所以其中断是否向CPU发送， 需要首先走LAPIC的中断评估逻辑。不过为了方便介绍下面的章节，我们暂将CR8 作用于CPU 的处理流程里。</p></blockquote><li><p><strong><em>RFLAGS.IF</em></strong>: CPU 侧的中断屏蔽位，用来指示当前CPU要不要阻塞apic pending 的中断（也就是要不要 回应/ack lapic).</p><li><p><strong>interrupt shadows</strong>: interrupt shadows – a single-instruction windows during which interrupts are not recognized. 例如: STI 指令（开中断）的下一条指令， 仍然是不接收中断的。</p></ul><p>SVM 新增了 virtual interrupt 运行的资源，用于只处理virtual interrupt，而不影响 phyiscal interrupt, 如下图所示:</p><p><img src="./pic/virtual_interrupt_env.svg" alt="virtual_interrupt_env" /></p><blockquote><p>NOTE</p><p>AMD spec 中没有提到 vRFLAGS.IF,</p></blockquote><p>除了增加了用于virtual interrupt处理的资源，还增加了用于配置virtual interrupt的 VMCB 字段以及其他字段.</p><h4 id="v_intr_masking"><span class="me-2">V_INTR_MASKING</span><a href="#v_intr_masking" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>为了防止guest block INTR(physical interrupt), SVM 提供了一个VMCB control bit: V_INTR_MASKING, 这个control bit控制guest EFLAGS.IF和 TPR/CR8 的作用范围:</p><ul><li>1: 作用于 virtual interrupt<li>0: 作用于virtual interrupt and physical interrupt</ul><p>分别来看下, 其具体的作用者:</p><h4 id="eflagsif"><span class="me-2">EFLAGS.IF</span><a href="#eflagsif" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>if V_INTR_MASKING == 1:<ul><li>The host EFLAGS.IF at the time of the VMRUN is saved and controls physical interrupts while the guest is running.<li>The guest value of EFLAGS.IF controls virtual interrupts only.</ul><li>else:<ul><li>EFLAGS.IF control VINTR and INTR</ul></ul><h4 id="cr8tpr"><span class="me-2">CR8/TPR</span><a href="#cr8tpr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>svm 新增了 virtual TPR register – VTPR, 在VMRUN时，从VMCB load，并且在#VMEXIT时，writeback to VMCB, APIC TPR 仅控制 physical interrupt，V_TPR 仅控制 virtual interrupt</p><ul><li>if V_INTR_MASKING == 1:<ul><li>Writes to CR8 affect only the V_TPR register.<li>Reads from CR8 return V_TPR.</ul><li>else:<ul><li>Writes to CR8 affect both the APIC’s TPR and the V_TPR register.<li>Reads from CR8 operate as they would without SVM.</ul></ul><p>上面所说的TPR virtualization 仅作用于通过访问CR8触发。但是在32-bit mode中, 没有CR8, 软件只能通过访问TPR，访问TPR只能使用传统MMIO的方式 (xapic), vmm需要做一些emulate处理，大致流程如下:</p><ol><li>VMM 不映射 guest 的 APIC page address<li>guest 访问该区域将产生#PF intercept<li>VMM根据这个物理地址来确定，该地址属于apic，并且是TPR的offset， 执行相关emulate代码</ol><p>为了提高 32 位模式下 TPR 访问的效率，SVM 通过一种 MOV TO/FROM CR8 的替代编码（即带有 LOCK 前缀的 MOV TO/FROM CR0）使 32 位代码可以使用 CR8。为了实现更好的性能，应该修改 32 位客户机以使用这种访问方法, 而不是使用内存映射的 TPR。</p><p>即使在 EFER.SVME 中禁用 SVM，这些 MOV TO/FROM CR8 指令的替代编码仍然 可用。它们在 64 位和 32 位模式下均可使用。</p><blockquote class="prompt-info"><p>INTERESTING!!!</p></blockquote><h4 id="injecting-virtual-interrupt"><span class="me-2">injecting virtual interrupt</span><a href="#injecting-virtual-interrupt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>virtual interrupt 允许host将一个interrupt(#INTR)传递给guest. 当运行在 guest中时，会执行和host一样的中断评估逻辑， 例如中断是否taken受(EFLAGS.IF 以及 vTPR值的影响). 所以virtual interrupt的引入，实际上是在每次指令的边界， 添加了关于virtual interrupt的处理逻辑。</p><p>inject细节如下:</p><ul><li><p>inject 流程</p><p>新增了三个用于存储virtual interrupt的字段:</p><ul><li><strong><em>VIRQ</em></strong> : 指示是否有VINTR需要注入<li><strong><em>V_INTR_PRIO</em></strong> : priority of VINTR<li><strong><em>V_INTR_VECTOR</em></strong> : vector of VINTR</ul><li><p>taken 条件:</p><p>如果下面条件满足, 处理器将taken virtual INTR interrupt:</p><ul><li>if V_IRQ == 1 &amp;&amp; V_INTR_PRIO &gt; V_TPR <strong>and</strong><li>if EFLAGS.IF == 1 <strong>and</strong><li>if GIF == 1 <strong>and</strong><li>if the processor not in an interrupt shadow</ul><li><p>VINTR vs INTR:</p><p>所以通过上面来看VINTR和INTR 在处理上的区别很小, 后者需要INTACK 来获取中断信息，而前者从V_INTR_VECTOR 中获取</p><li><p>external handle on VMEXIT:</p><ul><li><p>上面提到只有在合适的时机，virtual interrupt 才会被taken，在处理器 taken后，dispatch virtual interrupt时（through IDT), V_IRQ 在检查 intercept of virtual interrupt 之后，并在访问 IDT（中断描述符表）之前， V_IRQ 被清除。</p><li>在#VMEXIT时，会将V_IRQ writeback to VMCB, 允许VMM 来跟踪该virtual interrupt 有没有 taken.<li>另外在#VMEXIT时，处理器会clear到CPU缓存中的 V_IRQ 和 V_INTR_MASKING, 所以virtual interrupt不会在VMM中pending</ul><li><p>other</p><ul><li>在guest运行时，VMM可以通过使能 INTR intercept 来 intercept INTR<li><p>physical interrupt的优先级永远高:</p><p>Physical interrupts take priority over virtual interrupts, whether they are taken directly or through a <code class="language-plaintext highlighter-rouge">#VMEXIT</code>.</p><li><p>V_IGN_TPR可以控制当前pending的virtual interrupt不受 TPR 影响:</p><p>V_IGN_TPR field in the VMCB can be set to indicate that the currently pending virtual interrupt is not subject to masking by TPR. The priority comparison against V_TPR is omitted in this case. This mechanism can be used to inject ExtINT-type interrupts into the guest.</p></ul></ul><p>上面提到 <strong><em>GIF</em></strong> :</p><p>global interrupt (GIF) 用来控制 <strong><em>interrupt and other event</em></strong> 是否可以被当前处理器 taken。<strong><em>STGI</em></strong> 和 <strong><em>CLGI</em></strong> 指令用来set clear该bit.</p><p>下面时GIF取值对于event taken的影响:</p><p><img src="pic/GIF_impact.png" alt="GIF_impact" /></p><font color="red" size="5"><strong>总结</strong></font><p>:</p><p>离终极目标，满血版中断虚拟化又进了一步。现在在guest中增加了中断的评估 逻辑，使得guest可以去处理自己的中断（VINTR)。并且处理方式很像物理中断， 中断评估逻辑可以发生在guest的几乎任何指令边界处。<strong><em>这个优化很关键，相当于 打开了一个枷锁, 允许中断注入和中断taken异步发生</em></strong></p><p>我们较event inject来比较下:</p><div class="table-wrapper"><table><thead><tr><th>~<th>event inject<th>virtual interrupt<tbody><tr><td>when to delivery<td>end of VMRUN<td>like INTR, guest every inst boundary&lt;/br&gt;Meet the conditions for being<br />taken<tr><td>conditions of taken<td>NO CONDITIONS<td>like INTR, &lt;/br&gt;need check EFLAGS.IF TPR, &lt;/br&gt;interrupt shadow…</table></div><blockquote class="prompt-tip"><p>Q: 像INTR有什么好处?</p><p>A: 因为这是vm的需求，其总要求运行起来要<font size="5">像</font> 物理机一样。 所以硬件如果模拟的不像，就需要软件来模拟的像一些.</p><p>举个例子:</p><p>如果在VMRUN之前，如果vcpu处于interrupt shadow, event inject此时就不能注入 event，vmm还需要做好额外的intercept，尽量在intercept shadow刚关闭时，立即 退出guest，来inject event，来减小interrupt 延迟。</p><p>但是使用, virtual interrupt 考虑的就少很多了，不管啥样，直接在VMRUN之前注入 virtual interrupt， guest cpu 会自己判断interrupt shadow啥时候关闭，从而 更高效的 inject.</p></blockquote><p>那virtual interrupt 完成了，中断处理链条中的哪些部分呢?</p><p><img src="./pic/virtual_interrupt_handle.svg" alt="virtual_interrupt_handle" /></p><h3 id="advanced-virtual-interrupt-controller"><span class="me-2">Advanced Virtual Interrupt Controller</span><a href="#advanced-virtual-interrupt-controller" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>AVIC 是AMD虚拟化中的重要的一个增强。其为guest的每个vcpu 都提供了和LAPIC兼容的副本。基于这个副本，我们可以对apic 中的很多功能做虚拟化。</p><h4 id="introduction"><span class="me-2">introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h2 id="参考链接"><span class="me-2">参考链接</span><a href="#参考链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>amd spec<li><a href="https://patchwork.kernel.org/project/kvm/patch/20201210174814.1122585-1-michael.roth@amd.com/#23839851">KVM: SVM: use vmsave/vmload for saving/restoring additional host state</a></ol><h2 id="附录"><span class="me-2">附录</span><a href="#附录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="interrupt-and-exception-context-switch"><span class="me-2">interrupt and exception context switch</span><a href="#interrupt-and-exception-context-switch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>interrupt, fault exception 和trap exception 其上下文切换都是发生在指令边界处， 这样做的好处，是明确规定了上下文切换的点，让指令执行原子化，方便软件进行处理.</p><p>但是三者的机制不太相同。分别来看:</p><h4 id="interrupt-1"><span class="me-2">interrupt</span><a href="#interrupt-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img src="./pic/interrupt_context_switch.svg" alt="interrupt_context_switch.svg" /></p><p>当APIC发出一个interrupt后(我们这里以maskable interrupt为例), cpu会在指令边际处检查 是否有pending的中断, 会根据当前的cpu状态评估(interrupt window)，要不要接收该interrupt, 如果接收, 就向apic 要详细的中断信息，然后通过IDT进行上下文切换（当然不仅仅是IDT，还有 其他desc中的信息，这里不赘述)</p><h4 id="fault"><span class="me-2">fault</span><a href="#fault" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img src="./pic/fault_context_switch.svg" alt="fault_context_switch.svg" /></p><p>fault一般是指令执行过程中，发现该指令执行的有问题，例如，<code class="language-plaintext highlighter-rouge">#PF</code>是在寻址过程中，发现 page table walk 出现了问题，但是此时该指令还未执行完成，所以需要将cpu恢复到该指令 执行之前的上下文，然后，deliver一个exception</p><h4 id="trap"><span class="me-2">trap</span><a href="#trap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img src="./pic/trap_context_switch.svg" alt="trap_context_switch" /></p><p>trap的处理十分简单，如上图所示，trap的触发是通过trap指令，该指令的作用就是在该指令 之后的位置，挖一个坑，该坑通往处理该trap的异常处理程序。当异常处理程序返回时，执行 trap指令的下一条指令。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/amd-spec/">amd_spec</a>, <a href="/categories/svm/">svm</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/svm/" class="post-tag no-text-decoration" >svm</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=svm%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fsvm-overflow%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=svm%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fsvm-overflow%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fsvm-overflow%2F&text=svm%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/sched/">schedule: overflow</a><li class="text-truncate lh-lg"> <a href="/posts/learn-CCA/">[arm] learn CCA</a><li class="text-truncate lh-lg"> <a href="/posts/RME-spec/">[arm] RME(spec)</a><li class="text-truncate lh-lg"> <a href="/posts/learn-RME/">[arm] learn RME</a><li class="text-truncate lh-lg"> <a href="/posts/virtcca-paper/">[arm] virtCCA</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/amd-sev-api/" class="btn btn-outline-primary" aria-label="Older" ><p>sev api</p></a> <a href="/posts/memory-consistency-motivation-and-sequential-consistency/" class="btn btn-outline-primary" aria-label="Newer" ><p>Memory Consistency Motivation And Sequential Consistency</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
