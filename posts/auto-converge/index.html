<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="auto-converge" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="# 简介" /><meta property="og:description" content="# 简介" /><link rel="canonical" href="/posts/auto-converge/" /><meta property="og:url" content="/posts/auto-converge/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-12T23:20:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="auto-converge" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2024-11-12T23:20:00+08:00","datePublished":"2024-11-12T23:20:00+08:00","description":"# 简介","headline":"auto-converge","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/auto-converge/"},"url":"/posts/auto-converge/"}</script><title>auto-converge | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>auto-converge</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>auto-converge</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1731424800" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 12, 2024 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="4900 words" > <em>27 min</em> read</span></div></div></div></header><div class="content"> <script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"> </script><p>#</p><h2 id="简介"><span class="me-2">简介</span><a href="#简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在大型机器，并且系统负载高时热迁移，工作负载往往比热迁移速度更快，从而导致 live migration无法 converge.</p><p>这个往往受限于bandwidth, 虽然现在网卡的带宽越来越高。但是虚拟机的核心数量 以及cpu主频，内存带宽也在逐渐增大。</p><p><code class="language-plaintext highlighter-rouge">Chegu Vinod</code> 在 2013 年提出了 auto-converge, （但是的场景即使使用了10Gig NICs也仍然NOT converge). 所以，他提出了该方案，来限制脏页产生速度，也就是 简单粗暴的限制vcpu的”频率”, (让vcpu线程sleep).</p><p>我们来看下该patch 的 commit message:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre>Busy enterprise workloads hosted on large sized VM's tend to dirty
memory faster than the transfer rate achieved via live guest migration.
Despite some good recent improvements (&amp; using dedicated 10Gig NICs
between hosts) the live migration does NOT converge.

在大型虚拟机上运行的繁忙企业级工作负载通常会比实时迁移的传输速率更快
地修改内存数据。尽管近期在迁移性能上已有一些改进（包括在主机之间使用
专用的10Gb网卡），实时迁移仍然无法收敛。

If a user chooses to force convergence of their migration via a new
migration capability "auto-converge" then this change will auto-detect
lack of convergence scenario and trigger a slow down of the workload
by explicitly disallowing the VCPUs from spending much time in the VM
context.

如果用户选择通过一个新的迁移功能“auto-converge”来强制迁移收敛，
那么该功能将自动检测到未收敛的情况，并通过显式限制虚拟 CPU 在 
VM 上下文中的执行时间来减缓工作负载。

The migration thread tries to catchup and this eventually leads
to convergence in some "deterministic" amount of time. Yes it does
impact the performance of all the VCPUs but in my observation that
lasts only for a short duration of time. i.e. end up entering
stage 3 (downtime phase) soon after that. No external trigger is
required.

迁移线程会努力追赶同步速度，这最终会在“确定的”时间内实现收敛。
虽然这确实会影响所有虚拟 CPU 的性能，但根据我的观察，这种影响只会
持续较短的时间，即在此之后很快便进入第3阶段（停机阶段）。整个过程
不需要额外的触发。

Thanks to Juan and Paolo for their useful suggestions.
</pre></table></code></div></div><p>我们来分析下具体代码:</p><h2 id="first-patch-代码分析"><span class="me-2">first patch 代码分析</span><a href="#first-patch-代码分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="intro-async_run_on_cpu"><span class="me-2">intro async_run_on_cpu</span><a href="#intro-async_run_on_cpu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>引入该函数的主要目的，是为了让vcpu thread sleep 完成之前，migration thread 不必wait（打得就是频率差，否则就没有意义了)</p><p>原commit message:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Introduce an asynchronous version of run_on_cpu() i.e. the caller
doesn't have to block till the call back routine finishes execution
on the target vcpu.
</pre></table></code></div></div><p>代码如下:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">async_run_on_cpu</span><span class="p">(</span><span class="n">CPUState</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">qemu_work_item</span> <span class="o">*</span><span class="n">wi</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">qemu_cpu_is_self</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">wi</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">qemu_work_item</span><span class="p">));</span>
    <span class="n">wi</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">wi</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">wi</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">queued_work_first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">queued_work_first</span> <span class="o">=</span> <span class="n">wi</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">queued_work_last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">wi</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">queued_work_last</span> <span class="o">=</span> <span class="n">wi</span><span class="p">;</span>
    <span class="n">wi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">wi</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="n">qemu_cpu_kick</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="intro-auto-converge-param--cap"><span class="me-2">intro auto-converge param &amp;&amp; cap</span><a href="#intro-auto-converge-param--cap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="gh">diff --git a/migration.c b/migration.c
index 058f9e6..d0759c1 100644
</span><span class="gd">--- a/migration.c
</span><span class="gi">+++ b/migration.c
</span><span class="p">@@ -473,6 +473,15 @@</span> void qmp_migrate_set_downtime(double value, Error **errp)
     max_downtime = (uint64_t)value;
 }
 
<span class="gi">+bool migrate_auto_converge(void)
+{
+    MigrationState *s;
+
+    s = migrate_get_current();
+
+    return s-&gt;enabled_capabilities[MIGRATION_CAPABILITY_AUTO_CONVERGE];
+}
+
</span> int migrate_use_xbzrle(void)
 {
     MigrationState *s;
<span class="gh">diff --git a/qapi-schema.json b/qapi-schema.json
index a80ee40..c019fec 100644
</span><span class="gd">--- a/qapi-schema.json
</span><span class="gi">+++ b/qapi-schema.json
</span><span class="p">@@ -605,10 +605,13 @@</span>
 #          This feature allows us to minimize migration traffic for certain work
 #          loads, by sending compressed difference of the pages
 #
<span class="gi">+# @auto-converge: If enabled, QEMU will automatically throttle down the guest
+#          to speed up convergence of RAM migration. (since 1.6)
+#
</span> # Since: 1.2
 ##
 { 'enum': 'MigrationCapability',
<span class="gd">-  'data': ['xbzrle'] }
</span><span class="gi">+  'data': ['xbzrle', 'auto-converge'] }
</span></pre></table></code></div></div><h3 id="calc-if-dirty-throttle-or-not"><span class="me-2">calc if dirty throttle or not</span><a href="#calc-if-dirty-throttle-or-not" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="p">@@ -378,8 +381,14 @@</span> static void migration_bitmap_sync(void)
<span class="gi">+    static int64_t bytes_xfer_prev;
</span>     ...
<span class="gi">+    int64_t bytes_xfer_now;
+
+    if (!bytes_xfer_prev) {
+        bytes_xfer_prev = ram_bytes_transferred();
+    }
</span><span class="err">
</span><span class="p">@@ -404,6 +413,23 @@</span> static void migration_bitmap_sync(void)
 
     /* more than 1 second = 1000 millisecons */
     if (end_time &gt; start_time + 1000) {
<span class="gi">+        if (migrate_auto_converge()) {
+            /* The following detection logic can be refined later. For now:
+               Check to see if the dirtied bytes is 50% more than the approx.
+               amount of bytes that just got transferred since the last time we
+               were in this routine. If that happens &gt;N times (for now N==4)
+               we turn on the throttle down logic */
</span>             
           /* 后续可以进一步优化以下检测逻辑。当前逻辑如下：
              检查脏页字节数是否比上次进入该函数以来传输的字节数大50%。
              如果这种情况发生超过 N 次（目前 N==4），则开启降速逻辑 */
             //==(1)==
<span class="gi">+            bytes_xfer_now = ram_bytes_transferred();
+            if (s-&gt;dirty_pages_rate &amp;&amp;
+               (num_dirty_pages_period * TARGET_PAGE_SIZE &gt;
+                   (bytes_xfer_now - bytes_xfer_prev)/2) &amp;&amp;
</span>                //==(2)==
<span class="gi">+               (dirty_rate_high_cnt++ &gt; 4)) {
+                    trace_migration_throttle();
+                    mig_throttle_on = true;
+                    dirty_rate_high_cnt = 0;
+             }
+             bytes_xfer_prev = bytes_xfer_now;
+        } else {
</span>              //==(3)==
<span class="gi">+             mig_throttle_on = false;
+        }
</span></pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">migration_bitmap_sync</code>后，还是按照之前的逻辑，本次和上次差距1s，则认为 migration线程有压力。然后做了一个简单的算法:</p><p>先简单介绍下其中变量含义:</p><ul><li>bytes_xfer_prev: sync之前, 要传输的memory 数量<li>bytes_xfer_now: sync 之后, 要传输的memory 数量<li>num_dirty_pages_period: 本次和上次相比，dirty page的变化量<li>dirty_rate_high_cnt: 进入dirty rate high if分支的次数<li>mig_throttle_on: 表示开启<code class="language-plaintext highlighter-rouge">mig_throttle_on</code></ul><p>所以, 该算法比较简单，触发条件有两个</p><ol><li><p>(dirty_page_now - dirty_page_last) / (byte_xfer_now) - (byte_xfer_prev) &gt; 0.5 则认为需要限制脏页产生速率。</p><p>该公式分子部分，相当于脏页产生速率，而分母部分相当于 migration thread页面传输速率。 值越大，说明，脏页产生速率相对越快。</p><li><p>达到1中的条件5次。</p><p>达到条件2后, 将<code class="language-plaintext highlighter-rouge">dirty_rate_high_cnt</code> 设置为0。所以下次如果再想触发<code class="language-plaintext highlighter-rouge">mig_throttle</code>, 还需要再次达到条件2.</p><li><p>一旦开启了auto_converge, 就无法将 <code class="language-plaintext highlighter-rouge">mig_throttle_on</code> 设置为false</p></ol><h3 id="notify-vcpu-down-ratio"><span class="me-2">notify vcpu down ratio</span><a href="#notify-vcpu-down-ratio" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="p">@@ -628,6 +656,7 @@</span> static int ram_save_iterate(QEMUFile *f, void *opaque)
         }
         total_sent += bytes_sent;
         acct_info.iterations++;
<span class="gi">+        check_guest_throttling();
</span>         /* we want to check in the 1st loop, just in case it was the 1st time
            and we had to sync the dirty bitmap.
            qemu_get_clock_ns() is a bit expensive, so we only check each some
<span class="err">
</span><span class="gi">+static void check_guest_throttling(void)
+{
+    static int64_t t0;
+    int64_t        t1;
+
+    if (!mig_throttle_on) {
+        return;
+    }
+
+    if (!t0)  {
+        t0 = qemu_get_clock_ns(rt_clock);
+        return;
+    }
+
+    t1 = qemu_get_clock_ns(rt_clock);
+
+    /* If it has been more than 40 ms since the last time the guest
+     * was throttled then do it again.
+     */
</span>     //==(1)==
<span class="gi">+    if (40 &lt; (t1-t0)/1000000) {
+        mig_throttle_guest_down();
+        t0 = t1;
+    }
+}
</span></pre></table></code></div></div><p>在在每一轮的<code class="language-plaintext highlighter-rouge">ram_save_iterate</code>中，查看是否需要notify vcpu，但是这里 notify 也有一个频率为40ms, 我们下面看看是如何notify vcpu，以及 vcpu那边如何down ratio.</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="gi">+/* Stub function that's gets run on the vcpu when its brought out of the
+   VM to run inside qemu via async_run_on_cpu()*/
+static void mig_sleep_cpu(void *opq)
+{
+    qemu_mutex_unlock_iothread();
</span>     //==(1)==
<span class="gi">+    g_usleep(30*1000);
+    qemu_mutex_lock_iothread();
+}
+
+/* To reduce the dirty rate explicitly disallow the VCPUs from spending
+   much time in the VM. The migration thread will try to catchup.
+   Workload will experience a performance drop.
+*/
+static void mig_throttle_cpu_down(CPUState *cpu, void *data)
+{
+    async_run_on_cpu(cpu, mig_sleep_cpu, NULL);
+}
+
+static void mig_throttle_guest_down(void)
+{
+    qemu_mutex_lock_iothread();
+    qemu_for_each_cpu(mig_throttle_cpu_down, NULL);
+    qemu_mutex_unlock_iothread();
+}
</span></pre></table></code></div></div><p>从(1) 中可以看到, 每次sleep 30ms, 上面说了40ms kick 一次vcpu, 那么cpu sleep time和runtime的 占比大概是3:1</p><blockquote><p>======还存在的问题======</p></blockquote><p>这样做似乎太简单粗暴了，是固定频率限制，在某些情况下可能不管用</p><h2 id="dynamic-cpu-throttle"><span class="me-2">dynamic cpu throttle</span><a href="#dynamic-cpu-throttle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">Jason J. Herne</code> 发现了之前的<code class="language-plaintext highlighter-rouge">auto-converge</code>不太好用，因为他是让vcpu下降到一个固定 频率，但是在这个固定的频率下, 迁移的效率还是不够，导致迁移迟迟不能完成。所以， <code class="language-plaintext highlighter-rouge">Jason J. Herne</code>发送了一个mail，并且他想做一个真正”auto”的方式，动态的调整throttle 的力度. 向大家征求意见:</p><p><a href="https://lore.kernel.org/all/54F4D076.3040402@linux.vnet.ibm.com/">mail 地址 – 2015-03-12</a></p><p>其中<code class="language-plaintext highlighter-rouge">Dr. David Alan Gilbert</code>从工程角度, 针对<code class="language-plaintext highlighter-rouge">Jason J. Herne</code>提出的一些问题给 出了建议, 例如针对这些不太容易迁移的虚拟机，可以使用:</p><ul><li>xbzrle<li>post-copy<li>inc max-downtime</ul><p>等等来加速虚拟机迁移。并且对<code class="language-plaintext highlighter-rouge">Jason J. Herne</code>的想法给予肯定。</p><p><code class="language-plaintext highlighter-rouge">Jason J. Herne</code> 编写了该patch。（我们只看下<a href="https://lore.kernel.org/all/1441732357-11861-1-git-send-email-jjherne@linux.vnet.ibm.com/">v7 版本</a>)</p><p>首先看下 commit message:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>This patch set provides a new method for throttling a vcpu and makes use of
said method to dynamically increase cpu throttling during an autoconverge
migration until the migration completes. This method ensures that all
migrations will eventually converge.

&gt; 这个补丁集提供了一种新的限制虚拟 CPU 的方法，并利用该方法在自动收敛迁移过程
&gt; 中动态增加 CPU 限速，直到迁移完成。该方法确保所有迁移最终都能收敛。

The method used here for throttling vcpus is likely not the best. However, I
believe that it is preferable to what is used for autoconverge today.

&gt; 这里用于限制虚拟 CPU 的方法可能不是最好的。然而，我认为它比目前用于自动收敛
&gt; 的方式更为可取。

This work is related to the following discussion:
https://lists.gnu.org/archive/html/qemu-devel/2015-03/msg00287.html
</pre></table></code></div></div><p>该系列patch, 主要分为如下部分:</p><ul><li>重新定义涉及throttle 相关接口<ul><li>active/stop – 开启关闭 throttle<li>set throttle_percentage – 动态调整 throttle 力度<li>periodic tick – 可以更精准的周期性触发 periodic tick, 不再依赖migration thread notify<li>sleep interface – 可以根据 动态调整的 throttle 的值，来sleep.</ul><li>增加两个参数<ul><li>x-cpu-throttle-initial: 初始值<li>x-cpu-throttle-increment: 如果本次限制之后，再次达到了dirty radio 的限制，则一次增加<br /> throttle的值</ul><li>migration_bitmap_sync 处理逻辑(core)<ul><li>dynamic inc</ul><li>增加 thrrole ratio 查询<ul><li>info migrate<li>query-migrate</ul></ul><p>我们这里，只列举下和动态调整<code class="language-plaintext highlighter-rouge">throttle</code>的相关改动</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="gi">+/* Reduce amount of guest cpu execution to hopefully slow down memory writes.
+ * If guest dirty memory rate is reduced below the rate at which we can
+ * transfer pages to the destination then we should be able to complete
+ * migration. Some workloads dirty memory way too fast and will not effectively
+ * converge, even with auto-converge.
+ */
+static void mig_throttle_guest_down(void)
+{
+    MigrationState *s = migrate_get_current();
</span>     //初始值
<span class="gi">+    uint64_t pct_initial =
+            s-&gt;parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INITIAL];
</span>     //每次增加的值
<span class="gi">+    uint64_t pct_icrement =
+            s-&gt;parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INCREMENT];
+
</span>     //如果第一次执行，则设置为初始值
<span class="gi">+    /* We have not started throttling yet. Let's start it. */
+    if (!cpu_throttle_active()) {
+        cpu_throttle_set(pct_initial);
+    } else {
</span>         //说明是第2+次，触发了，则在原来值的基础上加上inc的值
<span class="gi">+        /* Throttling already on, just increase the rate */
+        cpu_throttle_set(cpu_throttle_get_percentage() + pct_icrement);
+    }
+}
</span></pre></table></code></div></div><p>可以看到，上面的patch，通过<code class="language-plaintext highlighter-rouge">cpu_throttle_set()</code>传入了 <code class="language-plaintext highlighter-rouge">current_pct + pct_icrement</code>, 这个值代表的是，睡眠时间所占的比重。</p><p>我们来看下为达到这样的时间比例，QEMU如何实现:</p><p>首先引入了一个时间片的值，该值为10ms</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="gi">+#define CPU_THROTTLE_TIMESLICE_NS 10000000
</span></pre></table></code></div></div><p>该值表示vcpu运行的时间片固定值, 也就是为了避免因为alarm频繁的 vm-exit. 将该值固定下来，然后让睡眠时间根据该值和pct再计算</p><p>定义了一个timer, 使用<code class="language-plaintext highlighter-rouge">QEMU_CLOCK_VIRTUAL_RT</code>, expired function 为<code class="language-plaintext highlighter-rouge">cpu_throttle_timer_tick</code></p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> void cpu_ticks_init(void)
 {
     seqlock_init(&amp;timers_state.vm_clock_seqlock, NULL);
     vmstate_register(NULL, 0, &amp;vmstate_timers, &amp;timers_state);
<span class="gi">+    throttle_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL_RT,
+                                           cpu_throttle_timer_tick, NULL);
</span> }
</pre></table></code></div></div><p>在set 新的throttle时, 会在当前时间上，增加<code class="language-plaintext highlighter-rouge">CPU_THROTTLE_TIMESLICE_NS</code> 设置timer，也就是使其，在下一个时间片上触发timer.</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="gi">+void cpu_throttle_set(int new_throttle_pct)
+{
+    /* Ensure throttle percentage is within valid range */
+    new_throttle_pct = MIN(new_throttle_pct, CPU_THROTTLE_PCT_MAX);
+    new_throttle_pct = MAX(new_throttle_pct, CPU_THROTTLE_PCT_MIN);
+
+    atomic_set(&amp;throttle_percentage, new_throttle_pct);
+
+    timer_mod(throttle_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT) +
+                                       CPU_THROTTLE_TIMESLICE_NS);
+}
</span></pre></table></code></div></div><p>timer 触发时，使用<code class="language-plaintext highlighter-rouge">CPU_THROTTLE_TIMESLICE_NS/(1-pct)</code>, 我们来看下该公式:</p>\[\begin{align} timer\_val \\ =&amp; 总的时间片 \\ =&amp; \frac{vcpu时间片}{vcpu时间比例} \\ =&amp; \frac{CPU\_THROTTLE\_TIMESLICE\_NS}{1-pct} \\ \end{align}\]<p>所以，这里传入的应该是总的时间片.</p><p>我们来看下timer expired callbak</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="gi">+static void cpu_throttle_timer_tick(void *opaque)
+{
+    CPUState *cpu;
+    double pct;
+
+    /* Stop the timer if needed */
+    if (!cpu_throttle_get_percentage()) {
+        return;
+    }
+    CPU_FOREACH(cpu) {
+        if (!atomic_xchg(&amp;cpu-&gt;throttle_thread_scheduled, 1)) {
</span>             //通知各个vcpu睡眠
<span class="gi">+            async_run_on_cpu(cpu, cpu_throttle_thread, cpu);
+        }
+    }
+throttle-trigger-threshold
+    pct = (double)cpu_throttle_get_percentage()/100;
</span>     //这里是再次触发timer的时间, 上面说到`CPU_THROTTLE_TIMESLICE_NS / (1-pct)`
     //是总的时间片，所以包含了vcpu time slice和sleep time slice
<span class="gi">+    timer_mod(throttle_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT) +
+                          
+                          CPU_THROTTLE_TIMESLICE_NS / (1-pct));
+}
</span></pre></table></code></div></div><p>那notify callbak一定是执行sleep了，我们关注下sleep时间:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="gi">+static void cpu_throttle_thread(void *opaque)
+{
+    CPUState *cpu = opaque;
+    double pct;
+    double throttle_ratio;
+    long sleeptime_ns;
+
+    if (!cpu_throttle_get_percentage()) {
+        return;
+    }
+
+    pct = (double)cpu_throttle_get_percentage()/100;
+    throttle_ratio = pct / (1 - pct);
+    sleeptime_ns = (long)(throttle_ratio * CPU_THROTTLE_TIMESLICE_NS);
+
+    qemu_mutex_unlock_iothread();
+    atomic_set(&amp;cpu-&gt;throttle_thread_scheduled, 0);
+    g_usleep(sleeptime_ns / 1000); /* Convert ns to us for usleep call */
+    qemu_mutex_lock_iothread();
+}
</span></pre></table></code></div></div><p>睡眠时间为:</p>\[\begin{align} sleep_ns = &amp; {总的时间片}* (pct) \\ =&amp; \frac{CPU\_THROTTLE\_TIMESLICE\_NS}{1-pct} * {pct} \\ =&amp; \frac{pct}{1-pct} * {CPU\_THROTTLE\_TIMESLICE\_NS} \\ =&amp; {throttle\_ratio} * {CPU\_THROTTLE\_TIMESLICE\_NS} \end{align}\]<hr /><blockquote><p>======还存在的问题======</p></blockquote><p>上面的patch虽然能动态的调整迁移过程中的<code class="language-plaintext highlighter-rouge">throttle</code>, 并且可以灵活的配置 <code class="language-plaintext highlighter-rouge">throttle</code>的初始值和增量, 进入guestdown的条件，是不变的。还是按照 最初的<code class="language-plaintext highlighter-rouge">dirty page inc / xfer inc &gt; 50%</code>, 也就是说达到这个条件后，肯定 会影响虚拟机性能。</p><p>zhukeqian 觉得不妥，想让用户来配置该值, 来确定这个百分比</p><h2 id="configure-throttle-trigger-threshold"><span class="me-2">configure throttle-trigger-threshold</span><a href="#configure-throttle-trigger-threshold" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先来看下commit message:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>Currently, if the bytes_dirty_period is more than the 50% of
bytes_xfer_period, we start or increase throttling.

&gt; 当前，如果 bytes_dirty_period 超过 bytes_xfer_period 的 50%，我
&gt; 们将开始或增加限速。

If we make this percentage higher, then we can tolerate higher
dirty rate during migration, which means less impact on guest.
The side effect of higher percentage is longer migration time.
We can make this parameter configurable to switch between mig-
ration time first or guest performance first.

&gt; 如果我们提高这个百分比，就可以在迁移过程中容忍更高的脏页速率，
&gt; 这意味着对虚拟机的影响会更小。提高百分比的副作用是迁移时间会变
&gt; 长。我们可以将这个参数设置为可配置，以便在迁移时间优先和虚拟机
&gt; 性能优先之间进行切换。

The default value is 50 and valid range is 1 to 100.

&gt; 默认值为 50，有效范围是 1 到 100。
</pre></table></code></div></div><p>目前该配置的默认值是50%，保持和原来一样的值，但是可以调整为<code class="language-plaintext highlighter-rouge">[1,100]</code></p><p>只看下判断是否<code class="language-plaintext highlighter-rouge">throttle</code>的代码改动:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="gi">+static void migration_trigger_throttle(RAMState *rs)
+{
+    MigrationState *s = migrate_get_current();
</span>     //throttle_trigger_threshold新增的调整参数
<span class="gi">+    uint64_t threshold = s-&gt;parameters.throttle_trigger_threshold;
+
+    uint64_t bytes_xfer_period = ram_counters.transferred - rs-&gt;bytes_xfer_prev;
+    uint64_t bytes_dirty_period = rs-&gt;num_dirty_pages_period * TARGET_PAGE_SIZE;
</span>     //按照比例计算bytes_dirty_threshold 
<span class="gi">+    uint64_t bytes_dirty_threshold = bytes_xfer_period * threshold / 100;
+
+    /* During block migration the auto-converge logic incorrectly detects
+     * that ram migration makes no progress. Avoid this by disabling the
+     * throttling logic during the bulk phase of block migration. */
+    if (migrate_auto_converge() &amp;&amp; !blk_mig_bulk_active()) {
+        /* The following detection logic can be refined later. For now:
+           Check to see if the ratio between dirtied bytes and the approx.
+           amount of bytes that just got transferred since the last time
+           we were in this routine reaches the threshold. If that happens
+           twice, start or increase throttling. */
+
</span>         //使用按比例计算后的 bytes_dirty_threshold 值来比较
<span class="gi">+        if ((bytes_dirty_period &gt; bytes_dirty_threshold) &amp;&amp;
+            (++rs-&gt;dirty_rate_high_cnt &gt;= 2)) {
+            trace_migration_throttle();
+            rs-&gt;dirty_rate_high_cnt = 0;
+            mig_throttle_guest_down();
+        }
+    }
+}
</span></pre></table></code></div></div><hr /><blockquote><p>======还存在的问题======</p></blockquote><p>inc throttle 的目前的算法，是在初始值上累加，每次增长的睡眠值在后期的很明显。 我们来看下公式:</p>\[\begin{align} sleep_ns = &amp; {总的时间片}* (pct) \\ =&amp; \frac{CPU\_THROTTLE\_TIMESLICE\_NS}{1-pct} * {pct} \\ =&amp; \frac{pct}{1-pct} * {CPU\_THROTTLE\_TIMESLICE\_NS} \\ \end{align}\]<p>我们来看下</p>\[\begin{align} y = \frac{x}{1-x} \end{align}\]<p>的图像(过于基础 - - )</p><p><img src="./pic/1_frac_1-x.png" alt="Image description" width="30%" /></p><p>是一个指数级增长。该值<code class="language-plaintext highlighter-rouge">* CPU_THROTTLE_TIMESLICE_NS(10ms)</code>， 不过, 由于 <code class="language-plaintext highlighter-rouge">x-cpu-throttle-increment</code>是整型, 所以其最大可以达到</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>99 / 1 * 10ms = 990ms = 0.99s
</pre></table></code></div></div><p>但是不可否认的是，后期的睡眠时间增长非常快。于是<code class="language-plaintext highlighter-rouge">Keqian Zhu</code> 增加了<code class="language-plaintext highlighter-rouge">cpu-throttle-tailslow</code> 参数，让其在后期可以增长的相对平缓。 但是延长迁移时间</p><h2 id="cpu-throttle-tailslow"><span class="me-2">cpu-throttle-tailslow</span><a href="#cpu-throttle-tailslow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>commit message</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>At the tail stage of throttling, the Guest is very sensitive to
CPU percentage while the @cpu-throttle-increment is excessive
usually at tail stage.

&gt; 在限流的尾阶段，虚拟机对 CPU 使用率非常敏感，而此时 
&gt; @cpu-throttle-increment 通常过大。

If this parameter is true, we will compute the ideal CPU percentage
used by the Guest, which may exactly make the dirty rate match the
dirty rate threshold. Then we will choose a smaller throttle increment
between the one specified by @cpu-throttle-increment and the one
generated by ideal CPU percentage.

&gt; 如果该参数为真，我们将计算虚拟机理想的 CPU 使用百分比，使其脏页率
&gt; 正好匹配脏页率阈值。然后，我们将在 @cpu-throttle-increment 和根据
&gt; 理想 CPU 使用率生成的增量之间选择一个较小的限流增量。

Therefore, it is compatible to traditional throttling, meanwhile
the throttle increment won't be excessive at tail stage. This may
make migration time longer, and is disabled by default.

&gt; 因此，这种方法与传统限流兼容，同时在尾阶段限流增量不会过大。这样可能会延
&gt; 长迁移时间，默认情况下是禁用的。
</pre></table></code></div></div><p>来看下如何计算得出一个新的增长量的相关代码:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="gi">+static void mig_throttle_guest_down(uint64_t bytes_dirty_period,
+                                    uint64_t bytes_dirty_threshold)
</span> {
     MigrationState *s = migrate_get_current();
     uint64_t pct_initial = s-&gt;parameters.cpu_throttle_initial;
<span class="gd">-    uint64_t pct_icrement = s-&gt;parameters.cpu_throttle_increment;
</span><span class="gi">+    uint64_t pct_increment = s-&gt;parameters.cpu_throttle_increment;
+    bool pct_tailslow = s-&gt;parameters.cpu_throttle_tailslow;
</span>     int pct_max = s-&gt;parameters.max_cpu_throttle;
<span class="err">
</span><span class="gi">+    uint64_t throttle_now = cpu_throttle_get_percentage();
+    uint64_t cpu_now, cpu_ideal, throttle_inc;
+
</span>     /* We have not started throttling yet. Let's start it. */
     if (!cpu_throttle_active()) {
         cpu_throttle_set(pct_initial);
     } else {
         /* Throttling already on, just increase the rate */
<span class="gd">-        cpu_throttle_set(MIN(cpu_throttle_get_percentage() + pct_icrement,
-                         pct_max));
</span><span class="gi">+        if (!pct_tailslow) {
+            throttle_inc = pct_increment;
+        } else {
+            /* Compute the ideal CPU percentage used by Guest, which may
+             * make the dirty rate match the dirty rate threshold. */
+            cpu_now = 100 - throttle_now;
</span>             //下面解释为什么这样可以得出 cpu_ideal
<span class="gi">+            cpu_ideal = cpu_now * (bytes_dirty_threshold * 1.0 /
+                        bytes_dirty_period);
</span>             //计算cpu运行时间增量。这里和 pct_increment 取最小值
<span class="gi">+            throttle_inc = MIN(cpu_now - cpu_ideal, pct_increment);
+        }
+        cpu_throttle_set(MIN(throttle_now + throttle_inc, pct_max));
</span>     }
 }
</pre></table></code></div></div><p>我们还是先解释下参数:</p><ul><li>bytes_dirty_period: 该period dirty byte数量. (当前值)<li>bytes_dirty_threshold: 该period dirty threshold (目标阈值)</ul><p>我们期望的是，经过调整vcpu ratio, 可以让</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>byte_dirty_period &lt;= bytes_dirty_threshold
</pre></table></code></div></div><p>我们假设，<code class="language-plaintext highlighter-rouge">byte_dirty_period</code>和<code class="language-plaintext highlighter-rouge">cpu_run_time</code>成正比 所以可得: $$ \begin{align}</p><p>byte_dirty_period &amp;= A * byte_dirty_threshold \</p><p>byte_dirty_period &amp;= \frac{cpu_ideal}{cpu_now} * byte_dirty_threshold \</p><p>cpu_ideal &amp;= \frac{byte_dirty_period}{byte_dirty_threshold} * cpu_now</p><p>\end{align} $$</p><p>(11) 解释:</p><p>由于<code class="language-plaintext highlighter-rouge">byte_dirty_period</code>较大， 我们需要在<code class="language-plaintext highlighter-rouge">byte_dirty_threshold</code>乘一个因子，让其 达到<code class="language-plaintext highlighter-rouge">byte_dirty_period</code>, 而前面我们假设认为<code class="language-plaintext highlighter-rouge">byte_dirty_period</code> 和 <code class="language-plaintext highlighter-rouge">cpu_run_time</code> 成正比, 所以我们可以将 <code class="language-plaintext highlighter-rouge">cpu_ideal / cpu_now</code> 作为乘因子。</p><p>由于上面是取 <code class="language-plaintext highlighter-rouge">cpu_now - cpu_ideal</code> 和 <code class="language-plaintext highlighter-rouge">pci_increment</code>的最小值，所以该流程 仅在后期起作用。</p><h2 id="commit--mail-list"><span class="me-2">commit &amp;&amp; mail list</span><a href="#commit--mail-list" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><ul><li><code class="language-plaintext highlighter-rouge">3c02270db980007424d797506301826310ce2db4</code><li><a href="https://lore.kernel.org/all/1372067382-141082-1-git-send-email-chegu_vinod@hp.com/">[PATCH v8 0/3] Throttle-down guest to help with live migration convergence</a><li><a href="https://lore.kernel.org/all/1372067259-141032-1-git-send-email-chegu_vinod@hp.com/">[PATCH v8 3/3] Throttle-down guest to help with live migration convergence</a></ul><li>Dynamic cpu throttling for auto-converge<ul><li><code class="language-plaintext highlighter-rouge">070afca258f973c704dcadf2769aa1ca921209a1</code><li>https://lore.kernel.org/all/1441732357-11861-1-git-send-email-jjherne@linux.vnet.ibm.com/</ul><li>migration/throttle: Add throttle-trig-thres migration parameter<ul><li><code class="language-plaintext highlighter-rouge">dc14a470763c96fd9d360e1028ce38e8c3613a77</code><li>https://patchwork.kernel.org/project/qemu-devel/patch/20200316042935.28306-1-zhukeqian1@huawei.com/</ul><li>migration/throttle: Add cpu-throttle-tailslow migration parameter<ul><li><code class="language-plaintext highlighter-rouge">cbbf818224faf5ede75c876e4900c9f8e6b6c0db</code><li>https://lore.kernel.org/all/20200413101508.54793-1-zhukeqian1@huawei.com/</ul></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/live-migration/">live_migration</a>, <a href="/categories/autoconverge/">autoconverge</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/autoconverge/" class="post-tag no-text-decoration" >autoconverge</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=auto-converge%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Fauto-converge%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=auto-converge%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Fauto-converge%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fauto-converge%2F&text=auto-converge%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/virtio-notify/">virtio notify</a><li class="text-truncate lh-lg"> <a href="/posts/virtio/">一文搞懵IO虚拟化之 -- virtio</a><li class="text-truncate lh-lg"> <a href="/posts/bpf-ISA/">Bpf Isa</a><li class="text-truncate lh-lg"> <a href="/posts/bpf-jit/">Bpf Jit</a><li class="text-truncate lh-lg"> <a href="/posts/bpf-verify/">Bpf Verify</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Migration-auto-converge-problem/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">[Translate]: Migration auto-converge problem</h4><div class="text-muted"><p>From: &quot;Jason J. Herne&quot; &amp;lt;jjherne@linux.vnet.ibm.com&amp;gt; To: &quot;qemu-devel@nongnu.org qemu-devel&quot; &amp;lt;qemu-devel@nongnu.org&amp;gt;, Christian Borntraeger &amp;lt;borntraeger@de.ibm.com&amp;gt; Subject: [Qemu-...</p></div></div></a></article><article class="col"> <a href="/posts/live-migration-workflow/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">live migration</h4><div class="text-muted"><p>热迁移简述 热迁移(live migration) 可以在虚拟机正在RUNNING时，对用户透明的从 source host 迁移到dest host. 涉及迁移对象种类 热迁移的流程会大概包含几个对象: cpu 内存 设备 主要工作 而热迁移主要工作是将这几个对象的信息，从原...</p></div></div></a></article><article class="col"> <a href="/posts/kvm-dirty_bitmap/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">dirty-bitmap</h4><div class="text-muted"><p>ORG PATCH 我们来看下最初的KVM实现了哪些功能。最初的KVM代码，是基于shadow page table, 支持了dirty_bitmap. 我们从几个方面看下dirty_bitmap实现: kernel data struct USER API lock Contention Analysis kernel data struct 并支持了dirty_b...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Migration-auto-converge-problem/" class="btn btn-outline-primary" aria-label="Older" ><p>[Translate]: Migration auto-converge problem</p></a> <a href="/posts/kvm-dirty_bitmap/" class="btn btn-outline-primary" aria-label="Newer" ><p>dirty-bitmap</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
