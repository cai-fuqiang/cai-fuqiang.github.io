<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="rcu - classic" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="本文主要讲解 经典rcu (classical rcu) 历史. 在介绍具体实现之前, 我们先明确几个概 念:" /><meta property="og:description" content="本文主要讲解 经典rcu (classical rcu) 历史. 在介绍具体实现之前, 我们先明确几个概 念:" /><link rel="canonical" href="/posts/rcu-classic/" /><meta property="og:url" content="/posts/rcu-classic/" /><meta property="og:site_name" content="Chirpy" /><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_todo_overflow.svg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2026-01-05T10:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_todo_overflow.svg" /><meta property="twitter:title" content="rcu - classic" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2026-01-05T10:00:00+08:00","datePublished":"2026-01-05T10:00:00+08:00","description":"本文主要讲解 经典rcu (classical rcu) 历史. 在介绍具体实现之前, 我们先明确几个概 念:","headline":"rcu - classic","image":"https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_todo_overflow.svg","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/rcu-classic/"},"url":"/posts/rcu-classic/"}</script><title>rcu - classic | Chirpy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chirpy"><meta name="application-name" content="Chirpy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/commons/avatar.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Chirpy</a><p class="site-subtitle fst-italic mb-0">A text-focused Jekyll theme</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/overflow/" class="nav-link"> <i class="fa-fw fas fa-star"></i> <span>OVERFLOW</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/github_username" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>rcu - classic</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>rcu - classic</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1767578400" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 5, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_todo_overflow.svg" class="popup img-link preview-img shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_todo_overflow.svg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="8686 words" > <em>48 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">rcu - classic</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">rcu - classic</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p>本文主要讲解 经典rcu (classical rcu) 历史. 在介绍具体实现之前, 我们先明确几个概 念:</p><ul><li><strong><em>quiescent state</em></strong>: 该CPU 上运行的所有 RCU 读取端临界区都已完成<sup>1</sup><li><strong><em>grace period</em></strong>: rcu 删除分为三部分, emoval ,Grace Period, and Reclamation. 宽限期 结束以所有cpu rcu 读临界区完成, 即所有cpu 都经历一次 <code class="language-plaintext highlighter-rouge">quiescent state</code><li><strong><em>rcu callback</em></strong>: 某些rcu writer将释放动作封装为一个<code class="language-plaintext highlighter-rouge">rcu_head</code>, 通过调用 <code class="language-plaintext highlighter-rouge">call_rcu()</code>注册回调，允许异步执行释放动作。</ul><p>rcu处理流程的关键点是:</p><ol><li>如何发现新的rcu callback, 发起一个新的宽限期<li><strong>如何判定该宽限期结束, 调用相关rcu callback</strong></ol><p>如下图所示:</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_todo_overflow.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_todo_overflow.svg" alt="rcu_todo_overflow" loading="lazy"></a></p><p>这里有几个问题需要思考下:</p><ol><li>谁持有rcu read lock(和问题三相关联)<li>什么时候需要发起一个新的宽限期<li>怎么确定该cpu 进入静默状态<li>怎么确定所有cpu 都经历了一次静默状态（当前宽限期结束)</ol><p>我们带着这些问题看接下来的内容:</p><h2 id="first-version"><span class="me-2">first version</span><a href="#first-version" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="struct"><span class="me-2">struct</span><a href="#struct" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>相关数据结构:</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_struct_overflow.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_struct_overflow.svg" alt="rcu_struct_overflow" loading="lazy"></a></p><p><strong><em>global</em></strong>:</p><ul><li><strong>rcu_ctrblk</strong>: 全局数据结构，和全局的宽限期”version”, 以及cpu静默状态位图<ul><li><strong>curbatch</strong>: 当前宽限期的”version”<li><strong>maxbatch</strong>: rcu callback “预定的” 最大宽限期 “version”<li><strong>rcu_cpu_mask</strong>: 当前宽限期处于静默状态位图</ul></ul><p><strong><em>per cpu</em></strong>:</p><ul><li>rcu_tasklet: 用于定义rcu_tasklet, 用户在<code class="language-plaintext highlighter-rouge">softirq</code>中处理rcu。<li><strong>rcu_data</strong>: 用于记录每个cpu的静默期，以及待处理的rcu callback 链表, 以及 batch “version”<ul><li><strong>qsctr</strong>: 当前静默期”version”<li><strong>last_qsctr</strong>: 上一次记录的静默期 “version”<li><strong>batch</strong>: 当前 <strong>curlist</strong> 处于宽限期的”version”<li><strong>curlist</strong>: 处于宽限期的rcu callback列表<li><strong>nxtlist</strong>: 表示待处理的rcu callback 列表(还未发起宽限期)</ul></ul><h3 id="处理流程"><span class="me-2">处理流程</span><a href="#处理流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="add-rcu_callback-to-head"><span class="me-2">add rcu_callback to head</span><a href="#add-rcu_callback-to-head" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">call_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="nc">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="c1">//===(1)===</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
    <span class="c1">//===(2)===</span>
    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="c1">//===(3)===</span>
    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RCU_nxtlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>构造<code class="language-plaintext highlighter-rouge">rcu_head</code> 数据机构<li>关中断。因为下面要操作<code class="language-plaintext highlighter-rouge">RCU_nxtlist()</code>, 防止该流程被中断打断（中断也可能执行这部分流程)<li>将新构造的 <code class="language-plaintext highlighter-rouge">head</code> 串到 <code class="language-plaintext highlighter-rouge">RCU_nxtlist()</code></ol><h4 id="cpu-experience-a-quiescent-state"><span class="me-2">cpu experience a quiescent state</span><a href="#cpu-experience-a-quiescent-state" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>上面讲述了，如何将rcu callback 注册到相应的数据结构中。那什么时候处理(执行)rcu callback呢? – 等一个完整的宽限期结束.</p><blockquote class="prompt-tip"><p>这里为什么要提完整的宽限期呢?</p><p>那就得讨论下是否要支持全局的宽限期。可以设想下，每个cpu 都可以发起宽限期。每个 cpu 负责记录自己的静默状态，并标记这些并在记录后，再处理每个cpu的宽限期状态。 这样实现起来太繁琐了。所以Linux 将宽限期定义为一个全局的状态。</p><p>举个例子, 如果rcu callback在每个时刻都会产生的话，整个的时间线将分割为不同的宽 限期.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>======================================================================&gt; timeline
|--  grace period 1  --|-- grace period 2 --|-- grace period 3--|--next 
</pre></table></code></div></div><p>那假设在period 1 阶段调用<code class="language-plaintext highlighter-rouge">call_rcu()</code>, 那call_rcu()产生的callback能不能在<code class="language-plaintext highlighter-rouge">grace period 1</code> 结束后执行么? 不可以，因为此时已经有一些cpu 进入下一个宽限期。可能正 处于读临界区中。所以需要等到grace period 2 结束。</p></blockquote><p>那么如何判定完整的宽限期结束呢? 在发起宽限期后，所有cpu 都经历一个静默状态. 那什 么时候可以判断静默状态结束呢?</p><p>明显的答案是<code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code>结束。因为这意味着读临界区结束。但是这样可能会和 Linux 本身要求rcu达到的效果相违背: 安全高效。</p><p><code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> 的问题:</p><p>全局状态更新太频繁: 在某个流程中频繁的调用<code class="language-plaintext highlighter-rouge">rcu_read_lock()</code>, <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code>. 频繁的更新全局状态会让写端(其实是处理grace period 流程)开销陡增（cache conherence cost)</p><blockquote class="prompt-warning"><p>并未找到官方说明, 所以这里我只是猜测。不知道是否有其他更深层次的原因。</p></blockquote><p>于是开发者们, 在两个点定义静默状态:</p><ul><li>timer interrupt from USERSPACE, idle<li>schedule()</ul><p>因为rcu读临界区都发生在内核代码中，所以从userspace 触发的中断可以断定一定没有处 于rcu读临界区。另外, idle比较特殊，其虽然位于内核空间，但是其是空闲的（什么都不 做), 所以也可以认为其属于静默状态.</p><p>判断条件在<code class="language-plaintext highlighter-rouge">rcu_check_callback()</code> 代码中:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">rcu_check_callbacks</span>
<span class="o">=&gt;</span> <span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="o">||</span> <span class="p">(</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">in_softirq</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">hardirq_count</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>
   <span class="o">=&gt;</span> <span class="n">RCU_qsctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">RCU_qsctr(cpu)++</code> 表示当前cpu已经经历了一次静默期。关于idle分支的判断 要稍微复杂一些:</p><ul><li><code class="language-plaintext highlighter-rouge">idle_cpu(cpu)</code>: 表示当前<code class="language-plaintext highlighter-rouge">cpu</code> 正在执行的任务是idle任务<li><code class="language-plaintext highlighter-rouge">!in_softirq()</code>: 不处于softirq 上下文<li><code class="language-plaintext highlighter-rouge">hardirq_count &lt;= 1</code>: 不处于中断上下文（该时钟中断的前一个上下文，而时钟中断 本身位于中断上下文, 所以这里要 <code class="language-plaintext highlighter-rouge">&lt;=1</code>)</ul><h4 id="when-to-initiate-a-new-grace-period-and-handle"><span class="me-2">when to initiate a new grace period and handle</span><a href="#when-to-initiate-a-new-grace-period-and-handle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当我们通过<code class="language-plaintext highlighter-rouge">call_rcu()</code> 注册一个异步callback后，这些callback需要经历一个完整的 宽限期。我们如何将这些callback和具体的宽限期联系起来。并在宽限期结束后处理 他们呢?</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_handle_overflow.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/rcu_handle_overflow.svg" alt="rcu_handle_overflow" loading="lazy"></a></p><p>如上图所示, 在时钟中断处理流程中，<code class="language-plaintext highlighter-rouge">scheduler_tick()</code> 会判断是否有<code class="language-plaintext highlighter-rouge">rcu</code>相关 的事情要处理, 如果有则调用 <code class="language-plaintext highlighter-rouge">rcu_check_callbacks()</code> 处理。该函数不仅会判断 是否经历了一次静默状态，同时也会调用<code class="language-plaintext highlighter-rouge">tasklet_schedule()</code> 调用<code class="language-plaintext highlighter-rouge">rcu_tasklet</code> 做进一步的下半部处理。</p><blockquote class="prompt-info"><p>关于rcu_pending()代码:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rcu_pending</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
         <span class="n">rcu_batch_before</span><span class="p">(</span><span class="n">RCU_batch</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">curbatch</span><span class="p">))</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
             <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_nxtlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span> <span class="o">||</span>
        <span class="n">test_bit</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>有两种情况需要在下半部进一步处理</p><ol><li>当前有未处理的 rcu_callback<ul><li>curlist 不为空，但是curlist 所在的batch 已经expired.(说明curlist所在的 宽限期已经结束), 或者<li>curlist 是空，nxtlist不为空。说明, 需要未nxtlist 发起一个新的宽限期<li>其他情况: 例如curlist 不为空，但是curlist 所在的batch 还没有 expired. 这说明curlist 所在的宽限期还没有结束。还不能为<code class="language-plaintext highlighter-rouge">nxtlist</code>分配下一个宽 限期</ul><li>判断<code class="language-plaintext highlighter-rouge">rcu_ctrlblk-&gt;rcu_cpu_mask</code> 是否有该cpu bit, <code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>用来标记 哪些cpu还没有在本次宽限期中经历静默状态; 如果为1 说明有宽限期正在等待 该cpu 到达静默状态。所以，需要该cpu 根据自己静默状态修改<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 这部分工作也放在了下半部处理。</ol></blockquote><h4 id="work-in-rcu_tasklet"><span class="me-2">work in rcu_tasklet</span><a href="#work-in-rcu_tasklet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>而位于<code class="language-plaintext highlighter-rouge">rcu_tasklet</code>中的流程，是rcu 处理的主流程, 其主要有几部分工作:</p><ul><li>为新的rcu callback分配宽限期<li>判断该cpu是否处于静默状态, 并修改<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code><li>判断该cpu curlist 所在的宽限期是否结束，如果结束执行相应的callback，并根据 nxtlist链表情况, 要不要发起下一个宽限期.</ul><p>代码并不复杂，我们直接看代码:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_process_callbacks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

    <span class="c1">//==(1)==</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="n">rcu_batch_after</span><span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">curbatch</span><span class="p">,</span> <span class="n">RCU_batch</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">//==(2)==</span>
    <span class="n">local_irq_disable</span><span class="p">();</span>
    <span class="c1">//==(3)==</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_nxtlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_nxtlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_nxtlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
        <span class="n">local_irq_enable</span><span class="p">();</span>

        <span class="cm">/*
         * start the next batch of callbacks
         */</span>
        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">RCU_batch</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">curbatch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">rcu_start_batch</span><span class="p">(</span><span class="n">RCU_batch</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">local_irq_enable</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">//==(4)==</span>
    <span class="n">rcu_check_quiescent_state</span><span class="p">();</span>
    <span class="c1">//==(5)==</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span>
        <span class="n">rcu_do_batch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>curlist中没有成员，并且 <code class="language-plaintext highlighter-rouge">rcu_ctrblk.curbatch</code> 比 <code class="language-plaintext highlighter-rouge">RCU_batch(cpu)</code> 要高，说明 当前全局的宽限期，已经比<code class="language-plaintext highlighter-rouge">cpu curlist</code>所在的宽限期要高，所以<code class="language-plaintext highlighter-rouge">cpu curlist</code>宽限期 已经结束。为此可以执行该<code class="language-plaintext highlighter-rouge">cpu curlist</code>中的<code class="language-plaintext highlighter-rouge">rcu callback</code><li>这里比较有意思，访问 RCU_curlist() 没有关中断，但是访问RCU_nxtlist() 却关中断, 原因是因为nxtlist 可能会在中断上下文中更新。<li>如果nxtlist不为空，但是curlist为空, 则需要为nxtlist 分配一个新的宽限期. 首先将nxtlist 链表转移至 curlist, 接着分配 <code class="language-plaintext highlighter-rouge">RCU_batch(cpu)</code> 宽限期”version” 为<code class="language-plaintext highlighter-rouge">global current batch + 1</code>(<code class="language-plaintext highlighter-rouge">rcu_ctrlblk-&gt;curbatch + 1</code>). 然后调用 <code class="language-plaintext highlighter-rouge">rcu_staret_batch()</code>（下面讲)<li>该函数会判断当前函数是否经历一次完整的静默期.<li>根据 1 可知，list中的rcu callback肯定经历了一次完整的静默期，可以执行release<ul><li>rcu_callback 流程</ul></ol><p><strong><em>rcu_start_batch()</em></strong>:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_start_batch</span><span class="p">(</span><span class="kt">long</span> <span class="n">newbatch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//maxbatch 永远记录当前"申请的" 最大的宽限期版本</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rcu_batch_before</span><span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">maxbatch</span><span class="p">,</span> <span class="n">newbatch</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">maxbatch</span> <span class="o">=</span> <span class="n">newbatch</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//如果maxbatch 比curbatch 早，说明 curbatch 已经涨上来了。</span>
    <span class="c1">//（curbatch - 1 已经结束了)</span>
    <span class="c1">//</span>
    <span class="c1">//反之，并且`rcu_ctrblk.rcu_cpu_mask == 0`, 说明旧的宽限期已经结束，并且有</span>
    <span class="c1">//新的宽限期需要发起.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rcu_batch_before</span><span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">maxbatch</span><span class="p">,</span> <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">curbatch</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//发起一个新的宽限期</span>
    <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span> <span class="o">=</span> <span class="n">cpu_online_map</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>怎么才算发起一个新的宽限期呢? 还记得<code class="language-plaintext highlighter-rouge">rcu_pending()</code>的条件么? 只要该cpu 的 <code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 置位，说明该cpu 需要关注自己的静默状态, 并在达到静默状态后， 清除<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>相应状态，所以，将<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>全部置位，所有的cpu 都要重新关注自己的静默状态。这样算是发起了新的宽限期。</p><blockquote class="prompt-tip"><p>发起宽限期的条件之一是 <code class="language-plaintext highlighter-rouge">rcu_ctrlblk.maxbatch &gt;= rcu_ctrlblk.curbatch</code>, 所以无论是curbatch改变，还是<code class="language-plaintext highlighter-rouge">maxbatch</code>改变都有可能发起新的宽限期.</p><p>而该调用路径:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>rcu_process_callback()
=&gt; rcu_start_batch()
   =&gt; rcu_ctrlblk.rcu_cpu_mask = cpu_online_map
</pre></table></code></div></div><p>其实是描述的<code class="language-plaintext highlighter-rouge">maxbatch</code>改变，在cpu检测到宽限期结束，自增全局curbatch时， 也会让这个天平倾斜</p></blockquote><p><strong><em>rcu_check_quiescent_state()</em></strong></p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_check_quiescent_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

    <span class="c1">//未置位的原因是该cpu 在该宽限期已经是静默状态.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * Races with local timer interrupt - in the worst case
     * we may miss one quiescent state of that CPU. That is
     * tolerable. So no need to disable interrupts.
     */</span>
    <span class="c1">//这个流程可能会和local timer interrupt 冲突??</span>
    <span class="c1">//冲突意味着 RCU_qsctr() 会更改, 但是结合`rcu_check_callbacks()`</span>
    <span class="c1">//代码来看其不会更改 RCU_qsctr()</span>
    <span class="c1">//</span>
    <span class="c1">//那还有一种可能 -- 调度, 但是softirq 不能被抢占。但是ksoftirq 可以</span>
    <span class="c1">//被抢占,  这里的意思难道是ksoftirq可以被抢占? 导致抢占后 RCU_qsctr</span>
    <span class="c1">//更改?</span>
    <span class="c1">//==(1)==</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RCU_last_qsctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">RCU_QSCTR_INVALID</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">RCU_last_qsctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">RCU_qsctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//==(1.2)==</span>
    <span class="c1">//说明当前记录的宽限期(last_qsctr) 还未结束</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RCU_qsctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">RCU_last_qsctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">//这个地方也很奇怪, 前面也检查过该cpu的mask，确定</span>
    <span class="c1">//present后，才会向下执行，但是这里为什么要加自旋锁</span>
    <span class="c1">//再检查下</span>
    <span class="c1">//==(2)==</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//运行到这里说明宽限期已经结束</span>
    <span class="n">clear_bit</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span><span class="p">);</span>

    <span class="c1">//last_qsctr 置为 RCU_QSCTR_INVALID(0)</span>
    <span class="n">RCU_last_qsctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">RCU_QSCTR_INVALID</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//处理下一个宽限期</span>
    <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">curbatch</span><span class="o">++</span><span class="p">;</span>

    <span class="c1">//发起下一个宽限期,</span>
    <span class="c1">//==(3)==</span>
    <span class="n">rcu_start_batch</span><span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">maxbatch</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li><p>为什么<code class="language-plaintext highlighter-rouge">qsctr</code> 要经历<code class="language-plaintext highlighter-rouge">RCU_QSCTR_INVAILD-&gt; RCU_qsctr(cpu) -&gt; RCU_qsctr()++</code> 这样的变化。而不能直接在宽限期结束后，不重制<code class="language-plaintext highlighter-rouge">RCU_last_qsctr()</code>.</p><p>当宽限期结束后，有新的宽限期发起，这时如果走到1，会将 <code class="language-plaintext highlighter-rouge">last_qsctr</code> 赋值为 <code class="language-plaintext highlighter-rouge">qsctr</code>, 但是如果做这个流程，必须得是新的宽限期发起后才做，而宽限期发起后， 如果执行了一次这个流程就无需在做，只需要等待<code class="language-plaintext highlighter-rouge">1.2</code>条件满足即可。</p><p>所以这里将<code class="language-plaintext highlighter-rouge">qsctr</code>赋值为<code class="language-plaintext highlighter-rouge">RCU_QSCTR_INVAILD</code>, 为了给下次进入该函数识别新宽限期 发起后，首次执行该函数作准备</p><li>这个地方着实没看懂<li>这里使用<code class="language-plaintext highlighter-rouge">maxbatch</code>作为参数调用<code class="language-plaintext highlighter-rouge">rcu_start_batch()</code>, <code class="language-plaintext highlighter-rouge">maxbatch</code> 前面提到过, 可 以认为是 目前”预定的”最大版本的宽限期. 相当于pending的最大版本的宽限期， 如果这个宽限期都处理完了，说明所有的<code class="language-plaintext highlighter-rouge">cpu-&gt;curlist</code> 都处理完了。</ol><h3 id="处理流程图示"><span class="me-2">处理流程图示</span><a href="#处理流程图示" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><details closee=""> <summary>流程图示展开</summary><p>初始状态</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_init.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_init.svg" alt="first_patch_simple_process_init" loading="lazy"></a></p><p>cpu0 rcu writer 调用 call_rcu() 异步释放object</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_1.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_1.svg" alt="first_patch_simple_process_1" loading="lazy"></a></p><p>CPU0 在时钟中断中发现有rcu事情需要处理，唤起 rcu tasklet, 将nxtlist 移动至 cutlist</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_2.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_2.svg" alt="first_patch_simple_process_2" loading="lazy"></a></p><p>发起一个新的宽限期新的宽限期为2 (maxbatch(2) 表示当前申请的最大的宽限期), <code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 赋值为 <code class="language-plaintext highlighter-rouge">cpu_online_mask</code>(1,1,1,1), 表示所有的cpu豆未经历静默状态。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_3.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_3.svg" alt="first_patch_simple_process_3" loading="lazy"></a></p><p>CPU0, CPU1, CPU2, CPU3 在检测自己是否进入静默状态是，现将 <code class="language-plaintext highlighter-rouge">last_qsctr</code>重置为<code class="language-plaintext highlighter-rouge">qsctr</code>，不过后者也是0。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_5.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_5.svg" alt="first_patch_simple_process_5" loading="lazy"></a></p><p>CPU0, CPU1, CPU2 进入静默状态，清除自己cpu的 <code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code></p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_6.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_6.svg" alt="first_patch_simple_process_6" loading="lazy"></a></p><p>CPU3 进入静默状态，并清除其cpu的<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>, 作为最后一个清除<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 的cpu, 最终会将<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 更改为0。更新至0 意味着所有的cpu 都进入静默状态。 也就是该宽限期(1)结束。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_7.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_7.svg" alt="first_patch_simple_process_7" loading="lazy"></a></p><p>宽限期(1) 结束，但是CPU0 curlist申请的不是宽限期1而是宽限期2(maxbatch), 所以 该宽限期结束不会处理任何callback，但是会发起进入下一个宽限期.</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_8.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_8.svg" alt="first_patch_simple_process_8" loading="lazy"></a></p><p>等待所有cpu又经历一个宽限期后, cpu0的rcu callback可以得到处理。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_9.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/rcu/rcu_classic/pic/first_patch_simple_process_9.svg" alt="first_patch_simple_process_9" loading="lazy"></a></p><p>处理过后，maxbatch仍然是2，而curbatch 更新至3，curbatch &gt; maxbatch, 说明pending 的宽限期已经处理完成，没有必要再处理curbatch。等待maxbatch 更新上来。</p><p>可以看到这里有些流程是不太好的。例如当我们重新发起宽限期时(move nxtlist-&gt;curlist), 总是将<code class="language-plaintext highlighter-rouge">RCU_batch(cpu) = rcu_ctrlblk.curbatch + 1</code>, 并没有看当前的宽限期活不活跃。 这样就会多经历一个额外的宽限期</p></details><h2 id="nohz-support"><span class="me-2">NOHZ support</span><a href="#nohz-support" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">s390</code>首先引入了<code class="language-plaintext highlighter-rouge">nohz</code>(commit 2), <code class="language-plaintext highlighter-rouge">nohz</code>意味着空闲的核心将可能在一段事件之内不会 有时钟中断。而发起一个新的宽限期后, 会等待所有的cpu进入静默状态。而 每个 cpu调整自己的静默状态是依赖时钟中断的执行<code class="language-plaintext highlighter-rouge">rcu_pending()</code>, 然后再唤醒<code class="language-plaintext highlighter-rouge">rcu tasklet</code> 所以, 当关闭某个cpu的时钟中断后，原有的<code class="language-plaintext highlighter-rouge">rcu</code>的处理逻辑就要变动。</p><p>首先，处于nohz的cpu肯定是idle的, 并且不会处于中断上下文和软中断上下文。 所以, 在发起新的宽限期时，可以不选择等待处于nohz 的cpu</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre> static void rcu_start_batch(long newbatch)
 {
<span class="gi">+       cpumask_t active;
+
</span>        if (rcu_batch_before(rcu_ctrlblk.maxbatch, newbatch)) {
                rcu_ctrlblk.maxbatch = newbatch;
        }
<span class="p">@@ -111,7 +113,9 @@</span> static void rcu_start_batch(long newbatch)
                return;
        }
        /* Can't change, since spin lock held. */
<span class="gd">-       rcu_ctrlblk.rcu_cpu_mask = cpu_online_map;
</span><span class="gi">+       active = idle_cpu_mask;
+       cpus_complement(active);
+       cpus_and(rcu_ctrlblk.rcu_cpu_mask, cpu_online_map, active);
</span> }
</pre></table></code></div></div><p>另外，如果在宽限期中，如果一个cpu并未进入静默状态，说明有宽限期在等待 该cpu进入静默状态，然后结束宽限期。此时该cpu不能进入nohz。(相当于不能 在读临界区中长期阻塞)</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>stop_hz_timer
<span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>rcu_pending<span class="o">(</span>smp_processor_id<span class="o">())</span> <span class="o">||</span> local_softirq_pending<span class="o">())</span>
   <span class="c">## return 1 表示 CPU 没有停掉timer</span>
   <span class="o">=&gt;</span> <span class="k">return </span>1
</pre></table></code></div></div><blockquote class="prompt-info"><p>我这里有一点疑问:</p><p>这里访问<code class="language-plaintext highlighter-rouge">idle_cpu_mask</code> 并未使用同步源语. 那另一个cpu对 idle_cpu_mask 的更新，可能得等一段事件才能被<code class="language-plaintext highlighter-rouge">rcu_start_batch()</code>发现，那么这会有影 响么?</p><p>例如:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>cpu0                       cpu1
==============================================
start_hz_timer
  update idle_cpu_mask
  enter rcu crtical section
    get data1
                           delete data1 in list
                           start a new grace period
                             copy idle_cpu_mask(but copy old data)
</pre></table></code></div></div><p>我个人认为可能会有这种情况.</p></blockquote><h2 id="cpu-hotplug"><span class="me-2">CPU HotPlug</span><a href="#cpu-hotplug" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当发起一个新的宽限期时，会将<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 赋值为<code class="language-plaintext highlighter-rouge">cpu_online_map</code>. 其只关注 online的cpu。从当cpu拓扑处于静态状态(没有热插拔), 来看没有什么问题.</p><p>但是当支持热插拔后, 事情有一些复杂。我们分为两个部分:</p><ul><li>热插<ul class="prompt-warning"><li>当热插后，cpu online 流程会更新<code class="language-plaintext highlighter-rouge">cpu_online_map</code>, 然后再进入读临界区。(中间 可能会有内存屏障。所以对于发起宽限期流程来说不会有影响。<blockquote><p>关于cpu online 处理流程 纯个人猜测，没有找到代码(置位 cpu_online_map)</p></blockquote></ul><li>热拔<ul><li>热拔流程会受一些影响主要为:<ul><li>在热拔时，该cpu可能在当前的宽限期中还未进入静默状态（也就意味着有人在等)<li>在热拔时, 可能有一些rcu callback还未执行</ul><p>那我们展开下这部分改动</p></ul></ul><p><strong>rcu 关于 cpu热拔新增改动</strong></p><p>首先在增加<code class="language-plaintext highlighter-rouge">CPU_DEAD</code> notify:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="p">@@ -214,7 +269,11 @@</span> static int __devinit rcu_cpu_notify(struct notifier_block *self,
        case CPU_UP_PREPARE:
                rcu_online_cpu(cpu);
                break;
<span class="gd">-       /* Space reserved for CPU_OFFLINE :) */
</span><span class="gi">+#ifdef CONFIG_HOTPLUG_CPU
+       case CPU_DEAD:
+               rcu_offline_cpu(cpu);
+               break;
+#endif
</span>        default:
                break;
        }
</pre></table></code></div></div><p>查看相关回调:</p><details> <summary>代码以及解释展开</summary><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
</pre><td class="rouge-code"><pre><span class="cm">/* warning! helper for rcu_offline_cpu. do not use elsewhere without reviewing
 * locking requirements, the list it's pulling from has to belong to a cpu
 * which is dead and hence not processing interrupts.
 */</span>
<span class="cm">/*
 * 这种处理往往是危险的。
 *
 * 首先中断上下文可能会调用`call_rcu()`, 所以一般情况下，操作`RCU_nxtlist()`都会
 * 关中断。
 *
 * 另外list所在的cpu 未offline那更危险，因为操作 per cpu的 rcu_data不会加锁。
 * 所以可能有两个cpu同时操作一个rcu_data...
 *
 * 所以`rcu_move_batch` 的约束为 offline cpu 另外关中断(在rcu_move_batch() 中已
 * 经将中断关了
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_move_batch</span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
    <span class="c1">//获取当前cpu</span>
    <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

    <span class="n">local_irq_disable</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="c1">//从之前的list转移到当前cpu 的 RCU_nxtlist()上.</span>
        <span class="n">list_del</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RCU_nxtlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_offline_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* if the cpu going offline owns the grace period
     * we can block indefinitely waiting for it, so flush
     * it here
     */</span>
    <span class="c1">//cpu offline之前先标记他已经进入静默状态,</span>
    <span class="c1">//和 rcu_check_quiescent_state() 类似, 当有cpu标记其进入静默状态，</span>
    <span class="c1">//该cpu还需要负责检查宽限期是否结束，如果结束，根据是否有pending</span>
    <span class="c1">//的宽限期发起新的宽限期</span>
    <span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

    <span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cpus_empty</span><span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">rcu_cpu_mask</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">//标记该宽限期已经结束</span>
        <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">curbatch</span><span class="o">++</span><span class="p">;</span>
        <span class="cm">/* We may avoid calling start batch if
         * we are starting the batch only
         * because of the DEAD CPU (the current
         * CPU will start a new batch anyway for
         * the callbacks we will move to current CPU).
         * However, we will avoid this optimisation
         * for now.
         */</span>
        <span class="cm">/*
         * 但是有必要在这里发起宽限期么?
         *
         * 当前cpu(非hotplug cpu) 会因为宽限期已经结束，rcu_pending 
         * 会返回true。从而进入`rcu_process_callbacks()`, 如果此时iu
         * `nxtlist`有值则会发起一个新的宽限期
         * 
         * 如果在这里取消调用`rcu_start_batch()`，就比较依赖`nxtlist`
         * 有值，但是一定会有值么?
         *
         * 首先如果当前cpu本身nxtlist 有值 那没有问题。
         *
         * 那如果当前cpu没有值，但是hotplug的 curlist, nxtlist 有值，那也没有问
         * 题，请看`rcu_move_batch()`
         *
         * 但是如果两个都没有值，但是maxbatch &gt;= curbatch (这里大概率是 等于),
         * 说明什么呢? 说明曾经有cpu预定过下一个宽限期。那后续就没有办法及时
         * 发起曾经pending的宽限期。
         *
         * 所以这个地方如果想优化，还得做一些其他改动。
         */</span>
        <span class="n">rcu_start_batch</span><span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">maxbatch</span><span class="p">);</span>
    <span class="p">}</span>
<span class="n">unlock</span><span class="o">:</span>
    <span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="c1">//将offline cpu的 curlist移动到 当前cpu的 nxtlist</span>
    <span class="n">rcu_move_batch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_curlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
    <span class="c1">//将offline cpu的 nxtlist移动到 当前cpu的 nxtlist</span>
    <span class="n">rcu_move_batch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_nxtlist</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

    <span class="n">tasklet_kill_immediate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCU_tasklet</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div></details><h2 id="rcu_cpu_mask-is-too-busy"><span class="me-2">rcu_cpu_mask is too busy</span><a href="#rcu_cpu_mask-is-too-busy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 表示哪些cpu在本次宽限期中有没有进入静默状态:</p><ul><li><strong><em>0</em></strong>: 进入静默状态<li><strong><em>1</em></strong>: 尚未进入静默状态</ul><p>一版来说, 内核的宽限期都不长，所以该字段可能面临频繁更新。（尤其是cpu很多的情况 下), 而<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>的访问频次又很高。出现在:</p><p><strong>check look for quiescent states</strong></p><ul><li>rcu_pending()<li>rcu_check_quiescent_state()</ul><p>这两个位置都会获取当前cpu 是否在宽限期中已经处于静默状态。这种情况下，面临严重的 cacheline trash. (可以回忆下 directory cache conherence read miss 的场景)。</p><p>但是我们在宽限期中进入静默状态后，在新的宽限期到来之前，该cpu的静默状态不再会更 改。（换句话说一个cpu的静默状态在一次宽限期中只会变更一次）。其他cpu静默状态变化 并不影响该cpu的静默状态。但是因为代码实现的原因，而导致其他cpu静默状态变化，影响 该cpu获取静默状态的性能，显然是不合理的。</p><p>因此cpu 是否处于静默状态更适合使用percpu vars保存，并且该变量的行为更像是 <code class="language-plaintext highlighter-rouge">read-only</code> (write-less). 尽量避免对写频繁的 <code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code> 访问.</p><p>于是, <code class="language-plaintext highlighter-rouge">Manfred Spraul</code>在上一版rcu实现中，做了如下改动:</p><h3 id="separating-write-hot-and-write-cold-variables-in-rcu_ctrblk"><span class="me-2">Separating Write-Hot and Write-Cold Variables in rcu_ctrblk</span><a href="#separating-write-hot-and-write-cold-variables-in-rcu_ctrblk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>cacheline trash 问题往往发生在对全局变量的更新中。所以<code class="language-plaintext highlighter-rouge">Manfred</code> 将<code class="language-plaintext highlighter-rouge">write-hot</code>部分 和<code class="language-plaintext highlighter-rouge">write-cold</code>分为两个cacheline:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre> struct rcu_ctrlblk {
<span class="gd">-       spinlock_t      mutex;          /* Guard this struct                  */
-       long            curbatch;       /* Current batch number.              */
-       long            maxbatch;       /* Max requested batch number.        */
-       cpumask_t       rcu_cpu_mask;   /* CPUs that need to switch in order  */
-                                       /* for current batch to proceed.      */
</span><span class="gi">+       /* "const" members: only changed when starting/ending a grace period  */
+       struct {
+               long    cur;            /* Current batch number.              */
+               long    completed;      /* Number of the last completed batch */
+       } batch ____cacheline_maxaligned_in_smp;
+       /* remaining members: bookkeeping of the progress of the grace period */
+       struct {
+               spinlock_t      mutex;  /* Guard this struct                  */
+               int     next_pending;   /* Is the next batch already waiting? */
+               cpumask_t       rcu_cpu_mask;   /* CPUs that need to switch   */
+                               /* in order for current batch to proceed.     */
+       } state ____cacheline_maxaligned_in_smp;
</span> };
</pre></table></code></div></div><p>这里有一些新面孔:</p><ul><li><strong>cur</strong>: 同curbatch, 在宽限期结束后更新<li><strong>completed</strong>: 上一个完成的 batch, 在宽限期结束后更新<li><strong>next_pending</strong>: 有下一个宽限期pending, 在发起新的宽限期时更新</ul><p>该改动主要是优化了先前的<code class="language-plaintext highlighter-rouge">maxbatch</code>的逻辑。</p><p>之前如何判断是否有一个新的宽限期需要发起呢?</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>maxbatch &gt; curbatch
</pre></table></code></div></div><p>但是maxbatch的值，往往最大=curbatch + 1, 表示下一个预定的宽限期比当前宽限期大， 也就是有pending的宽限期，由于只大一，所以其也只能表示是否有pending. 所以这里干 脆就将这个值删除，直接搞一个<code class="language-plaintext highlighter-rouge">next_pending</code>表示是否有新的宽限期正在阻塞，当前 宽限期结束后，需要立即发起该宽限期。</p><p>另外, 关于宽限期是否结束的判断逻辑也更改了，之前是判断:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">rcu_batch_before</span><span class="p">(</span><span class="n">RCU_batch</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">curbatch</span><span class="p">)</span>
</pre></table></code></div></div><p>curbatch 如果完成，就自增为<code class="language-plaintext highlighter-rouge">curbatch+1</code></p><p>现在使用completed替代. 表已经完成的宽限期的最大版本, 所以判断逻辑更改为:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="o">!</span><span class="n">rcu_batch_before</span><span class="p">(</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">batch</span><span class="p">.</span><span class="n">completed</span><span class="p">,</span><span class="n">RCU_batch</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
</pre></table></code></div></div><p>发起新宽限期的代码也有变动:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="gd">-static void rcu_start_batch(long newbatch)
</span><span class="gi">+static void rcu_start_batch(int next_pending)
</span> {
        cpumask_t active;
<span class="err">
</span><span class="gd">-       if (rcu_batch_before(rcu_ctrlblk.maxbatch, newbatch)) {
-               rcu_ctrlblk.maxbatch = newbatch;
</span><span class="gi">+       if (next_pending)
+               rcu_ctrlblk.state.next_pending = 1;
+
+       if (rcu_ctrlblk.state.next_pending &amp;&amp;
+                       rcu_ctrlblk.batch.completed == rcu_ctrlblk.batch.cur) {
+               rcu_ctrlblk.state.next_pending = 0;
+               /* Can't change, since spin lock held. */
+               active = nohz_cpu_mask;
+               cpus_complement(active);
+               cpus_and(rcu_ctrlblk.state.rcu_cpu_mask, cpu_online_map, active);
+               rcu_ctrlblk.batch.cur++;
</span>        }
<span class="gd">-       if (rcu_batch_before(rcu_ctrlblk.maxbatch, rcu_ctrlblk.curbatch) ||
-           !cpus_empty(rcu_ctrlblk.rcu_cpu_mask)) {
-               return;
</span><span class="gi">+}
</span></pre></table></code></div></div><p>不再维护<code class="language-plaintext highlighter-rouge">newbatch</code>，而是传入<code class="language-plaintext highlighter-rouge">next_pending</code>表示，调用该函数的原因是由于</p><ul><li>发起了新的宽限期? – <code class="language-plaintext highlighter-rouge">next_pending = 1</code><li>当前宽限期结束，可能有pending的宽限期需要处理 – <code class="language-plaintext highlighter-rouge">next_pending == 1</code></ul><p>然后再根据<code class="language-plaintext highlighter-rouge">rcu_ctrlblk.statet.next_pending</code>决定是否要发起新的宽限期.</p><p>而调用流程和之前类似:</p><ul><li><p>发起了新的宽限期的调用者: 将nxtlist-&gt;curlist, 发起新的宽限期</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="p">@@ -236,10 +268,10 @@</span> static void rcu_process_callbacks(unsigned long unused)
                /*
                 * start the next batch of callbacks
                 */
<span class="gd">-               spin_lock(&amp;rcu_ctrlblk.mutex);
-               RCU_batch(cpu) = rcu_ctrlblk.curbatch + 1;
-               rcu_start_batch(RCU_batch(cpu));
-               spin_unlock(&amp;rcu_ctrlblk.mutex);
</span><span class="gi">+               spin_lock(&amp;rcu_ctrlblk.state.mutex);
+               RCU_batch(cpu) = rcu_ctrlblk.batch.cur + 1;
+               rcu_start_batch(1);
+               spin_unlock(&amp;rcu_ctrlblk.state.mutex);
</span></pre></table></code></div></div><li><p><code class="language-plaintext highlighter-rouge">cpu_quiet()</code> 表示该宽限期已经结束，可能有pending的宽限期需要处理（发起pending 的宽限期)</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>cpu_quiet
<span class="o">=&gt;</span> cpus_empty<span class="o">(</span>rcu_ctrlblk.state.rcu_cpu_mask<span class="o">)</span>
   <span class="c">## 重新赋值 completed-&gt;cur, 表示该宽限期已经结束</span>
   <span class="o">=&gt;</span> rcu_ctrlblk.batch.completed <span class="o">=</span> rcu_ctrlblk.batch.cur<span class="p">;</span>
   <span class="c">## 可能有pending的宽限期，尝试发起</span>
   <span class="o">=&gt;</span> rcu_start_batch<span class="o">(</span>0<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div></ul><h3 id="record-per-cpu-batch"><span class="me-2">record per cpu batch</span><a href="#record-per-cpu-batch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>前面提到过，判断该cpu是否要处理rcu宽限期需要判断全局的<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>, 性能不好 要切换到<code class="language-plaintext highlighter-rouge">per-cpu vars</code>来记录, 那么就需要记录，在当前宽限期内，是否进入过静默 状态。在per cpu 的<code class="language-plaintext highlighter-rouge">rcu_data</code>中增加</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="k">struct</span> <span class="nc">rcu_data</span> <span class="p">{</span>
<span class="o">+</span>       <span class="cm">/* 1) quiescent state handling : */</span>
<span class="o">+</span>        <span class="kt">long</span>           <span class="n">quiescbatch</span><span class="p">;</span>     <span class="cm">/* Batch # for grace period */</span>
        <span class="kt">long</span>            <span class="n">qsctr</span><span class="p">;</span>           <span class="cm">/* User-mode/idle loop etc. */</span>
         <span class="kt">long</span>            <span class="n">last_qsctr</span><span class="p">;</span>     <span class="cm">/* value of qsctr at beginning */</span>
                                          <span class="cm">/* of rcu grace period */</span>
<span class="o">+</span>       <span class="kt">int</span>             <span class="n">qs_pending</span><span class="p">;</span>      <span class="cm">/* core waits for quiesc state */</span>
<span class="o">+</span>
<span class="o">+</span>       <span class="cm">/* 2) batch handling */</span>
         <span class="kt">long</span>           <span class="n">batch</span><span class="p">;</span>           <span class="cm">/* Batch # for current RCU batch */</span>
         <span class="k">struct</span> <span class="nc">list_head</span>  <span class="n">nxtlist</span><span class="p">;</span>
         <span class="k">struct</span> <span class="nc">list_head</span>  <span class="n">curlist</span><span class="p">;</span>

</pre></table></code></div></div><ul><li><strong>quiescbatch</strong>: 当前cpu所处的宽限期<li><strong>qs_pending</strong>: 在<code class="language-plaintext highlighter-rouge">quiescbatch</code>所表示的宽限期中，该cpu是否处于静默状态</ul><p>我们首先来看<code class="language-plaintext highlighter-rouge">rcu_pending()</code>处的改动:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre> static inline int rcu_pending(int cpu)
 {
<span class="gd">-       if ((!list_empty(&amp;RCU_curlist(cpu)) &amp;&amp;
-            rcu_batch_before(RCU_batch(cpu), rcu_ctrlblk.curbatch)) ||
-           (list_empty(&amp;RCU_curlist(cpu)) &amp;&amp;
-                        !list_empty(&amp;RCU_nxtlist(cpu))) ||
-           cpu_isset(cpu, rcu_ctrlblk.rcu_cpu_mask))
</span><span class="gi">+       /* This cpu has pending rcu entries and the grace period
+        * for them has completed.
+        */
+       if (!list_empty(&amp;RCU_curlist(cpu)) &amp;&amp;
+                 !rcu_batch_before(rcu_ctrlblk.batch.completed,RCU_batch(cpu)))
+               return 1;
+       /* This cpu has no pending entries, but there are new entries */
+       if (list_empty(&amp;RCU_curlist(cpu)) &amp;&amp;
+                        !list_empty(&amp;RCU_nxtlist(cpu)))
+               return 1;
+       /* The rcu core waits for a quiescent state from the cpu */
</span>        //有新的宽限期到达, 需要重新关注该cpu在该宽限期内的静默状态
        //或者
        //在当前的宽限期内，该cpu还未进入静默状态
<span class="gi">+       if (RCU_quiescbatch(cpu) != rcu_ctrlblk.batch.cur || RCU_qs_pending(cpu))
</span>                return 1;
<span class="gd">-       else
-               return 0;
</span><span class="gi">+       /* nothing to do */
+       return 0;
</span> }
</pre></table></code></div></div><p>可以看到在判断是否需要处理静默状态时，不再访问<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code></p><p>我们再来看下<code class="language-plaintext highlighter-rouge">rcu_check_quiescent_state()</code> 是怎么处理静默状态的:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="p">@@ -127,7 +161,19 @@</span> static void rcu_check_quiescent_state(void)
 {
        int cpu = smp_processor_id();
<span class="err">
</span><span class="gd">-       if (!cpu_isset(cpu, rcu_ctrlblk.rcu_cpu_mask))
</span>        //==(1)==
<span class="gi">+       if (RCU_quiescbatch(cpu) != rcu_ctrlblk.batch.cur) {
+               /* new grace period: record qsctr value. */
+               RCU_qs_pending(cpu) = 1;
+               RCU_last_qsctr(cpu) = RCU_qsctr(cpu);
+               RCU_quiescbatch(cpu) = rcu_ctrlblk.batch.cur;
+               return;
+       }
+
</span>        //==(2)==
<span class="gi">+       /* Grace period already completed for this cpu?
+        * qs_pending is checked instead of the actual bitmap to avoid
+        * cacheline trashing.
+        */
+       if (!RCU_qs_pending(cpu))
</span>                return;
        //==(3)==
</pre></table></code></div></div><ol><li>当判断有新的宽限期到达时，将<code class="language-plaintext highlighter-rouge">RCU_quiescbatch</code>更新为新的宽限期版本,并置位 <code class="language-plaintext highlighter-rouge">RCU_qs_pending</code><li>当cpu在该宽限期内不再处于静默状态时, 则不需要再处理. 直接返回<li>说明该cpu在该宽限期在之前未处于静默状态，需要继续判断现在是否已经进入静默状态</ol><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="p">@@ -135,27 +181,19 @@</span> static void rcu_check_quiescent_state(void)
         * we may miss one quiescent state of that CPU. That is
         * tolerable. So no need to disable interrupts.
         */
<span class="gd">-       if (RCU_last_qsctr(cpu) == RCU_QSCTR_INVALID) {
-               RCU_last_qsctr(cpu) = RCU_qsctr(cpu);
-               return;
-       }
</span>        if (RCU_qsctr(cpu) == RCU_last_qsctr(cpu))
                return;
        //==(1)==
<span class="gi">+       RCU_qs_pending(cpu) = 0;
</span><span class="err">
</span><span class="gd">-       spin_lock(&amp;rcu_ctrlblk.mutex);
-       if (!cpu_isset(cpu, rcu_ctrlblk.rcu_cpu_mask))
-               goto out_unlock;
-
-       cpu_clear(cpu, rcu_ctrlblk.rcu_cpu_mask);
-       RCU_last_qsctr(cpu) = RCU_QSCTR_INVALID;
-       if (!cpus_empty(rcu_ctrlblk.rcu_cpu_mask))
-               goto out_unlock;
-
-       rcu_ctrlblk.curbatch++;
-       rcu_start_batch(rcu_ctrlblk.maxbatch);
</span><span class="gi">+       spin_lock(&amp;rcu_ctrlblk.state.mutex);
+       /*
+        * RCU_quiescbatch/batch.cur and the cpu bitmap can come out of sync
+        * during cpu startup. Ignore the quiescent state.
+        */
</span>        //==(2)==
<span class="gi">+       if (likely(RCU_quiescbatch(cpu) == rcu_ctrlblk.batch.cur))
+               cpu_quiet(cpu);
</span><span class="err">
</span><span class="gd">-out_unlock:
-       spin_unlock(&amp;rcu_ctrlblk.mutex);
</span><span class="gi">+       spin_unlock(&amp;rcu_ctrlblk.state.mutex);
</span> }
</pre></table></code></div></div><ol><li>cpu 在该宽限期已经处于静默状态，置位<code class="language-plaintext highlighter-rouge">RCU_qs_pending()</code><li><p>走到这里，说明cpu已经处于静默状态，但是时第一次进入该函数，需要将cpu 在 <code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>中移除:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="gi">+/*
+ * cpu went through a quiescent state since the beginning of the grace period.
+ * Clear it from the cpu mask and complete the grace period if it was the last
+ * cpu. Start another grace period if someone has further entries pending
+ */
+static void cpu_quiet(int cpu)
+ {
+       cpu_clear(cpu, rcu_ctrlblk.state.rcu_cpu_mask);
+       if (cpus_empty(rcu_ctrlblk.state.rcu_cpu_mask)) {
+               /* batch completed ! */
</span>                //表示该宽限期结束
<span class="gi">+               rcu_ctrlblk.batch.completed = rcu_ctrlblk.batch.cur;
+               rcu_start_batch(0);
</span>        }
<span class="gd">-       /* Can't change, since spin lock held. */
-       active = nohz_cpu_mask;
-       cpus_complement(active);
-       cpus_and(rcu_ctrlblk.rcu_cpu_mask, cpu_online_map, active);
</span> }
</pre></table></code></div></div></ol><p>所以经过该改动后，在每个宽限期内, 每个cpu 只会读写各一次<code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>. 大大 减少了cacheline trash</p><p>这种级别的优化真是赏心悦目。作者在随后的patch中又对这块流程做了优化:</p><h2 id="reduce-unnecessary-rcu_start_batch1"><span class="me-2">reduce unnecessary rcu_start_batch(1)</span><a href="#reduce-unnecessary-rcu_start_batch1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>经过上面的改动, 每当cpu发现其要发起一个宽限期时 就会做如下动作:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">RCU_batch</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">batch</span><span class="p">.</span><span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">rcu_start_batch</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_ctrlblk</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></table></code></div></div><p>但是可能也有很多cpu同时发要发起一个新的宽限期，于是大家就串行的获取 <code class="language-plaintext highlighter-rouge">rcu_ctrblk.state.mutex</code>, 并且执行<code class="language-plaintext highlighter-rouge">rcu_start_batch()</code>。但是呢, 在 <code class="language-plaintext highlighter-rouge">rcu_start_batch()</code> 因为当前宽限期未完成，几乎什么都不做。</p><p>作者在想，能不能判断下现在是不是有宽限期正在pending，如果没有再发起一个新的宽限 期。作者的本意是, 直接使用<code class="language-plaintext highlighter-rouge">seqcount</code> 机制确保<code class="language-plaintext highlighter-rouge">cur, next_pending</code>两个值获取的一 致性:</p><details> <summary>代码变动展开</summary><p><strong>reader改动</strong> :</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="p">@@ -268,10 +272,19 @@</span> static void rcu_process_callbacks(unsigned long unused)
                /*
                 * start the next batch of callbacks
                 */
<span class="gd">-               spin_lock(&amp;rcu_ctrlblk.state.mutex);
-               RCU_batch(cpu) = rcu_ctrlblk.batch.cur + 1;
-               rcu_start_batch(1);
-               spin_unlock(&amp;rcu_ctrlblk.state.mutex);
</span><span class="gi">+               do {
+                       seq = read_seqcount_begin(&amp;rcu_ctrlblk.batch.lock);
+                       /* determine batch number */
+                       RCU_batch(cpu) = rcu_ctrlblk.batch.cur + 1;
+                       next_pending = rcu_ctrlblk.batch.next_pending;
+               } while (read_seqcount_retry(&amp;rcu_ctrlblk.batch.lock, seq));
+
+               if (!next_pending) {
+                       /* and start it/schedule start if it's a new batch */
+                       spin_lock(&amp;rcu_ctrlblk.state.mutex);
+                       rcu_start_batch(1);
+                       spin_unlock(&amp;rcu_ctrlblk.state.mutex);
+               }
</span></pre></table></code></div></div><p><strong>writer改动</strong> :</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="gh">diff --git a/kernel/rcupdate.c b/kernel/rcupdate.c
index d665d001e03..dc1ac448d07 100644
</span><span class="gd">--- a/kernel/rcupdate.c
</span><span class="gi">+++ b/kernel/rcupdate.c
</span><span class="p">@@ -47,7 +47,7 @@</span>
<span class="err">
</span> /* Definition for rcupdate control block. */
 struct rcu_ctrlblk rcu_ctrlblk =
<span class="gd">-       { .batch = { .cur = -300, .completed = -300 },
</span><span class="gi">+       { .batch = { .cur = -300, .completed = -300 , .lock = SEQCNT_ZERO },
</span>          .state = {.mutex = SPIN_LOCK_UNLOCKED, .rcu_cpu_mask = CPU_MASK_NONE } };
 DEFINE_PER_CPU(struct rcu_data, rcu_data) = { 0L };
<span class="err">
</span><span class="p">@@ -124,16 +124,18 @@</span> static void rcu_start_batch(int next_pending)
        cpumask_t active;
<span class="err">
</span>        if (next_pending)
<span class="gd">-               rcu_ctrlblk.state.next_pending = 1;
</span><span class="gi">+               rcu_ctrlblk.batch.next_pending = 1;
</span><span class="err">
</span><span class="gd">-       if (rcu_ctrlblk.state.next_pending &amp;&amp;
</span><span class="gi">+       if (rcu_ctrlblk.batch.next_pending &amp;&amp;
</span>                        rcu_ctrlblk.batch.completed == rcu_ctrlblk.batch.cur) {
<span class="gd">-               rcu_ctrlblk.state.next_pending = 0;
</span>                /* Can't change, since spin lock held. */
                active = nohz_cpu_mask;
                cpus_complement(active);
                cpus_and(rcu_ctrlblk.state.rcu_cpu_mask, cpu_online_map, active);
<span class="gi">+               write_seqcount_begin(&amp;rcu_ctrlblk.batch.lock);
+               rcu_ctrlblk.batch.next_pending = 0;
</span>                rcu_ctrlblk.batch.cur++;
<span class="gi">+               write_seqcount_end(&amp;rcu_ctrlblk.batch.lock);
</span>        }
 }
</pre></table></code></div></div></details><p>但是真的有必要这样搞么? 可能有两种潜在的故障需要避免:</p><ul><li>设置<code class="language-plaintext highlighter-rouge">cur</code>错误，导致设置不符合自己的宽限期版本?<li>丢失宽限期发起</ul><p>首先我们来想下第一个可能性。<code class="language-plaintext highlighter-rouge">cur</code>设置无非有两个版本:</p><ul><li>old_cur++(<code class="language-plaintext highlighter-rouge">new_cur</code>)<li>new_cur++(<code class="language-plaintext highlighter-rouge">++(++old_cur)</code>)</ul><p>其实设置哪个都可以，毕竟该cpu其实属于 <code class="language-plaintext highlighter-rouge">old_cur++</code>的宽限期版本，设置为<code class="language-plaintext highlighter-rouge">new_cur++</code> 无非是多等待一个宽限期.</p><p>那么下一种可能性是宽限期发起丢失，如果设置为了<code class="language-plaintext highlighter-rouge">new_cur</code> 不发起宽限期也不会有问题。 但是如果设置为<code class="language-plaintext highlighter-rouge">new_cur++</code>, 如果不执行<code class="language-plaintext highlighter-rouge">rcu_start_batch(1)</code>发起宽限期，可能会导致 <code class="language-plaintext highlighter-rouge">new_cur++</code>的宽限期不再发起. 而什么情况下不再发起呢 – 看到的<code class="language-plaintext highlighter-rouge">next_pending = 1</code> 那也就是得预防下看到下面的组合:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>new_cur + old_next_pending
</pre></table></code></div></div><p>这种情况下是还未读到next_pending的情况下，reader先看到了<code class="language-plaintext highlighter-rouge">new_cur</code>, 这其实是一个 memory order的问题，而为了避免这种情况, 那如果读写两端做哪些努力呢?</p><ul><li>reader: must read in order: cur, next_pending(必须先读 cur), 否则:<div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>reader                          writer
  <span class="nb">read </span>next_pending <span class="o">=</span>  1
                                update next_pending <span class="o">=</span> 0
                                update cur++
  <span class="nb">read</span> ++<span class="o">(</span>++<span class="o">(</span>cur<span class="o">))</span>
</pre></table></code></div></div><li>writer: must write in order: next_pending, cur(必须先写next_pending), 否则:<div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>reader                          writer
                                update cur++
<span class="nb">read</span> ++<span class="o">(</span>++<span class="o">(</span>cur<span class="o">))</span>
<span class="nb">read </span>next_pending <span class="o">=</span> 1
                                update next_pending <span class="o">=</span> 0
</pre></table></code></div></div></ul><p>所以通过合理添加内存屏障就可以规避上面的行为:</p><details> <summary>patch细节</summary><p>writer:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="p">@@ -185,10 +185,13 @@</span> static void rcu_start_batch(struct rcu_ctrlblk *rcp, struct rcu_state *rsp,
                        rcp-&gt;completed == rcp-&gt;cur) {
                /* Can't change, since spin lock held. */
                cpus_andnot(rsp-&gt;cpumask, cpu_online_map, nohz_cpu_mask);
<span class="gd">-               write_seqcount_begin(&amp;rcp-&gt;lock);
</span><span class="gi">+
</span>                rcp-&gt;next_pending = 0;
<span class="gi">+               /* next_pending == 0 must be visible in __rcu_process_callbacks()
+                * before it can see new value of cur.
+                */
+               smp_wmb();
</span>                rcp-&gt;cur++;
<span class="gd">-               write_seqcount_end(&amp;rcp-&gt;lock);
</span>        }
 }
</pre></table></code></div></div><p>reader:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="p">@@ -330,14 +331,15 @@</span> static void __rcu_process_callbacks(struct rcu_ctrlblk *rcp,
                /*
                 * start the next batch of callbacks
                 */
<span class="gd">-               do {
-                       seq = read_seqcount_begin(&amp;rcp-&gt;lock);
-                       /* determine batch number */
-                       rdp-&gt;batch = rcp-&gt;cur + 1;
-                       next_pending = rcp-&gt;next_pending;
-               } while (read_seqcount_retry(&amp;rcp-&gt;lock, seq));
-
-               if (!next_pending) {
</span><span class="gi">+
+               /* determine batch number */
+               rdp-&gt;batch = rcp-&gt;cur + 1;
+               /* see the comment and corresponding wmb() in
+                * the rcu_start_batch()
+                */
+               smp_rmb();
+
+               if (!rcp-&gt;next_pending) {
</span>                        /* and start it/schedule start if it's a new batch */
                        spin_lock(&amp;rsp-&gt;lock);
                        rcu_start_batch(rcp, rsp, 1);
</pre></table></code></div></div></details><h2 id="还有高手"><span class="me-2">还有高手?</span><a href="#还有高手" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>即便是做了上面的优化, <code class="language-plaintext highlighter-rouge">rcu_cpu_mask</code>仍然会有可扩展性的问题. 主要原因在于其变量在 多个cpu之间共享, 虽然上面的patch已经大大减少了访问次数, 但是, <code class="language-plaintext highlighter-rouge">clear(rcu_cpu_mask)</code> 在自旋锁下处理. 当临界区较小时，会造成严重的争用。</p><p><strong>TODO, 关于rcu 和CPU 节能, 之后分析</strong></p><h2 id="参考链接"><span class="me-2">参考链接</span><a href="#参考链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><a href="https://lwn.net/Articles/305782/">LWN: Hierarchical RCU</a></ol><h2 id="相关-commit"><span class="me-2">相关 commit</span><a href="#相关-commit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>Read-Copy Update infrastructure<ul><li>1477a825d7e6486a077608c7baf6abbb6f27ed95<li>Dipankar Sarma <a href="mailto:dipankar@in.ibm.com">dipankar@in.ibm.com</a><li>Tue Oct 15 05:40:46 2002 -0700</ul><li>percpu: convert RCU<ul><li>c12e16e28b4cf576840cff509caf0c06ff4dc299<li>Dipankar Sarma <a href="mailto:dipankar@in.ibm.com">dipankar@in.ibm.com</a><li>Tue Oct 29 23:31:27 2002 -0800<li><strong>DESC</strong>: This patch convers RCU per_cpu data to use per_cpu data area and makes it safe for cpu_possible allocation by using CPU notifiers.</ul><li>Hotplug CPUs: Read Copy Update Changes<ul><li>211b2fcef6366298877f1a8c0ba95d43db86ef85<li>Rusty Russell <a href="mailto:rusty@rustcorp.com.au">rusty@rustcorp.com.au</a><li>Thu Mar 18 16:03:35 2004 -0800</ul><li>s390: no timer interrupts in idle.<ul><li>1bd4c02c645161959a69be858ee1efc4d0273507<li>Martin Schwidefsky <a href="mailto:schwidefsky@de.ibm.com">schwidefsky@de.ibm.com</a><li>Mon Apr 26 09:00:52 2004 -0700</ul><li>rcu lock update: Add per-cpu batch counter<ul><li>5c60169a01af712b0b1aa1f5db3fcb8776b22d9f<li>Manfred Spraul <a href="mailto:manfred@colorfullife.com">manfred@colorfullife.com</a><li>Wed Jun 23 18:49:33 2004 -0700</ul><li>rcu lock update: Use a sequence lock for starting batches<ul><li>720e8a63908eb18aad1721c1429e89fbf7cf0ca6<li>Manfred Spraul <a href="mailto:manfred@colorfullife.com">manfred@colorfullife.com</a><li>Wed Jun 23 18:49:44 2004 -0700</ul><li>[PATCH] rcu: eliminate rcu_ctrlblk.lock<ul><li>a48d69a5c734ceedc04d351f394d428e032ca4b9<li>[PATCH] rcu: eliminate rcu_ctrlblk.lock<li>Tue Jan 4 05:30:36 2005 -0800</ul></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/os/">os</a>, <a href="/categories/synchronization/">synchronization</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/os/" class="post-tag no-text-decoration" >os</a> <a href="/tags/synchronization/" class="post-tag no-text-decoration" >synchronization</a> <a href="/tags/rcu/" class="post-tag no-text-decoration" >rcu</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=rcu%20-%20classic%20-%20Chirpy&url=%2Fposts%2Frcu-classic%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=rcu%20-%20classic%20-%20Chirpy&u=%2Fposts%2Frcu-classic%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Frcu-classic%2F&text=rcu%20-%20classic%20-%20Chirpy" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/rcu-hierarchical/">rcu - rcu hierarchical</a><li class="text-truncate lh-lg"> <a href="/posts/rcu-latency-optimization/">rcu - rcu latency optimization</a><li class="text-truncate lh-lg"> <a href="/posts/rcu-stall-dettection/">rcu - stalled grace peroiod detection</a><li class="text-truncate lh-lg"> <a href="/posts/seqcounter-and-seqlock/">sequence counters and sequential locks</a><li class="text-truncate lh-lg"> <a href="/posts/rcu-classic/">rcu - classic</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/synchronization/">synchronization</a> <a class="post-tag btn btn-outline-primary" href="/tags/os/">os</a> <a class="post-tag btn btn-outline-primary" href="/tags/rcu/">rcu</a> <a class="post-tag btn btn-outline-primary" href="/tags/spinlock/">spinlock</a> <a class="post-tag btn btn-outline-primary" href="/tags/tee/">tee</a> <a class="post-tag btn btn-outline-primary" href="/tags/completed/">completed</a> <a class="post-tag btn btn-outline-primary" href="/tags/mktme/">mktme</a> <a class="post-tag btn btn-outline-primary" href="/tags/non-blocking-algorithm/">non-blocking algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu/">qemu</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-coroutine/">qemu_coroutine</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/rcu-hierarchical/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1768308240" data-df="ll" > Jan 13, 2026 </time><h4 class="pt-0 my-2">rcu - rcu hierarchical</h4><div class="text-muted"><p>## NOTE ## 代码流程笔记 代码静态初始化 rcu_state: ```cpp struct rcu_state rcu_state = RCU_STATE_INITIALIZER(rcu_state); #define RCU_STATE_INITIALIZER(name) { \ //只初始化level[0] .level = { &name.node[0]...</p></div></div></a></article><article class="col"> <a href="/posts/rcu-latency-optimization/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1768227180" data-df="ll" > Jan 12, 2026 </time><h4 class="pt-0 my-2">rcu - rcu latency optimization</h4><div class="text-muted"><p>## overflow rcu callback 往往用来释放内存, 如果rcu callback调用的延迟比较高, 就会造成较高的 内存占用. 所以减少rcu callback的调用延迟也是一个很重要的优化方向。 ## ORG PATCH 在最初的版本中, `rcu_data`中存放了两个链表 * `rcu_data->nxtlist`: 调用`call_rcu()` 向该链表存放数...</p></div></div></a></article><article class="col"> <a href="/posts/rcu-stall-dettection/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1768183200" data-df="ll" > Jan 12, 2026 </time><h4 class="pt-0 my-2">rcu - stalled grace peroiod detection</h4><div class="text-muted"><p>1. rcu, debug: detect stalled grace periods + 67182ae1c42206e516f7efb292b745e826497b24 + Paul E. McKenney + Sun Aug 10 18:35:38 2008 -0700 2. rcu: RCU-based detection of stalled CPUs for ...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/tdx-spec/" class="btn btn-outline-primary" aria-label="Older" ><p>intel tdx (spec)</p></a> <a href="/posts/seqcounter-and-seqlock/" class="btn btn-outline-primary" aria-label="Newer" ><p>sequence counters and sequential locks</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://twitter.com/username">your_full_name</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.3.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/synchronization/">synchronization</a> <a class="post-tag btn btn-outline-primary" href="/tags/os/">os</a> <a class="post-tag btn btn-outline-primary" href="/tags/rcu/">rcu</a> <a class="post-tag btn btn-outline-primary" href="/tags/spinlock/">spinlock</a> <a class="post-tag btn btn-outline-primary" href="/tags/tee/">tee</a> <a class="post-tag btn btn-outline-primary" href="/tags/completed/">completed</a> <a class="post-tag btn btn-outline-primary" href="/tags/mktme/">mktme</a> <a class="post-tag btn btn-outline-primary" href="/tags/non-blocking-algorithm/">non-blocking algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu/">qemu</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-coroutine/">qemu_coroutine</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> (function () { const themeMapper = Theme.getThemeMapper('light', 'dark_dimmed'); const initTheme = themeMapper[Theme.visualState]; let lang = 'zh-CN';if (lang.length > 2 && !lang.startsWith('zh')) { lang = lang.slice(0, 2); } let giscusAttributes = { src: 'https://giscus.app/client.js', 'data-repo': 'cai-fuqiang/cai-fuqiang.github.io', 'data-repo-id': 'R_kgDOPsVm6A', 'data-category': 'Q&A', 'data-category-id': 'DIC_kwDOPsVm6M4C0OXB', 'data-mapping': 'pathname', 'data-strict' : '0', 'data-reactions-enabled': '1', 'data-emit-metadata': '0', 'data-theme': initTheme, 'data-input-position': 'top', 'data-lang': lang, 'data-loading': 'lazy', crossorigin: 'anonymous', async: '' }; let giscusNode = document.createElement('script'); Object.entries(giscusAttributes).forEach(([key, value]) => giscusNode.setAttribute(key, value) ); const $footer = document.querySelector('footer'); $footer.insertAdjacentElement("beforebegin", giscusNode); addEventListener('message', (event) => { if (event.source === window && event.data && event.data.id === Theme.ID) { const newTheme = themeMapper[Theme.visualState]; const message = { setConfig: { theme: newTheme } }; const giscus = document.getElementsByClassName('giscus-frame')[0].contentWindow; giscus.postMessage({ giscus: message }, 'https://giscus.app'); } }); })(); </script> <script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
