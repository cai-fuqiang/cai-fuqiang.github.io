<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="non-scalable VS scalable spinlock" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="自旋锁是一种会让尝试获取它的线程陷入循环 （“自旋”）并不断检查锁是否可用的锁 1。" /><meta property="og:description" content="自旋锁是一种会让尝试获取它的线程陷入循环 （“自旋”）并不断检查锁是否可用的锁 1。" /><link rel="canonical" href="/posts/non-scalable-vs-scalable-spinlock/" /><meta property="og:url" content="/posts/non-scalable-vs-scalable-spinlock/" /><meta property="og:site_name" content="Chirpy" /><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_end.svg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-12-26T11:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_end.svg" /><meta property="twitter:title" content="non-scalable VS scalable spinlock" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2025-12-26T11:00:00+08:00","datePublished":"2025-12-26T11:00:00+08:00","description":"自旋锁是一种会让尝试获取它的线程陷入循环 （“自旋”）并不断检查锁是否可用的锁 1。","headline":"non-scalable VS scalable spinlock","image":"https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_end.svg","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/non-scalable-vs-scalable-spinlock/"},"url":"/posts/non-scalable-vs-scalable-spinlock/"}</script><title>non-scalable VS scalable spinlock | Chirpy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chirpy"><meta name="application-name" content="Chirpy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/commons/avatar.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Chirpy</a><p class="site-subtitle fst-italic mb-0">A text-focused Jekyll theme</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/overflow/" class="nav-link"> <i class="fa-fw fas fa-star"></i> <span>OVERFLOW</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/github_username" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>non-scalable VS scalable spinlock</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>non-scalable VS scalable spinlock</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1766718000" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Dec 26, 2025 </time> </span><div class="mt-3 mb-3"> <a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_end.svg" class="popup img-link preview-img shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_end.svg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5516 words" > <em>30 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">non-scalable VS scalable spinlock</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">non-scalable VS scalable spinlock</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p>自旋锁是一种会让尝试获取它的线程陷入循环 （“自旋”）并不断检查锁是否可用的锁 <sup> 1</sup>。</p><p>和mutex 不同，mutex 可以睡眠，将cpu让渡给其他的程序，而自旋锁则是占据着cpu资源忙 等。忙等最主要的优点是，避免了调度所带来的上下文开销, 可以提升等锁进程获得锁的延 迟。另外，如果加锁的临界区很小，自旋锁忙等所带来的开销，可能会小于上下文切换的开 销，自旋锁的收益就会非常大。所以，自旋锁适用于临界区小的场景。</p><h2 id="overflow"><span class="me-2">overflow</span><a href="#overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>本文主要是来讲述, spinlock 的可伸缩性(scalable). 可扩展性是指系统处理不断增长的 工作量的能力。软件系统的可扩展性定义之一是，可以通过向系统添加资源来实现<sup> 2</sup>. 而对于spinlock而言, 如何增加其工作量呢？ <strong>增加并行调用spinlock的cpu数量</strong></p><p>在介绍之前我们先思考下，自旋锁和 “smp”, “up” 关系<sup>3</sup>。首先按照自旋锁的 逻辑，自旋锁的临界区是不能睡眠的，这个动作非常危险，容易造成死锁。所以 UP下(单 CPU) 自旋锁是没有意义的。</p><p>所以自旋锁是服务于smp的。而随着cpu的发展，cpu的核心越来越多, 并行调用spinlock的 数量也大大增加。而传统的spinlock则在 smp 场景中体现出了 non-scalable。</p><p>接下来的章节，我们首先介绍一些硬件背景，包括</p><ul><li>cache snoop method<li>cost of cache coherence</ul><p>而之后，便介绍因cache coherence 给spinlock带来的性能影响。最后，展示下scalable spinlock 带来的性能提升。</p><blockquote class="prompt-tip"><p>文本主要参考老黄和狗哥的文章<sup>4,5</sup> 以及<code class="language-plaintext highlighter-rouge">Non-scalable locks are dangerous</code> 论文<sup>6</sup>.</p></blockquote><h2 id="cache-coherence"><span class="me-2">cache coherence</span><a href="#cache-coherence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote class="prompt-warning"><p>关于cache coherence 很值得单独写一篇文章去总结( <strong>TODO</strong> ). 这里我们简单看下 <code class="language-plaintext highlighter-rouge">snoop-based coherence</code> non-scalable 问题。以及其改进版本 <code class="language-plaintext highlighter-rouge">directory-based coherence</code> 给spinlock 所带来的<code class="language-plaintext highlighter-rouge">non-scalable</code>问题。</p><p>本节内容(包括大量的图片) 均参考 <code class="language-plaintext highlighter-rouge">CMU 15-418/618 lecture</code><sup>7, 8</sup></p></blockquote><p>为了降低cpu访问内存的延迟, 在cpu 和 内存之间加了一层cache。但是在smp架构下，每个 cpu都有自己的cache，所以相当于<code class="language-plaintext highlighter-rouge">main memory</code> 所存储的数据在各个cpu上都有了副本。 这回带来一致性问题。而cpu硬件实现了一套无需软件参与的缓存一致性协议，用来维护各 个 cpu cache之间以及和主存之间的一致性。</p><p>在早期的实现中，cpu数量不多。cache一致性使用<code class="language-plaintext highlighter-rouge">snoop-based</code>的方式，该方式的特点是 广播，而随着cpu数量越来越多，尤其是NUMA架构的兴起，广播的代价越来越大， <code class="language-plaintext highlighter-rouge">snoop-based</code>方式则变得<code class="language-plaintext highlighter-rouge">non-scalable</code>. 于是大佬们搞出了非广播的点对点的 <code class="language-plaintext highlighter-rouge">directory-based coherence</code>一致性协议。</p><h3 id="snoop-based"><span class="me-2">snoop based</span><a href="#snoop-based" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/MESI_state_transition_digram.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/MESI_state_transition_digram.png" alt="MESI_state_transition_digram" loading="lazy"></a></p><p><code class="language-plaintext highlighter-rouge">snoop-based coherence</code> 是在缓存状态改变时，通过广播MESI 消息来维护各个cpu.</p><p>图中状态左侧部分表示，当前cpu 发起访存动作是要做的一些动作(包括发一些广播信号, 以 及置当前cacheline的状态)。而图中右侧则表示 cpu 被动的收到广播信号时, 所需要执行 的动作（包括置cacheline状态以及一些额外的动作, E.g. flush).</p><p>我们举一个例子，不展开各个状态。</p><p>如果当前cpu要write一个内存，该内存所对应的cache是 invalid(对应右侧<code class="language-plaintext highlighter-rouge">I-&gt;M</code>)</p><p>该cpu需要</p><ul><li>发起<code class="language-plaintext highlighter-rouge">BusRdx</code> 消息广播. (<code class="language-plaintext highlighter-rouge">BuxRdx</code> 表示一次写广播请求, 表示当前有人要写该 cacheline, 这里有一些<code class="language-plaintext highlighter-rouge">serialization</code>的问题这里不展开)<li>将该内存地址对应的cacheline的状态由 <code class="language-plaintext highlighter-rouge">I -&gt; M</code><li>执行<code class="language-plaintext highlighter-rouge">PrWr</code>(<code class="language-plaintext highlighter-rouge">PrWr</code>表示cpu发起写操作，可以理解为改cacheline的内容了)</ul><p>而其他cpu收到<code class="language-plaintext highlighter-rouge">BusRdx</code>后需要</p><ul><li>将cacheline状态修改<code class="language-plaintext highlighter-rouge">X-&gt;I</code>(<code class="language-plaintext highlighter-rouge">X</code>为<code class="language-plaintext highlighter-rouge">M, E, S</code> 任意状态)<li>如果是M状态, 可能还要执行<code class="language-plaintext highlighter-rouge">flush</code>动作.(这里有一些序列化的问题, 例如这个flush 的动作要不要发生发起写操作的cpu的PrWr 之前)</ul><hr /><p><code class="language-plaintext highlighter-rouge">snoop-based</code> non-scalable 原因主要来自广播。每次cache miss(invalid)发生时，需要通知 其他所有的cache。而在numa架构下这个问题更为突出。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/numa-system-example.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/numa-system-example.png" alt="numa-system-example" loading="lazy"></a></p><p>在numa架构下，软件尽可能的设计成numa亲和性方案，即让当前numa上cpu运行的程序，访 问该numa的内存，但是由于 <code class="language-plaintext highlighter-rouge">snoop-based conherence</code> 的存在, 当我们访问<code class="language-plaintext highlighter-rouge">near memory</code>时 还是需要向所有的cpu进行广播, 这导致软件层面的优化几乎不起作用。</p><p>于是大佬们在思考能不能不再广播，而是通过点对点的方式，向特定的cpu发送cache y conherence 消息。而这就需要一个数据库，记录cache在各个cpu中的状态，从而辅助 发起消息的cpu选择向哪些cpu发送。</p><h3 id="directory-based"><span class="me-2">directory-based</span><a href="#directory-based" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>既然需要一个数据库，我们则维护一个名为directory 的database:</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/very-simple-directory.png" class="popup img-link w-75 left shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/very-simple-directory.png" alt="very-simple-directory" loading="lazy"></a> 每个内存 在directory中维护了一个条目，每一个条目包括:</p><ul><li><strong><em>Dirty bit</em></strong>: 表示在某个cpu-cache中。其缓存是dirty的。<li>$p$ <strong><em>presence bit</em></strong>: 这是一个数组，每个字节表示该内存在其代表的cpu cache中 是否存在</ul><p><br /> <br /> <br /></p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/l3_cache_back.png" class="popup img-link w-50 right shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/l3_cache_back.png" alt="l3_cache_back" loading="lazy"></a> directory存在于L3 缓存组中(可能哈, 个人认为将l3当成了一个directory，该缓存条目中 除了包括常规的缓存信息外，还包括了和 directory 相关的信息。个人瞎猜).</p><p>我们来看下两个场景, read miss to dirty line 和write miss(这对应于竞争较激烈的 spinlock场景)</p><h4 id="read-miss-to-dirty-line"><span class="me-2">read miss to dirty line</span><a href="#read-miss-to-dirty-line" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/read_miss_to_dirty_line_part1.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/read_miss_to_dirty_line_part1.png" alt="read_miss_to_dirty_line_part1" loading="lazy"></a></p><p><strong>初始状态</strong></p><ul><li>cpu 0 要访问 near cpu 1 memory<li>cpu 0 中没有cache, directory entry dirtybit 为1<li>cpu2 中有该地址的cache, 并且没有writeback, directory entry $p$ 中有 cpu 2</ul><p>执行步骤:</p><ol><li>(步骤1)cpu 0 发起一个<code class="language-plaintext highlighter-rouge">read miss msg</code>的request.<li>(步骤2)对应的memory 的 directory 查询其该条目中的 $p$ array, 查到cpu 2。并返 回消息给 cpu0</ol><hr /><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/read_miss_to_dirty_line_part2.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/read_miss_to_dirty_line_part2.png" alt="read_miss_to_dirty_line_part2" loading="lazy"></a></p><ol><li>(步骤3) cpu0 向cpu2 请求缓存内容<li>(步骤4) cpu2 返回给cpu0</ol><hr /><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/read_miss_to_dirty_line_part3.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/read_miss_to_dirty_line_part3.png" alt="read_miss_to_dirty_line_part3" loading="lazy"></a></p><ul><li><p>(步骤5) cpu2 返回给cpu1, dir的变更信息包括:cpu 0 请求了该cacheline，所以 $p$中 要置位 cpu0 bit</p><p>另外, 将dirty data 也传递到cpu1, cpu1 收到后，将dirty data flush 到memory, 并 clear dirty bit</p></ul><blockquote class="prompt-info"><p>non-scalable spinlock 的问题主要就在这一过程中，我们在之后的后面的章节中展开</p></blockquote><p>我们接下来看下write miss</p><h4 id="write-miss"><span class="me-2">write-miss</span><a href="#write-miss" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part1.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part1.png" alt="write_miss_part1" loading="lazy"></a></p><p><strong>初始状态</strong></p><ul><li>cpu0 要写 near cpu 1 memory<li>cpu0 没有cache，directory entry dirtybit为0<li>cpu0 没有cache, cpu1, cpu2 上有clean cache, $p$ 中有 cpu1, cpu2</ul><p>执行步骤:</p><ul><li>(步骤1) cpu0 向directory 发 write miss msg</ul><hr /><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part2.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part2.png" alt="write_miss_part2" loading="lazy"></a></p><ul><li>(步骤2) 由于cache 是clear的, directory 直接将clear data + ids 返回给cpu0<li>directory 修改 $p$ <code class="language-plaintext highlighter-rouge">clean {0, 1, 1}</code> –&gt; <code class="language-plaintext highlighter-rouge">dirty {1, 0, 0}</code></ul><hr /><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part3.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part3.png" alt="write_miss_part3" loading="lazy"></a></p><ul><li>(步骤3) cpu0 向cpu1, 2发送 invalid msg 消息</ul><hr /><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part4.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/write_miss_part4.png" alt="write_miss_part4" loading="lazy"></a></p><ul><li>(步骤4) cpu1, cpu2 发送ack 给cpu0</ul><hr /><blockquote class="prompt-info"><p>其实这个过程性能并不低，因为这是一个一对多，并且允许每个点对点的<code class="language-plaintext highlighter-rouge">{request, response}</code> 可以异步执行。但是这是一个触发器，其在spinlock过程中会将其他cpu的cache line invalid。 其他cpu 会如果再访问该内存会执行<code class="language-plaintext highlighter-rouge">read miss</code>流程…</p></blockquote><blockquote class="prompt-tip"><p>文章<sup>4, 5</sup>介绍缓存一致性时，从<code class="language-plaintext highlighter-rouge">write-update</code>, <code class="language-plaintext highlighter-rouge">write-invalid</code>角度展开 两个缓存一致性协议，个人查找资料发现<code class="language-plaintext highlighter-rouge">write-update</code>似乎不在主流的缓存一致性实现中 <sup>9</sup></p><p>大家可以设想下，<code class="language-plaintext highlighter-rouge">write-update</code>一个好处是，在write操作发起时，会将cache 更新到 其他的缓存中，而不是让其失效。这样其他cpu 后续访问该缓存时，可以直接从当前 cpu local cache 中获取到干净的（而不是从主存)。</p><p>但是只update 不invalid 会有明显的问题，因为被update 的cpu可能很长一段时间不会访问 该cache，而这段时间内如果有cpu write 这个地址，都会update 该cpu的cache。这会 造成很大的浪费。而基于 invalid 协议，会在写操作时invalid，在read时 触发cache-miss, <strong>同时，也会从其他cpu的缓存中获取数据而不是直接从缓存获取</strong>, 总之，这种在 read-miss时按需获取再搭配 directory-based conherence 协议看起来比简单的 write-update 协议优秀很多。(当然可能cpu有一些更高级的预测功能，可以知道其他cpu可能在短时间 内需要访问这个cache(例如预取等等), 此时带宽又很空闲，会去做write-update? 但这远远 超出了我的知识范畴，也远远超出了本文要讲述的知识的范畴)</p><p>总之综上所述，本文接下来关于所有的cache conherence, 都不考虑write update, 均以write invalid 为例.</p></blockquote><p>ok, 关于cache conherence 这个基础而又宏大的话题就再此戛然而止吧。我们来简单总结 下:</p><h3 id="总结"><span class="me-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">snoop-based conherence</code>在核非常多(尤其在numa架构下)面临着<code class="language-plaintext highlighter-rouge">non-scalable</code>的问题， 其主要的问题在于 <code class="language-plaintext highlighter-rouge">MESI</code>的各个消息都需要采用广播的机制。为了解决这一问题, 大佬们搞出了<code class="language-plaintext highlighter-rouge">directory-based conherence</code>，其通过点对点的方式，按需和某些cpu 消息 通信。</p><p>但是, 在某些场景下，这仍然造成了<code class="language-plaintext highlighter-rouge">non-scalable</code>的问题。</p><h2 id="non-scalable-spinlock"><span class="me-2">non-scalable spinlock</span><a href="#non-scalable-spinlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>How to cause non-scalable</strong></p><p>来设想下: <code class="language-plaintext highlighter-rouge">non-scalable</code> 一般是怎么出现的。往往是在资源扩张后(例如cpu数量), 执行 一些操作时，这些操作的复杂度往往会随着资源扩张线性增长。</p><p>而 <em>spinlock</em> 尤为突出，因为spinlock这种阻塞忙等性质的同步机制不仅会影响发起慢操 作的cpu运行，而且由于其阻塞性质，会影响全局的进度。</p><p>在介绍具体的触发机制之前，我们先来看下 non-scalable spinlock的实现方式</p><h3 id="non-scalable-spinlock-implementation"><span class="me-2">non-scalable spinlock implementation</span><a href="#non-scalable-spinlock-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="wild-spinlock"><span class="me-2">wild spinlock</span><a href="#wild-spinlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>wild</strong> 的意思是<code class="language-plaintext highlighter-rouge">粗暴, 未经训化的意思</code>, 俗称原始人。我们也用比较原始的汇编 指令展现其简介性:</p><p><strong>lock 代码</strong></p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>lock:
    .long 0              <span class="c"># 锁变量，初始为0</span>
spin_lock:
    movl <span class="nv">$1</span>, %eax        <span class="c"># eax = 1，表示“想要锁”</span>
spin_loop:
    xchgl %eax, <span class="o">[</span>lock]     <span class="c"># 原子交换 eax 和 lock</span>
    testl %eax, %eax     <span class="c"># 判断之前的 lock 是否为0</span>
    jne spin_loop        <span class="c"># 如果不为0，继续自旋</span>
    <span class="c"># 获取锁成功，继续执行临界区代码</span>
</pre></table></code></div></div><p><strong>unlock代码</strong>:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>spin_unlock:
    movl <span class="nv">$0</span>, lock            <span class="c"># 直接写0，释放锁</span>
</pre></table></code></div></div><p>但是 wild spinlock有个很大的问题。就是公平性。不同的cpu”看到”的<code class="language-plaintext highlighter-rouge">[lock]</code> 变为0的时间不同, 所以哪个核获取到锁充满了随机性。这种不公平性体现在 获取自旋锁的延迟极不稳定，而软件又往往期待平稳的延迟。</p><blockquote class="prompt-tip"><p>这个地方其实涉及同时发起atomic操作的串性执行的仲裁问题。这个仲裁是 有谁来做的，是如何排序pending的atomic操作。这些知识在本人的知识储备 外，代后续补充.</p></blockquote><p>于是 <strong>ticket spinlock</strong> 闪亮登场。</p><h4 id="ticket-spinlock"><span class="me-2">ticket spinlock</span><a href="#ticket-spinlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>ticket spinlock</strong> 会让每个自旋锁的申请者记录自己的”号牌”, 然后等待叫号. 这个很 像显示中的 排号系统。大家从排号机顺序取号，叫号时也会按顺序。</p><p>简单的小程序如下<sup>5</sup>:</p><p>数据结构</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">spinlock_t</span> <span class="p">{</span>
    <span class="c1">// 上锁者自己的排队号</span>
    <span class="kt">int</span> <span class="n">my_ticket</span><span class="p">;</span>
    <span class="c1">// 当前叫号</span>
    <span class="kt">int</span> <span class="n">curr_ticket</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>加锁:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">my_ticket</span><span class="p">;</span>
    <span class="c1">// 顺位拿到自己的ticket号码；</span>
    <span class="n">my_ticket</span> <span class="o">=</span> <span class="n">atomic_inc</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">my_ticket</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">my_ticket</span> <span class="o">!=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">curr_ticket</span><span class="p">)</span>
        <span class="p">;</span> <span class="c1">// 自旋等待！</span>
<span class="p">}</span>
</pre></table></code></div></div><p>解锁:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">spin_unlock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 呼叫下一位！</span>
    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">curr_ticket</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="non-scalable-ticket-spinlock"><span class="me-2">non-scalable ticket spinlock</span><a href="#non-scalable-ticket-spinlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们以<code class="language-plaintext highlighter-rouge">ticket spinlock</code>为例来看下其在<code class="language-plaintext highlighter-rouge">directory-based conherence</code> 中 的non-scala.</p><p>按照ticket spinlock的设计, 当持有锁的cpu释放锁后，将会有一个确定的锁owner等待着 获取锁。但是按照前文提到的 <code class="language-plaintext highlighter-rouge">directory-based conherence</code>协议并不能第一时间让 这个确定的cpu看到，这就是矛盾所在。</p><p>我们来画图说明:</p><h4 id="初始状态"><span class="me-2">初始状态</span><a href="#初始状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/hold_spinlock.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/hold_spinlock.svg" alt="hold_spinlock.svg" loading="lazy"></a></p><p>初始状态为 CPU0 持有自旋锁，CPU1, CPU2 等待自旋锁。CPU 0 已经持有了一段时间， 此时CPU1, CPU2 中的cache已经更新为最近更新的值。</p><h4 id="cpu0-解锁"><span class="me-2">CPU0 解锁</span><a href="#cpu0-解锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/unlock_spinlock_part1.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/unlock_spinlock_part1.svg" alt="unlock_spinlock_part1.svg" loading="lazy"></a></p><p>CPU0 准备释放自旋锁，首先请求 directory 查询哪些cpu中还有该地址的cache, 并要求directory做一些invalid操作。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/unlock_spinlock_part2.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/unlock_spinlock_part2.svg" alt="unlock_spinlock_part2.svg" loading="lazy"></a></p><p>directory clean掉这些cpu bit，并且标记该cache 为dirty. 另外directory 将信息返回 cpu0.</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/unlock_spinlock_part3.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/unlock_spinlock_part3.svg" alt="unlock_spinlock_part3.svg" loading="lazy"></a></p><p>CPU0 发起invalid cpu1, cpu2 该cache的请求。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/./pic/unlock_spinlock_part4.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/./pic/unlock_spinlock_part4.svg" alt="unlock_spinlock_part4.svg" loading="lazy"></a></p><p>CPU1, CPU2 返回该req处理完成。该cacheline已经被invalid</p><h4 id="cpu2-read-miss"><span class="me-2">CPU2 read-miss</span><a href="#cpu2-read-miss" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>此时cpu2 仍然在自旋</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="p">(</span><span class="n">my_ticket</span> <span class="o">!=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">curr_ticket</span><span class="p">)</span>
</pre></table></code></div></div><p>由于此时CPU0 在解锁过程中，将cpu 2的<code class="language-plaintext highlighter-rouge">lock-&gt;curr_ticket</code>更新了，cpu2的cacheline 被invalid，其读取会遇到 <code class="language-plaintext highlighter-rouge">read-miss</code>。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_part1.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_part1.svg" alt="get_spinlock_part1.svg" loading="lazy"></a></p><ul><li>cpu2 read-miss 需要向directory 发起请求<li>directory 告诉cpu2这个cacheline 是 dirty 的，最新的数据在cpu0<li>CPU2 向CPU0请求最新数据</ul><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_part2.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_part2.svg" alt="get_spinlock_part2.svg" loading="lazy"></a></p><p>CPU0 将最新的数据返回 <a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_part3.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_part3.svg" alt="get_spinlock_part3.svg" loading="lazy"></a></p><p>CPU0 请求directory 将请求flush cache(writeback)并请求更新ids(将CPU2 bit置位)</p><h4 id="if-cpu2-not-own-the-update-curr_ticket"><span class="me-2">if cpu2 not own the update curr_ticket</span><a href="#if-cpu2-not-own-the-update-curr_ticket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>如果CPU2 没有持有更新后的<code class="language-plaintext highlighter-rouge">curr_ticket</code>, 此时cpu2 仍然会自旋，而其他的cpu也会重复 cpu2 的流程，但是如果cpu特别多的话，directory 处理消息则会是瓶颈（假设directory 处理消息为串行).</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_end.svg" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/get_spinlock_end.svg" alt="get_spinlock_end.svg" loading="lazy"></a></p><p>见上图, CPU (0-&gt;9) 都自旋 <code class="language-plaintext highlighter-rouge">curr_ticket</code>, CPU5 是当前ticket的owner但是CPU5 “看到” 该cacheline的更新比较晚（接收到CPU 0 invalid REQ比较慢, 或者因为其他的一些原因) 导致其在directory 中排队比较靠后，所以在CPU5 即便是发出了 <code class="language-plaintext highlighter-rouge">read-miss</code> 相关的消息 后，也会延迟一段时间，等待directory 处理完前面排队的消息。参与wait spinlock的cpu 越多，该延迟越明显。</p><h3 id="总结-1"><span class="me-2">总结</span><a href="#总结-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>本段用前面讲述的<code class="language-plaintext highlighter-rouge">directory-based cache conherence</code>协议 描述了ticket spinlock 在多核架构下的<code class="language-plaintext highlighter-rouge">non-scalable</code> 的底层原因。其原因主要是在消息通信过程中，会不可 避免的发生多对一的消息通信，导致”一”这一侧的处理成为了瓶颈。</p><p>接下来的章节我们将看下大佬们在 Linux kernel 侧的一些实践，将看到 non-scalable spinlock 是多么可怕么，并用数学方法解释相关现象。</p><h2 id="non-scalable-lock-are-dangerous"><span class="me-2">non-scalable lock are dangerous</span><a href="#non-scalable-lock-are-dangerous" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote class="prompt-ref"><p>NOTE</p><p>本文主要是参照<sup>6</sup></p></blockquote><p>在实践过程中，大佬们发现system throughput(系统吞吐)会因non-scalable lock突然崩溃。例如，在系统在25 个核心的cpu 上运行的良好，但是在30个核心 CPU上运行却完全崩溃. 并且令人惊讶的是，造成崩溃的原因居然可以 <strong>临界区非常小</strong> 的锁。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/sudden_perf_collapse_with_ticket_locks.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/sudden_perf_collapse_with_ticket_locks.png" alt="sudden_perf_collapse_with_ticket_locks" loading="lazy"></a></p><p>上图中的曲线有一些共同点，均是当Cpu和增长到一定的数量后，再增长几个核就会出现 极具的性能下降。</p><p>下图是各个负载的具体情况（其中EXIM, 是临界区特别小的场景)。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/Figure_3.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/Figure_3.png" alt="Figure_3" loading="lazy"></a></p><p>文中提出了几个问题:</p><ul><li>为什么崩溃会如此早的开始 (例如FOPS 居然在3，4个核心就出发崩溃 )。<li>为什么性能会最终会大幅下降。<li>为什么性能会迅速下降。</ul><p>为了解释上面这些问题，文中建立了马可夫链(<code class="language-plaintext highlighter-rouge">Markov chain</code>)模型。</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/Markov_chain_model.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/Markov_chain_model.png" alt="Markov_chain_model" loading="lazy"></a></p><p>一共有 $0, 1, 2, …. n$ 即$n + 1$个状态, $k$ 表示系统中共有 $k$ 个cpu在等待自旋 锁解锁。$A[k]$ 表示 状态从 $k$ 转换到 $k+1$ 的频率。(加锁的频率, 但是注意并不是 一个cpu申请锁的频率，而是 系统中共有$k$ 个等锁cpu到 $k+1$ 个等锁cpu的频率)。 而 $S[k]$</p><p>我们定义 $a$ 为单个核心上连续两次获取锁之间的平均时间。在没有竞争的情况下，单个 核心尝试获取锁的速率为 $\frac{1}{a}$, 因此，如果已有 k 个核心在等待锁，则新竞争 者的到达率为 $(n − k)/a$.( $n-k$ 增在从不等待自旋锁到等待自旋锁的状态，每个cpu的 频率为 $1/a$, 所以两者相乘). 因此图中的 $a[k]$为:</p>\[A[k] = \frac{n-k}{a} \tag{1}\]<p>我们再关注下解锁阶段: $S[k]$ 。我们将 $S[k]$ 阶段所消耗的时间分为两部分，一部分 是临界区代码所消耗的时间, 记做$E$, 另一部分是$unlock$操作消耗的时间，记做 $R$。</p><p>根据我们上面讲的 <code class="language-plaintext highlighter-rouge">directory-based cache conherence</code>的简单模型，在解锁阶段有一些 流程需要是串行的。所以我们假设处理一个更新核心的cache所消耗时间为 $c$, 那么 $k$ 个核在等待相同自旋锁的情况下，将所有核的cache更新需要的时间为 $k \times c$, 但是 先处理哪个cpu，这个是随机的，所以<code class="language-plaintext highlighter-rouge">curr_ticket owner</code> cache 更新时间取个这些cpu更新 时间的平均值 $k \times c /2$, 那么可得:</p>\[S[k]=\dfrac{1}{E+\dfrac{k×c}{2}} \tag{2}\]<p>可以看到 $S[k]$ 和$k$ 是成反比的关系。核心越多，更新cacheline的cost越高。</p><p>有了上面基本的结论，搭配下面一个稳态 Markov chain 状态转换率守恒的基本原则，即可 导出模型本身：</p><p>假設 $P_0, P_1, P_2, … P_n$ 系统处在这 $n$ 个状态的机率，显然 \(\sum P_k=1 \tag{3}\)</p><p>当系统处在稳态时，下方式子成立：</p>\[P_k \times A[k] = P_{k+1} \times S[k]\]<p>这时一个递推, 结合<code class="language-plaintext highlighter-rouge">(1), (2), (3)</code>可以求出 $P_k$ 关于 $k$ 的表达式:</p>\[P_k = \dfrac{\frac{1}{T_{arrive}^k(n-k)!}\prod_{i=1}^k (E+ic)}{\sum_{i=0}^{n}\frac{1}{T_{arrive}^i(n-i)!}\prod_{j=1}^i (E+jc)}\]<p>有了上面的公式，我们可以求出任意时刻整个系统等待自旋锁状态的CPU总量: （<code class="language-plaintext highlighter-rouge">有1个cpu 等锁概率 * 1 + 有两个cpu等锁概率 * 2 + ... + 有n个cpu等锁 * n</code>)</p>\[C = \sum_{i=0}^{n}iP_i\]<p>我们定义一个加速比的该你那，即在 $x$ 个cpu争抢 spinlock 时，有多少cpu未处于自旋锁 等锁的状态.</p>\[S=x - C\]<p>下图是作者使用上面公式得到的推测值以及实际测试过程中得到的数据的对比图:</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/MK_chain_predict_and_real_cmp.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/MK_chain_predict_and_real_cmp.png" alt="MK_chain_predict_and_real_cmp" loading="lazy"></a></p><p>可以发现两者较为重合。</p><blockquote class="prompt-info"><p>NOTE</p><p>上面公式本人未推导。均参考论文<sup>6</sup>以及狗哥文章<sup>4,5</sup></p></blockquote><h2 id="scalable-spinlock"><span class="me-2">scalable spinlock</span><a href="#scalable-spinlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote class="prompt-warning"><p>NOTE</p><p>本文不讨论scalable spinlock的具体实现。关于这部分我们在另外一篇文章 介绍内核qspinlock的实现.</p></blockquote><p>论文中提到了几种scalable spinlock并对这些锁做了性能测试.</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/diff_scalable_spinlock_perf.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/diff_scalable_spinlock_perf.png" alt="diff_scalable_spinlock_perf" loading="lazy"></a></p><p>其中MCS和 CLH lock性能较好。</p><p>另外，作者还对比了 <code class="language-plaintext highlighter-rouge">MCS vs ticket spinlock</code>在上面提到的四种场景下的性能对比 :</p><p><a href="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/mcs_vs_ticket_spinlock.png" class="popup img-link shimmer"><img src="https://cdn.jsdelivr.net/gh/cai-fuqiang/cai-fuqiang.github.io@myblob_master/_posts/synchronization/spinlock/history_of_scalable_spinlock/pic/mcs_vs_ticket_spinlock.png" alt="mcs_vs_ticket_spinlock" loading="lazy"></a></p><p>均取得了良好的效果。</p><blockquote class="prompt-tip"><p>NOTE</p><p>有小伙伴可能不理解为什么采用<code class="language-plaintext highlighter-rouge">scalable spinlock</code>后仍然会导致性能吞吐量下降的问 题。但这并不是锁的消耗导致的。文章有一段介绍FOPS性能降低原因:</p><blockquote class="prompt-ref"><p>Figure 12(a) shows the performance of FOPS with MCS locks. Going from one to two cores, performance with both ticket locks and MCS locks increases. For more than two cores, performance with the ticket spin lock decreases continuously. Performance with MCS locks initially also decreases from two to four cores, then re- mains relatively stable. The reason for this decrease in performance is that the time spent executing the critical section increases from 450 cycles on two cores to 852 cycles on four cores. The critical section is executed multiple times per-operation and modifies shared data, which incurs costly cache misses. As more cores are added, it is less likely that a core will have been the last core to execute the critical section, and therefore it will incur more cache misses, which will increase the length of the critical section</p></blockquote><p>大概的意思是, 临界区中的代码会遇到较严重的cache miss, 核数越多，这种现象就越明 显(因为核数越多，下次运行到该核上的概率就越低)</p><p>另外大家可以想一下，即便是没有<code class="language-plaintext highlighter-rouge">cache-miss</code> 核数一直增长性能就会一直增长么?</p><p>答案是肯定不是，因为这些程序并不全是完全并行的，要不就不会用到spinlock来保护 临界区。因为临界区的存在导致一部分流程必须串行。临界区越大的这种现象越明显。 而在结合临界区中因cache-miss而变长的情况，所以上面的测试得到的结果往往会 性能平稳的略微下降。</p></blockquote><h2 id="结论"><span class="me-2">结论</span><a href="#结论" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">non-scalable spinlock</code> 会因 cache 一致性而造成非常严重的性能问题。通过替换<code class="language-plaintext highlighter-rouge">scalable spinlock</code>会大大缓解该问题。</p><h2 id="参考链接"><span class="me-2">参考链接</span><a href="#参考链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><a href="https://en.wikipedia.org/wiki/Spinlock">Wikipedia: Spinlock</a><li><a href="https://en.wikipedia.org/wiki/Scalability">Scalability</a><li><a href="https://zhuanlan.zhihu.com/p/584016727">深入理解Linux内核之自旋锁</a><li><a href="https://hackmd.io/@sysprog/linux-spinlock-scalability#Aliworkqueue">sysprog: 从CPU cache一致性的角度看Linux spinlock的不可伸缩性(non-scalable)</a><li><a href="https://blog.csdn.net/dog250/article/details/80589442">dog250: 从CPU cache一致性的角度看Linux spinlock的不可伸缩性(non-scalable)</a><li><a href="https://people.csail.mit.edu/nickolai/papers/boyd-wickizer-locks.pdf">Non-scalable locks are dangerous</a><li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15418-s21/www/lectures/11_cachecoherence1.pdf">Snooping-Based Cache Coherence</a><li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15418-s19/www/lectures/13_directory.pdf">Directory-Based Cache Coherence</a><li><a href="https://www.reddit.com/r/computerarchitecture/comments/1dovrky/cache_coherence_when_do_modern_cpus_update/">Cache Coherence - when do modern CPUs update invalidated cache lines</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/synchronization/">synchronization</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/synchronization/" class="post-tag no-text-decoration" >synchronization</a> <a href="/tags/spinlock/" class="post-tag no-text-decoration" >spinlock</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=non-scalable%20VS%20scalable%20spinlock%20-%20Chirpy&url=%2Fposts%2Fnon-scalable-vs-scalable-spinlock%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=non-scalable%20VS%20scalable%20spinlock%20-%20Chirpy&u=%2Fposts%2Fnon-scalable-vs-scalable-spinlock%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fnon-scalable-vs-scalable-spinlock%2F&text=non-scalable%20VS%20scalable%20spinlock%20-%20Chirpy" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/tdx-spec/">intel tdx (spec)</a><li class="text-truncate lh-lg"> <a href="/posts/rcu-overflow/">rcu - overflow</a><li class="text-truncate lh-lg"> <a href="/posts/intel-memory-encryption/">intel memory encryption technologies</a><li class="text-truncate lh-lg"> <a href="/posts/non-scalable-vs-scalable-spinlock/">non-scalable VS scalable spinlock</a><li class="text-truncate lh-lg"> <a href="/posts/non-blocking-algorithm/">non-blocking algorithm</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/synchronization/">synchronization</a> <a class="post-tag btn btn-outline-primary" href="/tags/spinlock/">spinlock</a> <a class="post-tag btn btn-outline-primary" href="/tags/tee/">tee</a> <a class="post-tag btn btn-outline-primary" href="/tags/completed/">completed</a> <a class="post-tag btn btn-outline-primary" href="/tags/mktme/">mktme</a> <a class="post-tag btn btn-outline-primary" href="/tags/non-blocking-algorithm/">non-blocking algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/os/">os</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu/">qemu</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-coroutine/">qemu_coroutine</a> <a class="post-tag btn btn-outline-primary" href="/tags/rcu-preliminaries/">rcu preliminaries</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/qspinlock/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1694397600" data-df="ll" > Sep 11, 2023 </time><h4 class="pt-0 my-2">qspinlock</h4><div class="text-muted"><p>简介 内核中的自旋锁是互斥锁。而内核中的自旋锁经过多个版本的演进， 最终是在 mcs 自旋锁 算法之上，根据kernel 本身的需求，作了改进。 我们这里不去回顾 Linux 自旋锁的历史，简单介绍下 mcs 自旋锁算法， 并详细讲解 kernel 中的 mcs自旋锁的变体。 NOTE 如果想要了解 kernel 自旋锁的演进，可以看下 深入理解Linux内核之自旋锁 ...</p></div></div></a></article><article class="col"> <a href="/posts/rcu-overflow/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1767011160" data-df="ll" > Dec 29, 2025 </time><h4 class="pt-0 my-2">rcu - overflow</h4><div class="text-muted"><p>## background > 本章节主要参考9 {: .prompt-info} 在介绍RCU之前，我们先来思考下，如何提升程序的性能? 一个最直接的方法是, 提升 并发量, 但是并发程序往往会造成多个线程(cpu) 访问同一个资源, 我们暂时先不考虑, 假设一个程序只有读者，每个读者都会去访问一个read-only list, 那么thread 数量和 吞吐关系图如下: ![rea...</p></div></div></a></article><article class="col"> <a href="/posts/non-blocking-algorithm/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1766628000" data-df="ll" > Dec 25, 2025 </time><h4 class="pt-0 my-2">non-blocking algorithm</h4><div class="text-muted"><p>在计算机科学中，如果任何线程的故障或挂起不会导致其他线程的故障或挂起，则称该算法 为非阻塞算法1。根据非阻塞算法的达到效果，可以分为两类: wait-free: if there is also guaranteed per-thread progress lock-free: if there is guaranteed system-wide progress Obstr...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/non-blocking-algorithm/" class="btn btn-outline-primary" aria-label="Older" ><p>non-blocking algorithm</p></a> <a href="/posts/intel-memory-encryption/" class="btn btn-outline-primary" aria-label="Newer" ><p>intel memory encryption technologies</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://twitter.com/username">your_full_name</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.3.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/synchronization/">synchronization</a> <a class="post-tag btn btn-outline-primary" href="/tags/spinlock/">spinlock</a> <a class="post-tag btn btn-outline-primary" href="/tags/tee/">tee</a> <a class="post-tag btn btn-outline-primary" href="/tags/completed/">completed</a> <a class="post-tag btn btn-outline-primary" href="/tags/mktme/">mktme</a> <a class="post-tag btn btn-outline-primary" href="/tags/non-blocking-algorithm/">non-blocking algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/os/">os</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu/">qemu</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-coroutine/">qemu_coroutine</a> <a class="post-tag btn btn-outline-primary" href="/tags/rcu-preliminaries/">rcu preliminaries</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> (function () { const themeMapper = Theme.getThemeMapper('light', 'dark_dimmed'); const initTheme = themeMapper[Theme.visualState]; let lang = 'zh-CN';if (lang.length > 2 && !lang.startsWith('zh')) { lang = lang.slice(0, 2); } let giscusAttributes = { src: 'https://giscus.app/client.js', 'data-repo': 'cai-fuqiang/cai-fuqiang.github.io', 'data-repo-id': 'R_kgDOPsVm6A', 'data-category': 'Q&A', 'data-category-id': 'DIC_kwDOPsVm6M4C0OXB', 'data-mapping': 'pathname', 'data-strict' : '0', 'data-reactions-enabled': '1', 'data-emit-metadata': '0', 'data-theme': initTheme, 'data-input-position': 'top', 'data-lang': lang, 'data-loading': 'lazy', crossorigin: 'anonymous', async: '' }; let giscusNode = document.createElement('script'); Object.entries(giscusAttributes).forEach(([key, value]) => giscusNode.setAttribute(key, value) ); const $footer = document.querySelector('footer'); $footer.insertAdjacentElement("beforebegin", giscusNode); addEventListener('message', (event) => { if (event.source === window && event.data && event.data.id === Theme.ID) { const newTheme = themeMapper[Theme.visualState]; const message = { setConfig: { theme: newTheme } }; const giscus = document.getElementsByClassName('giscus-frame')[0].contentWindow; giscus.postMessage({ giscus: message }, 'https://giscus.app'); } }); })(); </script> <script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
