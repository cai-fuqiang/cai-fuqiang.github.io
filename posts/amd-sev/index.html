<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="sev &amp;&amp; csv" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="本文是对1的高仿，但是劣质版本，非常建议去阅读下huangyong的文章" /><meta property="og:description" content="本文是对1的高仿，但是劣质版本，非常建议去阅读下huangyong的文章" /><link rel="canonical" href="/posts/amd-sev/" /><meta property="og:url" content="/posts/amd-sev/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-02-28T09:39:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="sev &amp;&amp; csv" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2025-02-28T09:39:00+08:00","datePublished":"2025-02-28T09:39:00+08:00","description":"本文是对1的高仿，但是劣质版本，非常建议去阅读下huangyong的文章","headline":"sev &amp;&amp; csv","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/amd-sev/"},"url":"/posts/amd-sev/"}</script><title>sev && csv | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>sev && csv</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>sev && csv</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1740706740" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 28, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="7605 words" > <em>42 min</em> read</span></div></div></div></header><div class="content"><blockquote><p>本文是对<sup>1</sup>的高仿，但是劣质版本，非常建议去阅读下huangyong的文章</p></blockquote><h2 id="背景"><span class="me-2">背景</span><a href="#背景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在云环境中有两类角色:</p><ul><li>platform owner : 云厂商<li>guest owner : 租用云厂商的用户</ul><p>云厂商负责提供云基础设施, 为用户构建出一套”属于自己的” 计算存储网络， 同时需要保证云基础设施足够优质来吸引用户。</p><p>而租户则是使用云厂商提供的云基础设施，来跑自己的业务，在云场景下， 租户只需要关心云环境中的业务，而无需关心云基础设施的层面的问题， 例如: 云主机的网络波动，硬件老化等等。</p><p>而云环境下的安全也是platform owner的一个重要服务，而guest owner，只能选择信任 云厂商提供的安全防护功能。但是, 总有防不住的时候，一旦platform owner的 的防线被击穿，其上面运行的guest都会有风险，而由于host有足够的权限，并且 其操作对于guest而言都是透明的，所以对于一些数据敏感的guest owner而言， 这种安全风险不能接受。</p><p>前面也提到, platform owner 也想提供更优质的服务来吸引用户。而安全防护也是 一个很重要的服务。但是软件防护总是限制的, 而能不能通过在硬件层面来保证， 在host 安全组件被击破后，还有一道硬件防线，可以防止guest不被攻击。AMD SEV 提供了该解决方案。</p><p>简单来说，AMD SEV 主要提供了一个隔离方案，让host无法观测到guest的行为， 同时提供给 guest 一些接口，可以让 guest 来验证，自己是跑在一个安全的 AMD SEV 环境。</p><p>另外, 对于提供sev功能的云厂商来说，既希望提供给用户这个功能，也希望 能像传统虚拟机一样管理sev虚拟机的生命周期. 例如:</p><ul><li>启动<li>关闭<li>迁移<li>快照</ul><h2 id="overflow"><span class="me-2">overflow</span><a href="#overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在介绍<code class="language-plaintext highlighter-rouge">SEV</code>之前, 我们先来看下传统虚拟机。</p><p>在传统架构中，有两个角色, Hypervisor和guest, Hypervisor, 几乎可以 访问虚拟机所有的位置的数据，还可以修改虚拟机运行上下文:</p><ul><li>MEMORY<li>REGISTER<li>DISK</ul><p>所以，在SEV中, 就是要限制Hypervisor的权限, 不能让host随意获取到guest 中运行的数据，甚至不能恶意模块修改. 最直接的方法就是数据加密.而在SEV 引入之前，AMD CPU支持通过SME功能来加密内存, SEV 则是在原有SME功能基础 上进行了进一步扩展, 通过虚拟机的VSID 作为keyid，来查找相关key，进行加密, 内存加密部分我们放在 <a href="">SME</a> 章节中介绍.</p><p>另外, guest需要一种方法可以确认，自己所处的环境是一个安全的, 可以 被信任的环境。AMD是通过证书链认证实现的, 这部分内容我们在<a href="">证书链</a> 章节中介绍。</p><p>而对于hypervisor来说，其负责管理guest的生命周期，资源分配. 而由于sev 在 guest 生命周期中附加了一些额外的操作，这些需要hypervisor 于sev fw交互, 所以需要一组API，这些API执行的时候需要一个通道. 这些内容我们放到API章节中 介绍, 并且在该章节中，我们会介绍部分API.</p><p>前面提到的主要是guest内存的加密，然而有这些是不够的, 仅能防住GUEST内存不被 host看到，但是不能防止host篡改，为了达到这种防护，AMD引入了SEV-SNP, 来实现 guest, host 内存隔离。而最后，我们也结合AMD SEV-SNP的原理，以及hygon CSV 代码，来猜测hygon CSV3 内存隔离的实现.</p><h2 id="sme"><span class="me-2">SME</span><a href="#sme" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Secure Encrypted Virtualization (SEV) 功能允许在VM运行期间，透明的 加解密内存，并且每个VM加解密时，可以使用他们独有的key(密钥)。实现方式 是在memory control 中实现一个高性能的加密模块，该加密模块可以编程多个密钥， 用来给不同的虚拟机使用。</p><p><img src="pic/SME_C_BIT.png" alt="SME_C_BIT" /></p><details> <summary>cache in SME, SEV</summary><p>在SME使能过程中，我们假设带C bit来访问内存，首先会从内存中获取秘文，然后由加密 模块解密，最终递交给CPU。但是，cache中是如何存储的呢?</p><p>实际上，cache中存储的是明文。所以，假设我们多次访问一个内存，后续的访问则会从 cache中直接获取，而并非从内存中获取秘文再解密。</p><p>但是，这实际上引入了一个问题，C-bit是存储在Page Table中。而我们完全可以建立两个 映射，一个带有C bit, 一个不带有C bit，如下图所示:</p><p><img src="./pic/SME_cache_for_diff_c_bit.svg" alt="SME_cache_for_diff_c_bit" /></p><p>这样的话，cache缓存的究竟是明文还是秘文呢? 假设我们都要存储的话，是不是会遇到重名 的问题。</p><p>AMD工程师采用了一个非常聪明的做法, 将虚拟地址的最高位作用来标记C-bit，这样缓存 一个地址的明文秘文就不会遇到重名问题.</p><p><img src="./pic/SME_C_BIT_replace_most_significant_bit.svg" alt="SME_C_BIT_replace_most_significant_bit" /></p><p>但是我们设想下，在SEV中，该技巧还能不能奏效…</p><p>A: 不能！为什么? 因为使用这种方法有代价，就是需要牺牲物理地址空间。C bit作为单bit 牺牲掉物理地址的一个bit，造成物理地址空间范围减少一半，可以接受。但是VSID是多位 (16-bit), 会大大减少虚拟机物理地址空间。我们设想下，假设物理地址空间为48bit. <code class="language-plaintext highlighter-rouge">48-16 = 32</code>, 相当于虚拟机变回了32位.</p></details><p>在AMD后续的实现中，除了对内存加密外，还实现了其他额外的功能:</p><ul><li>SEV-ES : 寄存器加密<li>SEV-SNP : 将host和guest内存隔离</ul><h2 id="keys"><span class="me-2">KEYs</span><a href="#keys" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="证书链"><span class="me-2">证书链</span><a href="#证书链" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上面提到，虽然guest可以感知到自己的内存是加密的，但是如何保证hypervisor 不能解 密呢? 换句话说，guest在一个对外完全封闭，对内四处漏风的环境内如何验证自己的 环境符合一定的安全需求.</p><p>举个例子, 我们去买一个手机, 手机厂家说, 这手机遥遥领先, 满载跑起来温度不超过50度。 作为聪明的消费者, 我们当然不信，于是我们打开B站权威（没有收钱）的up主的评测, 去 验证手机厂家说的话是否属实。</p><p>而guest就像是消费者，云厂商中的基础设施就像是手机厂家, 其几乎不信任基础设置中 的任何组件。所以，需要有一个权威机构保证某个东西完全没有问题，这样guest可以 完全信任该组件。并无忧无虑的和其通信。</p><p><img src="./pic/SEV_guest_trusted.png" alt="SEV guest trusted" /></p><p>上图是SEV架构下，guest 信任者的示例图，在上图中, guest 除了<code class="language-plaintext highlighter-rouge">AMD hardware and Firmware</code> 谁都不信。而<code class="language-plaintext highlighter-rouge">AMD hardware and Firmware</code>作为最底层的硬件, 而且用户对其足够信任(如果不信任, 就不会买了), guest将其做为唯一的信任者, 这很合理，但是这又是很理想的情况。为什么呢? 需要大家思考几个问题:</p><ul><li> <font color="red">guest如何知道自己运行的环境就是`AMD`牌子的`haredware and Firmware`, 而不是`DMA`牌.</font><li> <font color="blue">guest owner 有时会和platform的安全处理器建立安全信道进行通信(例如导入磁盘密钥), 如何保证在 hyp参与的情况下，该信道仍然是安全的</font></ul><p>SEV通过证书链机制，实现上面的需求，我们来看下具体的细节</p><h4 id="keys-and-certificate"><span class="me-2">keys and certificate</span><a href="#keys-and-certificate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在整个的证书链中，包含很多的keys，这些key之间存在一个认证链，我们先把 整个关系展示出来，在分别介绍:</p><p><img src="./pic/sev_keys.svg" alt="sev keys" /></p><ul><li><p><strong>ASK, ARK</strong>:</p><p>ask 是amd的信任根，其签名表示AMD的真实性. 使用ARK私钥对ASM公钥进行签名. ark 是一个中级密钥，使用ask私钥对cek进行签名.</p><li> <font color="red" size="5"><strong>CEK:</strong></font><p>cek 用来对pek进行签名，从而将pek锚定到amd的信任根, 每个芯片都有一个唯一的 cek，关于该密钥km spec中的描述如下:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Each chip has a unique CEK which is derived from secrets stored in 
chip-unique OTP fuses. The lifetime of this key is the lifetime of 
the individual chip.
</pre></table></code></div></div><p>OTP 熔丝是一种硬件技术，用于在芯片制造过程中或之后存储永久性数据。这种数据一 旦写入，就无法修改或删除，因此可以用于生成独特的、不可复制的密钥。这种机制确 保了每个芯片的 CEK 是唯一的，并为芯片的安全功能提供了一个信任基础。</p><font color="red"><strong>所以, 将CEK公私钥封装到芯片内部，同时，又使用ASK私钥对CEK公钥签名生成证书，保存在 AMD厂商，这样就相当于把该机器锚定了amd的信任链. 所以, CEK 是固件可信的起点(回答了第一个疑问)</strong></font><p>那怎么验证cek是否有效呢??</p><p>可以让硬件对使用cek私钥另一个公钥进行签名，生成证书，然后，使用厂商的cek证书中的公 钥对其签署的证书，进行验签，如果验签成功，说明CEK没有问题，同时也能说明CEK签署的证书 也没有问题。</p><p>那签署的是什么证书？有何作用?</p><li><p><strong>OCA</strong>:</p><p>OCA证书是自签署的, OCA私钥用来签名PEK, 用来表明PEK是经过platform owner签署的. 该OCA密钥对以及证书生成的方式，我们放到下面的章节中介绍</p><li><p><strong>PEK</strong>, <font color="blue" size="5"><strong>PDH</strong></font>:</p><p>PEK 是由固件创建，由CEK和OCA(下面介绍) 双签名，其作用是对PDH进行签名。</p><p>PDH 使用椭圆曲线Diffie-Hellman(ECDH)算法密钥。PDH主要用于SEV fw和其他外部实体（guest owner) 协商一个住密钥，然后使用这个主密钥通过 key derivation function(KDF) 来建立起一个可信通道。</p><font color="blue"><strong>所以，使用该可信通道，就可以让Guest owner和set fw在穿过hypervisor的 情况下, 安全的通信</strong></font></ul><h3 id="other-keys"><span class="me-2">other keys</span><a href="#other-keys" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>SEV 可以在不信任的环境中，建立一个可信的通信通道. 需要下面key来保证。</p><ul><li><strong><em>TIK, TEK</em></strong>: 用于在不安全信道中传输数据<ul><li><strong>TEK</strong>: AES-128 encryption key<ul><li>SEV fw 使用该key 加密所有的 confidential information 在fw和外部实体(例如guest owner/anthor SEV fw)中传输</ul><li><strong>TIK</strong>: HMAC SHA-256 integrity key.<ul><li>SEV firmware 使用TIK来验证在 sev fw和外部entity之前传输的受保护的信息。</ul><li>SEV firmware 在发送方操作流程中生成，由firmware 生成一个TEK/TIK, 固件会 <font color="red" size="4"><strong>从安全的熵源生成 TEK, TIK</strong></font><p>。</p><li>SEV fw 在 launching and receiving 相关工作流中会导入该 WRAPPED TEK, TIK<blockquote><p>下面会介绍 WRAPPER TEK</p></blockquote></ul><li><strong><em>KEK, KIK</em></strong>: 用于在不安全信道中传输 <code class="language-plaintext highlighter-rouge">TIK, TEK</code><ul><li><strong>KEK</strong>: AES-128 encryption key<ul><li>used to wrap TEK and TIK during session establishment</ul><li><strong>KIK</strong>: HMAC-SHA-256 key<ul><li>used to wrap the TEK and TIK during session establishment(integrity)</ul><li>SEV fw <font color="red" size="4"><strong>通过密钥协商协议中协商得到的主密钥 （master secret）推导出 KEK, KIK（密钥加密密钥)</strong></font></ul><li><p><strong><em>VEK</em></strong>: AES-128 encryption key.</p><p>VEK的作用是: 在guest运行时，加密guest 内存. SEV fw 从一个安全嫡中生成 VEK. 并且 在热迁时，源端目的端应使用不同的VEK. 所以remote platform 应该自己重新生成一个 VEK.</p></ul><blockquote><p>NOTE</p><p>我们来思考下，<code class="language-plaintext highlighter-rouge">VEK</code>作为虚拟机内存加密使用的key，不用做对外传输（热迁时也不迁 移该key). 而<code class="language-plaintext highlighter-rouge">TEK, TIK</code> 用作传输过程中传输”秘密数据”的加密通道的重要工具。其是 在建立加密通道时创建的。然而我们在receive 端确认，<code class="language-plaintext highlighter-rouge">TEK, TIK</code> 是由 “真的” SEV fw 生成的呢?</p><p>从信任链我们知道, 信任链的底端是PDH。用于加密 TEK, TIK的KEK 是通过master secret 派生的。而master secret 又是通过两方的 PDH 派生而来. 所以整个的链条延伸 如下:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>SEV-fw -- gen --&gt; TIK, TEK
SEV-fw -- PDH keys -- calc--&gt; share secret -- KDF --&gt; master secret --KDF--&gt; KEK,KIK --wrapper--&gt; TIK, TEK
</pre></table></code></div></div><p>我们来看下细节</p></blockquote><h3 id="sev-fw-establish-trusted-channel"><span class="me-2">SEV fw establish TRUSTED channel</span><a href="#sev-fw-establish-trusted-channel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>SEV firmware 需要在他自己和remote party之间建立起安全信道. 其中有两个角色:</p><ul><li>server: SEV firemware issuing lanch and receive command<li>client: guest owner 和其 SEV firmware issuing send command</ul><p><img src="./pic/sev_establish_trusted_channel.svg" alt="sev establish trusted channel" /></p><p>大致流程如下:</p><ul><li>client server 交换 ECDH public key, 同时client 生成一个随机数N，并发送给server<li>client server 通过 对方的 ECHD public key和自己的 ECHD private key 生成 share secret, 然后在通过 KDF(share secret, N) 生成master secret.<li>client 通过master secret 派生出 KEK, KIK, 并生成用户传输加密验证的密钥:TIK, TEK<li>client 通过KEK 将 TIK, TEK wrap 加密，并发送给server<li>server 端也通过 master secret 派生出相同的 KEK, KIK. 并使用该密钥解析WRAP_TK,得到 TEK, TIK<li>之后，server client，就可以使用 TEK, TIK 进行安全通信.</ul><p>其实整个过程就是达到的目的是，即验证了对方的身份(PDH pubkey)，同时又将client端 生成的用于安全传输的密钥(TEK,TIK)传递到server端.</p><p>这里面牵扯到一个事情，就是双方都有一个密钥对的基础上，如何安全的传输数据. (例如 WRAP_TK数据), AMD SEV 采用一个通用的方法来实施，我们下面介绍:</p><h3 id="data-protection"><span class="me-2">Data Protection</span><a href="#data-protection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>执行data protection 需要下面输入参数:</p><ul><li><strong><em>IV</em></strong>: 128-bit initialization vector<li><strong><em>K</em></strong>: A 128-bit encryption key(e.g., KEK)<li><strong><em>I</em></strong>: A 128-bit integrity protection key(e.g., KIK)<li><strong><em>M</em></strong>: A message to protect(e.g., WRAP_TK)</ul><p>SEV key api spec 规定，不同的message 不应该使用相同的 IV 和 K 保护。 但是使用不同的K可以使用相同的IV(这条在SEND_START command中有用到)</p><p>加密规则:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>C = AES-128-CTR(M; K, IV)
MAC = HMAC-SHA-256(IV || C; I)
</pre></table></code></div></div><p>client 需要发送 C, MAC, IV 到server端，以便server端用来恢复明文。</p><h2 id="api-overflow"><span class="me-2">API overflow</span><a href="#api-overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="channel-of-software-fw"><span class="me-2">channel of [software, fw]</span><a href="#channel-of-software-fw" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>对这些密钥的管理，以及vmm和guest VM memory 之间的安全数据的传输，是通 过处理器中的SEV firmware处理。host hyperivor 和 sev fw之间通信是通过 一些API<sup>3</sup>.</p><p>同时guest有时需要外部能访问到非加密数据, 例如DMA，所以在guest中，某些 memory operation 是不需要使用key加密的。如下图所示:</p><p><img src="./pic/sev_API.svg" alt="sev API" /></p><p>在上图中，guest可以控制页表的c-bit来控制哪些页在访问时, 需要被加解密. 在sev-snp中，这个行为会更复杂，我们先不关注。总之，driver 可以使用API 来管理key，但是获取不到guest key。而运行在guest时，则会使用guest key 在访存操作时，进行数据加解密。</p><p>所以, 软件如果要配置 sev 功能，需要通过 sev 提供的一组API。</p><p>API包括:</p><ul><li><p>Platform Management API: 用于platform owner配置平台和查询平台范围内的数据</p><li><p>Guest Management API: 在整个客户机生命周期中管理 <code class="language-plaintext highlighter-rouge">Guest Context</code></p></ul><p>而SEV driver 通过SEV fw给定的方式, 向fw发送命令请求。目前支持两种通信方式:</p><ul><li>Mailbox mode: 最初的固件<li>Ring Buffer Mode: 0.24+ 固件</ul><p>其中, Mailbox Mode是通过MMIO Register实现，而Ring Buffer Mode而是在内存中 划定了一块ringbuffer，需要先通过 Mailbox方式下发 <code class="language-plaintext highlighter-rouge">RING_BUFFER</code> 命令进入。</p><h3 id="platform-api-usage-flows--platform-provisioning"><span class="me-2">PLATFORM API USAGE FLOWS – Platform Provisioning</span><a href="#platform-api-usage-flows--platform-provisioning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img src="pic/Platform_Provisioning_Usage_flows.png" alt="Platform_Provisioning_Usage_flows" /></p><ol><li>执行 <code class="language-plaintext highlighter-rouge">FACTORY_RESET</code> 恢复出厂设置.<li>厂商请求 初始化 SEV<li>platform执行INIT<li>厂商请求 PEK 签署, platform 执行 PEK_CSR 生成 CSR<li>厂商生成 PEK cert, 并用 CA signing key 签署(OCA)<li>platform 执行<code class="language-plaintext highlighter-rouge">PEK_CERT_IMPORT</code>进行 PEK_CERT，以及OCA CERT导入</ol><h3 id="guest-api-usage-flows---launch-guest"><span class="me-2">GUEST API USAGE FLOWS – LAUNCH GUEST</span><a href="#guest-api-usage-flows---launch-guest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img src="pic/LAUNCH_GUEST.png" alt="LAUNCH GUEST" /></p><p>该过程有guest owner参与, 而首先要做的, 是在guest owner(server)和 AMD secure processor(client)之间建立加密通道. 以便后续guest owner 和 client侧 传输数据(measure 等信息)</p><p>1,2. guest owner 向 client请求 导出PDH 和其他相关证书, client通过 PDH_CERT_EXPORT 导出.</p><ol><li><p>生成LAUNCH_START session 相关信息</p><blockquote><p>NOTE</p><p>见” SEV fw establish TRUSTED channel” 以及见 SEV KS API “LAUNCH_START” cmd 主要包括:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>NONCE
server PDH
WRAPPER TK, IV, MAC
</pre></table></code></div></div></blockquote><li>将guest(固件)加载到内存中<li>根据DH key 和获取到的session info, 执行LAUNCH_START命令<li>调用ACTIVATE 命令，将ASID 和虚拟机（KEY）绑定<li>调用LAUNCH_UPDATE_DATA 加密 guest memory</ol><p><img src="pic/LAUNCH_GUEST2.png" alt="LAUNCH_GUEST2" /></p><ol><li>将所有load内存都加密后，调用LAUNCH_MEASURE 对该内存进行测量<li>将测量结构发送给guest owner<li>认证platform 并验证测量结果<li>将磁盘密钥发送给guest<li>host 通过LAUNCH_SECERT 将磁盘密钥注入到guest<li>调用LAUNCH_FINISH结束launch流程<li>在VMCB中使能 SEV-enable bit 来为该虚拟机开启SEV功能<li>调用VMRUN启动虚拟机，进入guest</ol><h3 id="guest-api-usage-flows--live-migration"><span class="me-2">GUEST API USAGE FLOWS – LIVE migration</span><a href="#guest-api-usage-flows--live-migration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img src="pic/LIVE_MIGRATION.png" alt="LIVE migrate" /></p><p>该过程相当于source端为client，dest端为server。在source和dest之间建立起 一个加密通道。</p><ol><li>向server端请求PDH<li>server端执行 PDH_CERT_EXPORT 命令导出PDH和其他相关证书<li><p>调用SEND_START,</p><p>该命令要求输入目的端 platform的证书链:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>ARK-&gt;ASK-&gt;CEK-- +--&gt; PEK
                |
          OCA---
</pre></table></code></div></div><p>以及PDH</p><p>SEV fw会使用证书链验证 PDH, 验证成功后，生成session 相关信息</p><li><p>将session相关信息发送给目的端，目的端通过 RECEIVE_START 命令 加载</p><p>receive 民营没有这么复杂，只需要输入source端 PDH 以及source端 生成的session info即可.</p><li>dest端调用ACTIVATE<li>source端调用SEND_UPDATE_DATA, 将source guest memory导入到一个内存中， 注意该内存，被SEV FW 使用 VEK 解密，并使用TEK 加密, 并使用 TIK 摘要<li><strong>dest 端 调用 RECEIVE_UPDATE_DATA, 将传过来的guest memory 导入到dest guest memory 中, 注意该内存以被 SEV fw 通过 TEK 解密，并通过dest guest VEK 加密</strong><li>dest，source端调用相应 FINISH 命令结束热迁移过程</ol><h2 id="其他流程"><span class="me-2">其他流程</span><a href="#其他流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="远程近程证明"><span class="me-2">“远程”(近程)证明</span><a href="#远程近程证明" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>根据LAUNCH process 的流程中可知，在guest launch 过程中，guest owner 可以通过 guest发送过来的相关证书，以及摘要来验证guest 是否在可信环境中。如果处于安全环境， guest owner 将指示 vmm 来执行后续操作。</p><p>但是这个环境比较繁琐。于是, hygon 修改了SEV 的 ATTESTATOIN 命令，并且搞了一个 单机版的工具，来验证guest是否处于安全环境验证。</p><p><img src="./pic/csv-attestation.svg" alt="近程证明" /></p><p>该工具在guest 用户态执行，通过调用VMMCALL指令，将<code class="language-plaintext highlighter-rouge">userdata, mnonce, hash</code>等数据传输 到kvm侧。注意，此时kvm看到的是密文，通过 ATTESTATION 命令，将该内存传递到CSV FW 中。</p><p>CSV FW 填充report信息到该内存, 其中userdata 是 guest 传递过来的userdata，并通过 PEK进行签名。此时，CEV fw 返回到kvm，kvm看到的仍是密文。</p><p>而guest 调用VMMCALL 返回，看到的是明文。可以通过证书链验证PEK证书的合法性。 并且通过PEK 证书对证书信息进行验签，和SIG1 进行比对，如果验签成功，说明</p><font color="red"><strong>该数据被 合法的csv fw 处理过</strong></font><p>. 证明了 当前guest处于安全环境中。</p><h2 id="page-isolate"><span class="me-2">page isolate</span><a href="#page-isolate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="sev-snp"><span class="me-2">SEV-SNP</span><a href="#sev-snp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="rmp"><span class="me-2">RMP</span><a href="#rmp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>SEV SNP 使用RMP机制，来划分这部分内存的归属. 每个page对应一个 RMP entry <code class="language-plaintext highlighter-rouge">RMP.Assigned</code>字段会比表明这个配置是owned by guest, 还是 owned by host.</p><p><img src="./pic/SEV_SNP_RMP_CPU_IOMMU.svg" alt="SEV_SNP_RMP_CPU_IOMMU" /></p><p>关于page own:</p><ul><li>host cpu memory access 和iommu memory access 都将当前的执行者认为hypervisor.<li>RMP.Assigned = 0 包括 guest owned page 和 AMD-SP owned page(e.g. RMP page)两种 类型</ul><p>关于memory access check:</p><ul><li>当 CPU (guest or host) 使用访存指令访问内存时, 通过MMU pagetable walk后, 获取到 HPA, 将该HPA传递给SEV fw, 然后fw 会去查找RMP table, 查看该page owner 和 本次访存的角色(guest host) 是否一致. 如果不一致:<ul><li>GUEST: trap #NPF<li>HOST: trap #PF</ul><li>当 设备通过 DMA 访存时，该 TLP 到达 root complex后，被IOMMU拦截, IOMMU 使用 IOMMU pagetable 将 IOVA转换为 PA, 让后将该PA传递给 SEV fw, 同样的fw会查找RMP table。<li>对于memory access 限制，只限于write access, 因为read access 有AES DEC保护。</ul><p>为了防止host更改guest映射(e.g., guest的本意是 GPA1-&gt;HPA1, 结果被hyp更改为GPA1-&gt; HPA2), guest memory access check会额外检查RMP.GPA是否和本次pagetable walk获取的 GPA相同, 如果不相同，则认为guest受到攻击，触发NPF:</p><p><img src="pic/NESTED_TABLEWORK.png" alt="NESTED_TABLEWORK" /></p><h4 id="page-validate"><span class="me-2">PAGE VALIDATE</span><a href="#page-validate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>而page own不是一成不变的. host 通过<code class="language-plaintext highlighter-rouge">RMPUPDATE</code>指令, guest 通过<code class="language-plaintext highlighter-rouge">PVALIDATE</code>指令可以 修改page own.</p><p><img src="pic/change_page_state.png" alt="change_page_state" /></p><p>首先说明不同的page state:</p><ul><li>Hypervisor Page: owned by hyp。可被hyp读写, 不能被guest 使用c=1访问 （public page 下面会讲)<li>Guest-Invalid: owned by guest, 但是未验证。<strong>不可被hyp写</strong> . 不能被guest 使用c=1访问<li>Guest-Valid: owned by guest, 已经验证。<strong>不可被hyp写</strong> . 可以被guest 使用c=1访问</ul><p>owner 变更:</p><ul><li><code class="language-plaintext highlighter-rouge">hyp page -&gt; Guest-Invalid</code> : HOST 调用 <code class="language-plaintext highlighter-rouge">RMPUPDATE</code>. 常用于启动虚拟机，after launch guest mem.<li><code class="language-plaintext highlighter-rouge">Guest-xxx -&gt; hyp page</code> : HOST 调用 <code class="language-plaintext highlighter-rouge">RMPUPDATE</code>. 常用于关闭虚拟机.<li><code class="language-plaintext highlighter-rouge">Guest-Invalid -&gt; Guest-validate</code> : GUEST 调用<code class="language-plaintext highlighter-rouge">PVLAIDATE</code>, 用于将GPA固定为private page.<li><code class="language-plaintext highlighter-rouge">Guest-validate -&gt; Guest-Invalid</code>: GUEST 调用<code class="language-plaintext highlighter-rouge">PVLAIDATE</code>, 取消private page固定，为public page映射作准备</ul><blockquote><p>NOTE</p><p>这里牵扯到private page, public page的概念，我们下面会讲到。</p></blockquote><p>我们来看如果hyp 更改 guest GPA-&gt;HPA映射会发生什么?</p><p><img src="pic/PAGE_REMAPPING_ATTACK.png" alt="PAGE_REMAPPING_ATTACK" /></p><ol><li>guest首先执行pvalidate 指令，将其GPA和HPA固定.<li>hw 设置RMP[X].validate flag.<li>Hypervisor 分配了一个新的page 准备 re-mapping攻击, 调用 RMPUPDATE 将该page所在的RMP GPA ASID 都更新为和RMP[x]一样的。<li>hyp 更改了NPT,将 GPA(A) 映射到了物理地址[Y]<li>硬件检查RMP[Y].Validate = 0 说明物理地址Y没有被guest验证过.</ol><blockquote><p>NOTE</p><p>guest应该确保，其对每个GPA所在的page应该只执行一次PVALIDATE指令.</p></blockquote><p>由此可见, HOST 调用<code class="language-plaintext highlighter-rouge">RMPUPDATE</code>的作用是管理guest page的生命周期，为GUEST 分配具体 的物理内存(另外，guest 销毁时, 也需要将其内存资源进行回收).</p><p><img src="./pic/RMP_entry_and_inst.svg" alt="RMP_entry_and_inst" /></p><p>在RMP中:</p><ul><li>HOST执行的<code class="language-plaintext highlighter-rouge">RMPUPDATE</code>负责更改大部分字段, 如果<code class="language-plaintext highlighter-rouge">RMPUPDATE</code> 更改了上面紫色部分， 则会clear <code class="language-plaintext highlighter-rouge">RMP.validate</code> 字段<blockquote><p>部分伪代码:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>IF ((OLD_RMP.ASID ^ NEW_RMP.ASID) ||
    (OLD_RMP.GUEST_PA ^ NEW_RMP.GUEST_PA) ||
    (OLD_RMP.PAGE_SIZE ^ NEW_RMP.PAGE_SIZE) ||
    (OLD_RMP.ASSIGNED ^ NEW_RMP.ASSIGNED))
  N = CPUID Fn8000001F_EBX[15:12]
  temp_RMP.VALIDATED = 0
  temp_RMP.VMSA = 0
  temp_RMP.PERMISSIONS[0] = FULL_PERMISSIONS
  temp_RMP.PERMISSIONS[1:(N-1)] = 0
</pre></table></code></div></div></blockquote><li>GUEST执行<code class="language-plaintext highlighter-rouge">PVALIDATE</code>负责更改<code class="language-plaintext highlighter-rouge">validate</code>字段</ul><p>而GUEST 调用<code class="language-plaintext highlighter-rouge">PVALIDATE</code>的作用是声明HOST 分配的这个page 是属于当前的GPA。HOST不能 擅自再通过调用 <code class="language-plaintext highlighter-rouge">RMPUPDATE</code> 更改映射关系.</p><p><img src="./pic/PVALIDATE_RMPUPDATE.svg" alt="PVALIDATE_RMPUPDATE" /></p><p>这个机制很关键，相当于把最终的控制权交给了guest，让guest有能力管理其GPA是否要固 定。</p><h3 id="csv3"><span class="me-2">CSV3</span><a href="#csv3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>回忆 <code class="language-plaintext highlighter-rouge">SEV-SNP</code> 的机制, SEV-SNP 机制主要靠 <code class="language-plaintext highlighter-rouge">RMP</code> , 而其作用主要分为两 部分:</p><ul><li>确定 PAGE 的归属<li>将PAGE 和具体的GPA绑定，并且保证host无法更改</ul><p>好，基于上面两点，我们来看下hygon CSV3.</p><h4 id="csv3-rmp--smcr"><span class="me-2">CSV3 “RMP” – SMCR</span><a href="#csv3-rmp--smcr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img src="./pic/CSV_CMA.svg" alt="CSV_CMA" /></p><p>在<code class="language-plaintext highlighter-rouge">SEV-SNP</code>中 所有物理页是通过RMP table来决定page归属的。而在CSV3中，该方式有了一些 更改（个人认为是优化）。</p><ul><li>首先通过 kernel cmdline 可以配置<code class="language-plaintext highlighter-rouge">csv_mem_percentage</code> 来决定，可以 用于csv3 虚拟机的内存比例<li>在kernel引导早期，csv driver会在各个numa上, 根据<code class="language-plaintext highlighter-rouge">csv_mem_percentage</code> 预留内存， 并使用<code class="language-plaintext highlighter-rouge">cma</code> 管理.<li>而随后，会调用两个csv cmd : <code class="language-plaintext highlighter-rouge">SET_SMR</code>, <code class="language-plaintext highlighter-rouge">SET_SMCR</code>, 个人理解，SMR 相当于告诉 csv固件，这些内存将被 csv fw 管理. 而SMCR则是在 SMR中 isolate 一块内存, 用于管理使用。(个人认为相当于RMP)</ul><p>但是256M内存非常小，并不能以page的的粒度去管理， 下面我们看下其管理机制.</p><h4 id="csv3-change-to-guest-invaild--set_guest_private_memory"><span class="me-2">CSV3 change to “GUEST-Invaild” – SET_GUEST_PRIVATE_MEMORY</span><a href="#csv3-change-to-guest-invaild--set_guest_private_memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img src="./pic/CSV_SET_GUEST_PRIVATE_MEMORY.svg" alt="CSV_SET_GUEST_PRIVATE_MEMORY" /></p><ul><li><p>所有cma所在的地址空间范围（包括各个cma之间的空洞），被划分为8192个空间。个人猜 测在 SMCR中，也划分为8192个object，每个 object 管理一个physical address space。所以，其管理的粒度 (假设1T内存的话，每个空间为128M)</p><li>而csv3 虚拟机分配内存时，每次分配的内存也是以相同的颗粒大小分配<code class="language-plaintext highlighter-rouge">[1T, 128M]</code><li>通过上面的设计，可以猜测，SMCR的是多个page, 而非单个</ul><p>当执行完 <code class="language-plaintext highlighter-rouge">SET_GUEST_PRIVATE_MEMORY</code> , 命令后，该page就归属成当前的虚拟机，host无 法再访问。所以该步骤相当于 <code class="language-plaintext highlighter-rouge">SEV-SNP</code>的<code class="language-plaintext highlighter-rouge">hyp page-&gt; guest invalid page</code>的page state 的转变过程.</p><p>而<code class="language-plaintext highlighter-rouge">sev-snp</code>的功能除了决定page归属，还应该确保，guest内存在使用过程中不被host更改， csv3如何做到呢?</p><h4 id="csv3-pvalidate---csv3_secure_cmd_encdec"><span class="me-2">CSV3 “PVALIDATE” – CSV3_SECURE_CMD_ENC/DEC</span><a href="#csv3-pvalidate---csv3_secure_cmd_encdec" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img src="./pic/CSV3_PVALIDATE.svg" alt="CSV3_PVALIDATE" /></p><p>这里其实产生了一个矛盾，SMCR的管理粒度是一组page，而<code class="language-plaintext highlighter-rouge">PVALIDATE</code>的需求往往是一个page, 那SMCR目前的设计就无法满足<code class="language-plaintext highlighter-rouge">PVALIDATE</code>的需求。</p><p>确实是这样，然而csv3不用<code class="language-plaintext highlighter-rouge">SMCR</code>控制这些，那怎么做呢?</p><p>CSV3 <code class="language-plaintext highlighter-rouge">GPA-&gt;HPA</code>的映射是靠NPT page table, 那么直接把 NPT page table isolate，不让 Hyp 管理，由SEV fw 自己管理。所以NPT host就无法更改了。</p><p>这样做是非常省事! Hygon csv3 不用在设计复杂的机制来验证guest 映射是否更改。而在 guest中也不用处理 <code class="language-plaintext highlighter-rouge">#VE</code> 这种异常类型.</p><p><img src="./pic/CSV_MAPPING_PAGE.svg" alt="CSV_MAPPING_PAGE" /></p><p>所以，对于csv3虚拟机中，是有两套页表，一套是有CSV fw管理作为private 内存映射访问。 而另一套是由 KVM 管理，用于public 内存映射访问。</p><p>由于存在两套页表，guest在运行时，怎么决定使用哪套页表呢?</p><p>我的猜测是先在 <code class="language-plaintext highlighter-rouge">isolate by CSV fw</code>管理的NPT中找，如果找不到，再从<code class="language-plaintext highlighter-rouge">NO isolate</code>的 NPT页表中找. 再找不到就报 <code class="language-plaintext highlighter-rouge">#NPF</code> 给KVM.</p><p>那么由于有public/private page 转换需求，就需要从guest 中支持执行某些命令来控制 csv fw 建立/取消 <code class="language-plaintext highlighter-rouge">isolate by CSV fw NPT mapping</code>.</p><p>在看这些之前，我们先看下，guest如何和csv fw 进行通信。</p><h3 id="csv3-guest-exec-csv-fw-command"><span class="me-2">CSV3 guest exec CSV FW command</span><a href="#csv3-guest-exec-csv-fw-command" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>NOTE</p><p>可以想下AMD-SNP PVALIDATE 是不是需要和 SEV fw进行通信。个人认为不需要，因为 RMP 是明文，CPU完全有能力修改这部分内存。所以其在guest中扩展了指令集。</p><p>但是CSV3不同。CSV3 隔离了这部分内存，CPU如果要支持必须和CSV fw进行通信.</p></blockquote><p>CSV3 并没有扩展 指令集，而是设置了一个规则，让guest 可以和SEV fw 进行加密通信。</p><p><img src="./pic/csv_guest_exec_fw_api.svg" alt="csv_guest_exec_fw_api" /></p><p>但是csv fw 作为一个 “PCI 设备”, 在host中可以看到，在guest中并没有该设备，guest 又如何合其通信呢?</p><p><img src="./pic/csv_se_call_table.svg" alt="csv_se_call_table" /></p><p>如上图所示，通过一个secure call pages 和 csv fw通信。这两个page一个有NPT映射， 一个没有NPT映射，有NPT映射的作为input page， 而没有NPT 映射的作为output page。</p><p>guest首先将需要执行的命令写入output page, 然后读取 input page，由于INPUT page没有 NPT映射，trap到KVM中，kvm调用 <code class="language-plaintext highlighter-rouge">UPDATE_NPT</code>命令通知 csv fw建立映射，而csv 观测到 该page是 secure call page后，执行 该page中的cmd，将resp数据放到output page中， 并将原来的input page接触映射，将output page 建立映射。 (此时output page, 和input page的角色已经互换）</p><p>而guest 从kvm中返回，可以从原来的output page（现在的input page）中读取到csv fw 返回的数据。</p><h3 id="private-public-page"><span class="me-2">private public page</span><a href="#private-public-page" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>无论是 SEV-SNP, 还是CSV3，都面临一个问题，guest memory 不能被host访问，但是作为 DMA的page又往往需要host 访问。所以其设计出一套机制，将guest memory 划分为两部分</p><ul><li>private memory<li>share memory:</ul><p><img src="./pic/private_public_page.svg" alt="private public page" /></p><p>其中public memory 作为memfd 的file pagecache管理，而 private memory 则用CMA进行预 分配.（这个不展开)</p><p>切换流程:</p><p><img src="./pic/csv_private_to_public.svg" alt="csv private to public" /></p><p>切换主要包含三个流程:</p><ol><li>clear guest pgtable中的C bit.<li>向sev fw 发送 CSV3_SECURE_CMD_ENC 解除NPT映射。这时该gpa可以被host自定义映射<li>guest调用VMMCALL trap 到kvm，kvm最终建立该gpa到memfd pagecache的映射。</ol><p>做完上面三步, guest 访问该地址会将明文存放到share page中。</p><p>但是原来的private page 并没有释放，所以对于这个gpa会有双倍的内存损耗</p><blockquote><p>NOTE</p><p>可以思考下，为什么不能使用大页</p></blockquote><p>那么我们再来看下 public to private 流程:</p><p><img src="./pic/csv_public_to_private.svg" alt="csv_public_to_private" /></p><p>过程和private to public 相似，不过不同的是，其会调用invalidate pagecache相关接口， 将public page 释放掉.</p><h2 id="参考链接"><span class="me-2">参考链接</span><a href="#参考链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><a href="https://blog.csdn.net/huang987246510/article/details/135487665?spm=1001.2014.3001.5501">huangyong - AMD SEV基本原理</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/white-papers/memory-encryption-white-paper.pdf">AMD MEMORY ENCRYPTION</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/white-papers/SEV-SNP-strengthening-vm-isolation-with-integrity-protection-and-more.pdf">AMD SEV SNP</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/programmer-references/55766_SEV-KM_API_Specification.pdf">Secure Encrypted Virtualization API Version 0.24</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/58019.pdf">Secure VM Service Module for SEV-SNP Guests</a><li><a href="https://www.youtube.com/watch?v=RYIjUweFysA">YouTube – SNP Live Migration with guest-memfd and mirror VM </a><li><a href="https://github.com/AMDESE/linux-svsm">Git – linux-svsm</a><li><a href="https://blog.imlk.top/posts/amd-sev-on-epyc-and-pve/">探究AMD SEV/SEV-ES远程证明过程——在EPYC 7302洋垃圾服务器上</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/coco/">coco</a>, <a href="/categories/sev/">sev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/sev/" class="post-tag no-text-decoration" >sev</a> <a href="/tags/csv/" class="post-tag no-text-decoration" >csv</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=sev%20&&%20csv%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Famd-sev%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=sev%20&&%20csv%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Famd-sev%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Famd-sev%2F&text=sev%20&&%20csv%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/RMM/">[arm] RMM</a><li class="text-truncate lh-lg"> <a href="/posts/sched/">schedule: overflow</a><li class="text-truncate lh-lg"> <a href="/posts/HOWTO-study-Linux-kernel/">How To study Linux kernel and become a committer</a><li class="text-truncate lh-lg"> <a href="/posts/learn-CCA/">[arm] learn CCA</a><li class="text-truncate lh-lg"> <a href="/posts/RME-spec/">[arm] RME(spec)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/amd-sev-api/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1740706740" data-df="ll" > Feb 28, 2025 </time><h4 class="pt-0 my-2">sev api</h4><div class="text-muted"><p>Platform Management API Platform Management API 由 platform owner 使用，用于配置/查询 platform-wide data。 下面的章节主要包括: Platform Context: Which data are categorized as platform-wide data Ownership: who i...</p></div></div></a></article><article class="col"> <a href="/posts/learn_the_architecture__trustzone/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1755049140" data-df="ll" > Aug 13, 2025 </time><h4 class="pt-0 my-2">[arm] TrustZone</h4><div class="text-muted"><p>What is TrustZone? TrustZone is the name of the Security architecture in the Arm A-profile architecture. First introduced in Armv6K, TrustZone is also supported in Armv7-A and Armv8-A. TrustZone p...</p></div></div></a></article><article class="col"> <a href="/posts/virtcca-paper/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1756104900" data-df="ll" > Aug 25, 2025 </time><h4 class="pt-0 my-2">[arm] virtCCA</h4><div class="text-muted"><p>ABSTRACT ARM recently introduced the Confidential Compute Architecture (CCA) as part of the upcoming ARMv9-A architecture. CCA enables the support of confidential virtual machines (cVMs) within a ...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/coroutine/" class="btn btn-outline-primary" aria-label="Older" ><p>qemu coroutine</p></a> <a href="/posts/amd-sev-api/" class="btn btn-outline-primary" aria-label="Newer" ><p>sev api</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
