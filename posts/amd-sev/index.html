<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="sev" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="本文是对1的高仿，但是劣质版本，非常建议去阅读下huangyong的文章" /><meta property="og:description" content="本文是对1的高仿，但是劣质版本，非常建议去阅读下huangyong的文章" /><link rel="canonical" href="/posts/amd-sev/" /><meta property="og:url" content="/posts/amd-sev/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-02-28T09:39:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="sev" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2025-02-28T09:39:00+08:00","datePublished":"2025-02-28T09:39:00+08:00","description":"本文是对1的高仿，但是劣质版本，非常建议去阅读下huangyong的文章","headline":"sev","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/amd-sev/"},"url":"/posts/amd-sev/"}</script><title>sev | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>sev</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>sev</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1740706740" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 28, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="7046 words" > <em>39 min</em> read</span></div></div></div></header><div class="content"><blockquote><p>本文是对<sup>1</sup>的高仿，但是劣质版本，非常建议去阅读下huangyong的文章</p></blockquote><h2 id="背景"><span class="me-2">背景</span><a href="#背景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在云环境中有两类角色:</p><ul><li>platform owner : 云厂商<li>guest owner : 租用云厂商的用户</ul><p>云厂商负责提供云基础设施, 为用户构建出一套”属于自己的” 计算存储网络， 同时需要保证云基础设施足够优质来吸引用户。</p><p>而租户则是使用云厂商提供的云基础设施，来跑自己的业务，在云场景下， 租户只需要关心云环境中的业务，而无需关心云基础设施的层面的问题， 例如: 云主机的网络波动，硬件老化等等。</p><p>而云环境下的安全也是platform owner的一个重要服务，而，只能选择信任 云厂商提供的安全防护功能。但是, 总有防不住的时候，一旦platform owner的 的防线被击穿，其上面运行的guest都会有风险，而由于host有足够的权限，并且 其操作对于guest而言都是透明的，所以对于一些数据敏感的guest owner而言， 这种安全风险不能接受。</p><p>前面也提到, platform owner 也想提供更优质的服务来吸引用户。而安全防护也是 一个很重要的服务。但是软件防护总是限制的, 而能不能通过在硬件层面来保证， 在host 安全组件被击破后，还有一道硬件防线，可以防止guest不被攻击。AMD SEV 提供了该解决方案。</p><p>简单来说，AMD SEV 主要提供了一个隔离方案，让host无法观测到guest的行为， 同时提供给 guest 一些接口，可以让 guest 来验证，自己是跑在一个安全的 AMD SEV 环境。</p><p>另外, 对于提供sev功能的云厂商来说，既希望提供给用户这个功能，也希望 能像传统虚拟机一样管理sev虚拟机的生命周期. 例如:</p><ul><li>启动<li>关闭<li>迁移<li>快照</ul><h2 id="overflow"><span class="me-2">overflow</span><a href="#overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在介绍<code class="language-plaintext highlighter-rouge">SEV</code>之前, 我们先来看下传统虚拟机。</p><p>在传统架构中，有两个角色, Hypervisor和guest, Hypervisor, 几乎可以 访问虚拟机所有的位置的数据，还可以修改虚拟机运行上下文:</p><ul><li>MEMORY<li>REGISTER<li>DISK</ul><p>所以，在SEV中, 就是要限制Hypervisor的权限，不能让host随意获取到guest 中运行的数据，甚至不能恶意模块修改. 而最直接的方法就是数据加密， 关于这部分我们在<a href="">SME</a> 章节中介绍</p><p>另外, guest需要一种方法可以确认，自己所处的环境是一个安全的，可以 被信任的环境。AMD是通过证书链认证实现的，这部分内容我们在<a href="">证书链</a> 章节中介绍。</p><p>hypervisor 负责管理guest的生命周期，资源分配. 而由于sev引入了证书链， 所以需要host管理各种证书. 并且sev又引入了一些其他对guest管理的额外 要求，这都需要hypervisor 与 sev 安全组件交互，所以需要一组API，以及 需要定义使用这些API的通道. 这些内容我们放到API章节中介绍, 并且在该章节 中，我们会介绍部分API，以及其在SEV 框架中的作用。</p><h2 id="sme"><span class="me-2">SME</span><a href="#sme" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Secure Encrypted Virtualization (SEV) 功能允许在VM运行期间，透明的 加解密内存，并且每个VM加解密时，可以使用他们独有的key(密钥)。实现方式 是在memory control 中实现一个高性能的加密模块，该加密模块可以编程多个密钥， 用来给不同的虚拟机使用。</p><blockquote><p>TIPS</p><p>我们来思考下，memory control 如何识别本次访问是属于哪个虚拟机呢?</p><p>AMD的做法是，在对TLB虚拟化时，通过引入ASID, 可以标记该虚拟机拥有哪些 TLB, 从而让TLB中可以拥有虚拟机维度的TLB隔离。SEV功能也是复用了ASID， 让其作为密钥ID。</p></blockquote><p>在AMD后续的实现中，除了对内存加密外，还实现了其他额外的功能:</p><ul><li>SEV-ES : 寄存器加密<li>SEV-SNP : 将host和guest内存隔离</ul><blockquote class="prompt-warnnings"><p>TODO</p></blockquote><h2 id="证书链"><span class="me-2">证书链</span><a href="#证书链" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>上面提到，虽然guest可以感知到自己的内存是加密的，但是如何保证hypervisor 不能解 密呢? 换句话说，guest在一个对外完全封闭，对内四处漏风的环境内如何验证自己的 环境符合一定的安全需求。</p><p>举个例子, 我们去买一个手机, 手机厂家说, 这手机遥遥领先, 满载跑起来温度不超过50度。 作为聪明的消费者, 我们当然不信，于是我们打开B站权威（没有收钱）的up主的评测, 去 验证手机厂家说的话是否属实。</p><p>而guest就像是消费者，云厂商中的基础设施就像是手机厂家, 其几乎不信任基础设置中 的任何组件。所以，需要有一个权威机构保证某个东西完全没有问题，这样guest可以 完全信任该组件。并无忧无虑的和其通信。</p><p><img src="./pic/SEV_guest_trusted.png" alt="SEV guest trusted" /></p><p>上图是SEV架构下，guest 信任者的示例图，在上图中, guest 除了<code class="language-plaintext highlighter-rouge">AMD hardware and Firmware</code> 谁都不信。而<code class="language-plaintext highlighter-rouge">AMD hardware and Firmware</code>作为最底层的硬件, 而且用户对其足够信任(如果不信任, 就不会买了), guest将其做为唯一的信任者, 这很合理，但是这又是很理想的情况。为什么呢? 需要大家思考几个问题:</p><ul><li> <font color="red">guest如何知道自己运行的环境就是`AMD`牌子的`haredware and Firmware`, 而不是`DMA`牌.</font><li> <font color="blue">在guest中，会有一些行为需要和sev fw 进行通信。但是理论上，从guest出发的所有行为， hypervisor都能捕获，guest如何在穿过hypervisor的情况下，和 sev fw建立起安全的通信通道</font></ul><p>SEV通过证书链机制，实现上面的需求，我们来看下具体的细节</p><h4 id="keys-and-certificate"><span class="me-2">keys and certificate</span><a href="#keys-and-certificate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在整个的证书链中，包含很多的keys，这些key之间存在一个认证链，我们先把 整个关系展示出来，在分别介绍:</p><p><img src="./pic/sev_keys.svg" alt="sev keys" /></p><ul><li><p><strong>ASK, ARK</strong>:</p><p>ask 是amd的信任根，其签名表示AMD的真实性. 使用ARK私钥对ASM公钥进行签名. ark 是一个中级密钥，使用ask私钥对cek进行签名.</p><li> <font color="red" size="5"><strong>CEK</strong></font><p>:</p><p>cek 用来对pek进行签名，从而将pek锚定到amd的信任根, 每个芯片都有一个唯一的 cek，关于该密钥km spec中的描述如下:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Each chip has a unique CEK which is derived from secrets stored in 
chip-unique OTP fuses. The lifetime of this key is the lifetime of 
the individual chip.
</pre></table></code></div></div><p>OTP 熔丝是一种硬件技术，用于在芯片制造过程中或之后存储永久性数据。这种数据一 旦写入，就无法修改或删除，因此可以用于生成独特的、不可复制的密钥。这种机制确 保了每个芯片的 CEK 是唯一的，并为芯片的安全功能提供了一个信任基础。</p><font color="red"><strong>所以, 将CEK公私钥封装到芯片内部，同时，又使用ASK私钥对CEK公钥签名生成证书，保存在 AMD厂商，这样就相当于把该机器锚定了amd的信任链. 所以, CEK 是固件可信的起点(回答了第一个疑问)</strong></font><p>那怎么验证cek是否有效呢??</p><p>可以让硬件对使用cek私钥另一个公钥进行签名，生成证书，然后，使用厂商的cek证书中的公 钥对其签署的证书，进行验签，如果验签成功，说明CEK没有问题，同时也能说明CEK签署的证书 也没有问题。</p><p>那签署的是什么证书？有何作用?</p><li><p><strong>PEK</strong>, <font color="blue" size="5"><strong>PDH</strong></font>:</p><p>PEK 是由固件创建，由CEK和OCA(下面介绍) 双签名，其作用是对PDH进行签名。</p><p>PDH 使用椭圆曲线Diffie-Hellman(ECDH)算法密钥。PDH主要用于SEV fw和其他外部实体（guest owner) 协商一个住密钥，然后使用这个主密钥通过 key derivation function(KDF) 来建立起一个可信通道。</p><font color="blue"><strong>所以，使用该可信通道，就可以让Guest和set fw在穿过hypervisor的情况下， 安全的通信</strong></font><li><p><strong>OCA</strong>:</p><p>OCA证书是自签署的, OCA私钥用来签名PEK, 用来表明PEK是经过platform owner签署的. 该OCA密钥对以及证书生成的方式，我们放到下面的章节中介绍</p></ul><p>##</p><h2 id="api-overflow"><span class="me-2">API overflow</span><a href="#api-overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="channel-of-software-fw"><span class="me-2">channel of [software, fw]</span><a href="#channel-of-software-fw" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>对这些密钥的管理，以及vmm和guest VM memory 之间的安全数据的传输，是通 过处理器中的SEV firmware处理。host hyperivor 和 sev fw之间通信是通过 一些API<sup>3</sup>.</p><p>同时guest有时需要外部能访问到非加密数据, 例如DMA，所以在guest中，某些 memory operation 是不需要使用key加密的。如下图所示:</p><p><img src="./pic/sev_API.svg" alt="sev API" /></p><p>在上图中，guest可以控制页表的c-bit来控制哪些页在访问时, 需要被加解密. 在sev-snp中，这个行为会更复杂，我们先不关注。总之，driver 可以使用API 来管理key，但是获取不到guest key。而运行在guest时，则会使用guest key 在访存操作时，进行数据加解密。</p><p>所以, 软件如果要配置 sev 功能，需要通过 sev 提供的一组API。</p><p>API包括:</p><ul><li><p>Platform Management API: 用于platform owner配置平台和查询平台范围内的数据</p><li><p>Guest Management API: 在整个客户机生命周期中管理 <code class="language-plaintext highlighter-rouge">Guest Context</code></p></ul><p>而SEV driver 通过SEV fw给定的方式, 向fw发送命令请求。目前支持两种通信方式:</p><ul><li>Mailbox mode: 最初的固件<li>Ring Buffer Mode: 0.24+ 固件</ul><p>其中, Mailbox Mode是通过MMIO Register实现，而Ring Buffer Mode而是在内存中 划定了一块ringbuffer，需要先通过 Mailbox方式下发 <code class="language-plaintext highlighter-rouge">RING_BUFFER</code> 命令进入。</p><h2 id="platform-management-api"><span class="me-2">Platform Management API</span><a href="#platform-management-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Platform Management API 由 platform owner 使用，用于配置/查询 platform-wide data。</p><p>下面的章节主要包括:</p><ul><li>Platform Context: Which data are categorized as platform-wide data<li>Ownership: who is the platform owner<li>Non-volatile Storage: Persistently store platform-wide data<li>Platform APIs</ul><h3 id="platform-context"><span class="me-2">Platform Context</span><a href="#platform-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>SEV fw 在 platform 的整个生命周期中维护了一个platform context. 该context包含了 SEV API 所需的data 和 metadata.</p><p>PlatForm Context (PCTX) Field:</p><p><img src="pic/PCTX_Field.png" alt="PCTX_Field" /></p><p>PCTX中主要包括:</p><ul><li><p>platform state</p><p>某些API会改变platform state. 并且某些API只能在特定的state下才能执行。并且 Guest Management API 只能在INIT/WORKING platform states 下，才能执行:</p><p><img src="pic/PSTATE.png" alt="PSTATE" /></p><li>platform config<li>keys: PDH, PEK, CEK, OCA。这些key有些是导入的，有些是生成的， 有些是固化在固件中的。platform API 负责去管理这些证书的生命周期.<li>Guest Information:<ul><li>GUEST_COUNT: number of guest contexts currently managed by the fw.<li>GUEST: guest contexts currently managed by the fw.</ul></ul><h3 id="ownership"><span class="me-2">Ownership</span><a href="#ownership" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一个platform 可能由外部实体拥有，也可能是self-owned。platform owner的所有权由一个以 OCA（所有者信任根）为根的证书链定义。OCA 签署 PEK。当platform不由外部实体拥有时， platform会生成自己的 OCA 密钥对.</p><p>这有什么用呢?</p><blockquote><p>下面是自己的理解。很可能不对。</p></blockquote><p>目前在整个AMD的信任链中，PSP(Platform Secure Processor) 是根据CET有一套完整的信任链。 但是, Processor 之上的软硬件组件，还是需要platform 来保证. 虽然platform owner已经无法 窥探到guest的真面目了, 但是作为guest owner来说，还是想要platform owner的一些其他的服务 和特性。</p><p>举个不恰当的例子。某用户最近想买 aliyun deepseek 一体机. 但是买不起一手的，只能买二手的。 去闲鱼上一看, 我的天，这些同样牌子的aliyun deepseek 一体机，怎么长得都不一样。用户也 不确定自己买回来的是真的 aliyun牌子的还是awaiyun的。</p><p>那用户就可以通过OCA验证。设备再aliyun出厂时，导入了OCA的公钥。以及使用了OCA私钥，签署了 PEK。这样用户就可以去做验证了。</p><p>当然，如果客户不想买一体机，想买个裸机回来自己搭建，那platform owner就是他自己。这时， OCA就可以使用sev fw API 在这台机器生成。</p><p>所以，总结来说，OCA就是用来验证platform owner的身份的真伪。</p><h4 id="non-volatile-storage"><span class="me-2">Non-volatile Storage</span><a href="#non-volatile-storage" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>上面提到的PCTX某些信息的生命周期可能比物理机运行周期还长（关机不清除) 。所以，这些信息 是存储在non-volatile storage中。包括:</p><ul><li>PDH key pair<li>PDH certificate<li>PEK key pair<li>PEK certificate<li>OCA public key<li>OCA private key (only if self-owned)<li>OCA certificate</ul><p>这些cert/key 在生成/导入后，立即加密存储.</p><h4 id="platform-apis"><span class="me-2">PlatForm APIs</span><a href="#platform-apis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="table-wrapper"><table><thead><tr><th>name<th>State restrictions for executing<th>state change<tbody><tr><td>INIT<td>UNINIT<td>INIT<tr><td>INIT_EX<td>UNINIT<td>INIT<tr><td>SHUTDOWN<td>ANY<td>UNINIT<tr><td>PLATFORM_RESET<td>UNINIT<td>NOT CHANGE(UNINIT)<tr><td>PLATFORM_STATUS<td>ANY<td>NOT CHANGE<tr><td>PEK_GEN<td>INIT<td>NOT CHANGE(INIT)<tr><td>PEK_CSR<td>INIT, WOKRING<td>NOT CHANGE<tr><td>PEK_CERT_IMPORT<td>INIT<td>NOT CHANGE(INIT)</table></div><h5 id="init"><span class="me-2">INIT</span><a href="#init" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>overflow<ul><li>INIT cmd用于 platform owner 初始化platform。该命令会从 non-volation storage 中加 载并初始化 platform context. 这一般是首先要执行的命令(除了 PLATFORM_STATUS 确定API version)</ul><li>action<ul><li>CEK 是是根据芯片的唯一值 派生(derived)出来的<li>如果没有OCA 证书，则self-signed(自签名）一个OCA cert. 这个新生成的证书也会写到 non-volatile storage中.<li>没有PEK, 或者 OCA 刚刚生成, 生成PEK signing key 并且通过OCA &amp;&amp; CEK 签名。 同样的，也写到 non-volatile storage 中<li>没有PDH 或者 PEK 刚刚被生成, 生成 PDH key. 通过PEK 签署 PDH 证书.<li>所有核上的SEV-related ASID 都被标记为invalid. 在active 任何vm之前，每个核心都需 要执行WBINVD 指令.</ul></ul><h4 id="init_ex"><span class="me-2">INIT_EX</span><a href="#init_ex" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>和上面命令相似, 只不过支持 NV_PADDR传入额外信息，暂略</p><h4 id="shutdown"><span class="me-2">SHUTDOWN</span><a href="#shutdown" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>All platform and guest state maintained by the firmware is securely deleted from volatile storage.<h4 id="platform_reset"><span class="me-2">PLATFORM_RESET</span><a href="#platform_reset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></ul><li>overflow<ul><li>reset the non-volatile SEV related data<li>invoking this command is useful when the owner wishes to transfer the platform to a new owner or securely dispose（销毁) of the system.</ul><li>action<ul><li>delete persistent state from non-volatile storge</ul></ul><h4 id="platform_status"><span class="me-2">PLATFORM_STATUS</span><a href="#platform_status" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>used by the platform owner to collect the current status of the platform.</ul><li>action<ul><li>IF PSTATE.UNINIT<ul><li>OWNER, CONFIG.ES, CUEST_COUNT = 0</ul><li>IF owned by an <strong><em>EXTERNAL OWNER</em></strong><ul><li><p>OWNER = 1</p><p>else</p><p>OWNER = 0</p></ul><li>CONFIG flags == INIT command params</ul></ul><h4 id="pek_gen"><span class="me-2">PEK_GEN</span><a href="#pek_gen" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p>overflow</p><p>该命令用户生成一个新的<code class="language-plaintext highlighter-rouge">PEK</code>. 用来重新生成 identity of the platform 但其实在平 台reset后，首次调用INIT命令时, PEK 会被重新生成，所以该命令不是必须的。</p><li><p>action</p><ul><li>deleted from volatile and non-volatile storage:<ul><li>PEK key pair<li>PEK certificate<li>PDH key pair<li>PDH certificate<li>OCA key pair (if the platform is self-owned)<li>OCA certificate</ul><li><strong><em>re-generate</em></strong> and <strong><em>store</em></strong> in non-volatile storage<ul><li>OCA signing key &amp;&amp; self-signed OCA cert<li>PEK &amp;&amp; PEK cert<li>PDH &amp;&amp; and signed by PEK</ul><li>该命令相当于依次调用<ul><li>SHUTDOWN<li>PLATFORM_RESET<li>INIT</ul></ul></ul><h5 id="pek_csr"><span class="me-2">PEK_CSR</span><a href="#pek_csr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>overflow<ul><li>可以结合 PEK_CERT_IMPORT 命令使用. 该命令会生成一个CSR(cert sign request?). 该CSR中包含<ul><li>platform information<li>PEK public key</ul><li>之后CA则会根据CSR中的infomration, key 签署一个证书</ul><li>action<ul><li>该命令主要是生成CSR<li><p>CSR的格式和 SEV CERT 的格式相同，只不过 signatures 字段都是0</p><p><img src="pic/SEV_CERT.png" alt="SEV_CERT" /></p><blockquote><p>NOTE</p><p>但是这里有个疑问，SEV CERT 需要签署两次(OCA, CEK 双签署），那导出 的CSR中有没有CEK 签名</p></blockquote></ul></ul><h4 id="pek_cert_import"><span class="me-2">PEK_CERT_IMPORT</span><a href="#pek_cert_import" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li><p>该命令结合PEK_CSR命令一起使用。CSR由 platform owner ca签署后会用其 OCA签署 CSR。然后，再在platform侧，执行该命领将签署好的PEK和OCA倒入导入 platform</p><p>但是需要注意的是, 这个过程需要在trusted envirment中执行。</p></ul><li>action<ul><li>该platform 必须是self-owned. 需要确保caller 已经通过PEK_GEN命令重新 生成了PEK，所以该PEK没有被 任何owner签署<li>OCA 和 PEK 证书会被验证。验证过程包括以下几个步骤：<ul><li>The algorithms of the PEK and OCA must be supported<li>The version of the PEK and OCA certificates must be supported<li>The PEK certificate must match the current PEK<li>The OCA signature on the PEK certificate must be valid</ul><li>OCA cert and PEK signature written into platform context(不用在执行INIT了） and non-volatile stroage<li>PDH is <strong><em>regenerated</em></strong> and signed with the new PEK</ul></ul><h4 id="pdh_gen"><span class="me-2">PDH_GEN</span><a href="#pdh_gen" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>该命令可以根据需要多次重新生成 PDH。请注意，如果其他实体正在使用当前的 PDH 来建立用于加密数据或进行完整性校验的密钥，那么重新生成 PDH 会使任何正在进行的密钥协商操作失效。在这种情况下，其他实体必须获取新的 PDH，才能继续进行密钥协商。</ul></ul><h4 id="pdh_cert_export"><span class="me-2">PDH_CERT_EXPORT</span><a href="#pdh_cert_export" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow 这个命令用于获取当前平台的PDH。常用于导出到remote entities 来建立安全的传输通道（例如热迁移)<li><p>actions</p><p>导出如下数据:</p><ul><li>PDH cert<li>CEK cert<li>PEK cert<li>OCA cert</ul></ul><h3 id="platform-api-usage-flows--platform-provisioning"><span class="me-2">PLATFORM API USAGE FLOWS – Platform Provisioning</span><a href="#platform-api-usage-flows--platform-provisioning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img src="pic/Platform_Provisioning_Usage_flows.png" alt="Platform_Provisioning_Usage_flows" /></p><ol><li>执行 <code class="language-plaintext highlighter-rouge">FACTORY_RESET</code> 恢复出厂设置.<li>厂商请求 初始化 SEV<li>platform执行INIT<li>厂商请求 PEK 签署, platform 执行 PEK_CSR 生成 CSR<li>厂商生成 PEK cert, 并用 CA signing key 签署(OCA)<li>platform 执行<code class="language-plaintext highlighter-rouge">PEK_CERT_IMPORT</code>进行 PEK_CERT，以及OCA CERT导入</ol><h3 id="summary"><span class="me-2">SUMMARY</span><a href="#summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>platform API 主要是管理平台的生命周期，例如设备生产后的各类证书 生成，设备reset等等。</p><p>但是<code class="language-plaintext highlighter-rouge">PDH_CERT_EXPORT</code>命令则可能用在虚拟机的生命周期的管理中，我们 下面会看到</p><h2 id="guest-management-api"><span class="me-2">GUEST Management API</span><a href="#guest-management-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>和platform Management 类似，guest Management API 用于管理 guest context, 从而作用于guest 生命周期管理.</p><h3 id="guest-context"><span class="me-2">Guest Context</span><a href="#guest-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img src="pic/GCTX.png" alt="GCTX" /></p><p>如果说Platform Context 是platform 粒度，是全局的，则<code class="language-plaintext highlighter-rouge">Guest Context</code> 则是VM粒度，是每个vm独有的，我们关注下面的字段</p><ul><li>STATE:<ul><li>UNINIT<li>LUPDATE: guest current being launched and plaintext data and VMCS save area are being imported &gt; 正在导入明文<li>LSECRET: The guest is currently being launched and ciphertext data are being imported. &gt; 正在导入密文<li>RUNNING: guest is fully launched or migrated in, and not being migrated out to another machine. &gt; 已经launched 或者迁入，并且没有在迁出<li>SUPDATE: The guest is currently being migrated out to another machine.<li>RUPDATE: The guest is currently being migrated from another machine.<li>SENT: The guest has been sent to another machine.</ul><p>每个sev vm 在运行过程中都会经历一个 finite state machine(有限状态机). 固件只会 在每个虚拟机的特定state下，才能执行某些命令</p><li>HANDLE: 用于唯一标识 guest<li>ASID: 上面说过, memory controller中有个加密模块，其是识别TLB中的 ASID 作为密钥ID, 来索引相关密钥<li>ACTIVE:<li>POLICY: 用于描述当前虚拟机的sev策略，例如SEV, SEV-SP<li> <font color="blue"><strong>VEK: The memory encryption key of the guest</strong></font><li>NONCE: 当前与该虚拟机关联的可信通道随机数<li>MS: The master secret current associated with this guest. ??<li>TEK: transport encryption key<li><p>TIK: transport integrity key</p><p>(热迁移时候会用到)</p><li>LD: 该虚拟机的启动摘要上下文</ul><h3 id="guest-management-apis"><span class="me-2">GUEST Management APIs</span><a href="#guest-management-apis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><tbody><tr><td>name<td>State restrictions for executing<td>state change<td> <tr><td>LAUNCH_START<td>新创建<td>GSTATE(UNINIT-&gt; LUPDATE) PSTATE(-&gt;WORKING)<td> <tr><td>LAUNCH_UPDATE_DATA<td>PSTATE.WORKING &amp;&amp; GSTATE.LUPDATE<td>NOT CHANGE<td> <tr><td>LAUNCH_UPDATE_MEASURE<td>PSTATE.WORKING &amp;&amp; GSTATE.LUPDATE<td>GSTATE(LUPDATE-&gt;LSECRET)<td> <tr><td>LAUNCH_SECERT<td>PSTATE.WORKING &amp;&amp; GSTATE.LSECRET<td>NOT CHANGE<td> <tr><td>LAUNCH_FINISH<td>PSTATE.WORKING &amp;&amp; GSTATE.LSECRET<td>GSTATE.RUNNING<td>NOT CHANGE</table></div><h4 id="launch_start"><span class="me-2">LAUNCH_START</span><a href="#launch_start" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>该命令用于通过使用新的 VEK 对虚拟机内存进行加密，从而引导（初始化）一个虚拟机。 此命令会创建一个由 SEV 固件管理的虚拟机上下文，之后可以通过返回给调用者的HANDLE来 引用该上下文.</ul><li>action<ul><li>如果HANDLE字段是0， 会生成一个新的VEK. 如果不是0，会检查下面字段:<ul><li>HANDLE is a valid guest<li>GUEST[HANDLE].POLICY 和 传入的POLICY field 相同<li><p>POLICY.NOKS == 0 (需要共享)</p><li>如果上述检查过了，则会将HANDLE 指向的 VEK copy到the new guest context (相当于dup())</ul><li>new guest handle written to HANDLE field<li>init GCTX.LD<li>version check<ul><li>检查参数POLICY 字段中的API_MAJOR和API_MINOR是否满足要求:<ul><li>PLATFORM.API_MAJOR &gt; POLICY.API_MAJOR or<li><p>PLATFORM.API_MAJOR == POLICY.API_MAJOR and PLATFORM.API_MINOR &gt;= POLICY.API_MAJOR</p><p>(向下兼容)</p></ul></ul><li>DH_CERT_PADDR: 如果其为0， 则 忽略如下字段:<ul><li>DH_CERT_LEN<li>SECTION_PADDR<li>SECTION_LEN<blockquote><p>NOTE</p><p>为什么要这样做呢? 因为PDH cert, 就是为了建立其安全的加密通道, 而其建立安全加密通道的信息，就保存在SECTION 中, 下面会看到</p></blockquote></ul></ul><li><p>params:</p><p><img src="pic/LAUNCH_START_params.png" alt="LAUNCH_START_params" /></p></ul><h4 id="launch_update_data"><span class="me-2">LAUNCH_UPDATE_DATA</span><a href="#launch_update_data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>使用VEK加密guest data</ul><li>action<ul><li>GCTX.LD: 被更新为 PADDR指向的明文。而明文被guest的VEK 加密为存放在PADDR处<h4 id="launch_update_vmsa"><span class="me-2">LAUNCH_UPDATE_VMSA</span><a href="#launch_update_vmsa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>(和 SEV-ES相关，略)</p></ul></ul><h4 id="launch_measure"><span class="me-2">LAUNCH_MEASURE</span><a href="#launch_measure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>该命令返回launched guest’s memory pages 和 VMCB areas(SEV-ES). 测量的结果使用 TIK 作为密钥，guest owner可以使用该测量结果验证launch 过程没有被干预</ul><li>action<ul><li>GCTX.LD最终被封存为导入guest的所有明文的hash digest.<li>launch measurement 最终被计算为:<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>HMAC(0x04 || API_MAJOR || API_MINOR || BUILD || GCTX.POLICY || GCTX.LD ||
MNONCE; GCTX.TIK)
</pre></table></code></div></div><blockquote><p>NOTE</p><ul><li><code class="language-plaintext highlighter-rouge">||</code>表示拼接.<li>MNONCE 在这个过程中 fw 随机生成的<li>用GCTX.TIK加密</ul></blockquote><li>将计算结果写入 <code class="language-plaintext highlighter-rouge">MEASURE</code> 字段</ul><li><p>params</p><p><img src="pic/LAUNCH_MEASURE_param.png" alt="LAUNCH_MEASURE_param" /></p><p><img src="pic/LAUNCH_MEASURE_Measurement_Buffer.png" alt="LAUNCH_MEASURE_Measurement_Buffer" /></p><blockquote><p>NOTE</p><p><code class="language-plaintext highlighter-rouge">MNONCE</code> 在这个过程中的作用, 就是用来验证完整性的, <code class="language-plaintext highlighter-rouge">MEASURE_PADDR.MEASURE</code>(HMAC) 中存放密文, 而<code class="language-plaintext highlighter-rouge">MEASURE_PADDR.MNONCE</code> 中存放明文. 而HMAC中被加密的<code class="language-plaintext highlighter-rouge">MNONCE</code> 只有FW知道,</p><font color="red"><strong> 所以该字段用于验证`MEASURE_PADDR.MEASURE`完整性. </strong></font><h4 id="launch_secret"><span class="me-2">LAUNCH_SECRET</span><a href="#launch_secret" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></blockquote><li>overflow<ul><li>inject a secret into guest, 在launch measurement 已经被guest owner收到并验证 通过后执行该cmd</ul><li>action<ul><li>verfiy MAC field<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>HMAC(0x01 || FLAGS || IV || GUEST_LENGTH || TRANS_LENGTH || DATA || MEASURE; GCTX.TIK)
</pre></table></code></div></div><p>目的是验证该secret的注入方是否是GUEST owner. 通过什么验证呢?</p><ul><li>MEASURE: (只有GUEST OWNER 和 FW知道)</ul><li>DATA 是TRANS_PADDR 指向的密文<li>而 TRANS_PADDR 指向的密文，通过GCTX.TEK 加密<li>如果 FLAGS.COMPRESSED == 1, 生成的明文则会被解压缩，解压后的 结果会被写入 GUEST_PADDR, 并通过 VM 的VEK 进行加密.</ul><li><p>parameters</p><p><img src="pic/LAUNCH_SECRET_params.png" alt="LAUNCH_SECRET_params" /></p></ul><blockquote><p>NOTE</p><p>该过程比较复杂，我们在这里做下小结:</p><p>该流程的目的是，guest owner将一个secret 通过 LAUNCH_SECRET 注入到guest中。</p><p>首先遇到的一个问题是，怎么确定该”secret” 是guest owner 传过来的，另外，怎么 确定, 该”secret”有没有被篡改。</p><p>首先，确定一个数据有没有被篡改。SEV FW常用的方式是，在明文参数中放一个字段存储 该数据, 另外在使用HMAC()将所有需要保证完整性的数据进行打包。</p><p>例如，通过对比Packet Header Buffer中的 IV和 MAC中解密后的IV可以判断，HMAC中的 数据有没有被篡改</p><p>另外，怎么验证该secret 是guest owner传递过来的呢? （<strong><em>下面纯属猜测</em></strong>)</p><p>通过MEASURE字段，MEASURE字段只有guest owner和 SEV fw 知道。SEV fw会在执行该命 令之前首先对该字段做验证. (如果真是这样, IV 字段有些多余) (GCTX.LD) field</p><p>保证数据的完整性已经做到，那还需要保证数据加密，不会外界获取。方法是通过TEK 加密 TRANS_PADDR 中指向的数据。</p><p>传递到platform侧后, sev fw会将该密文通过TEK解密，然后通过VEK加密，最终数据在内存 中被host 观测到的是通过VEK 加密过的。而在guest中，则可以通过SME机制获取到解密 后的数据</p></blockquote><h4 id="launch_finish"><span class="me-2">LAUNCH_FINISH</span><a href="#launch_finish" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>该命令用于将guest state 置为 可以RUN 的状态.</ul><li>action<ul><li>zero following GCTX field: TEK, TIK, MS, NONCE, LD</ul></ul><h4 id="attestaton"><span class="me-2">ATTESTATON</span><a href="#attestaton" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>该命令生成一个报告，其中包括通过<code class="language-plaintext highlighter-rouge">LAUNCH_UPDATE_*</code>命令传递的guest memory，以及 VMSA的SHA-256 digset。该摘要于guest memory 在 LAUNCH_MEASURE中使用的 digset一致。</ul><li><p>parameters</p><p><img src="pic/ATTESTATION_command_buffer.png" alt="ATTESTATION_command_buffer" /></p></ul><h4 id="send_start"><span class="me-2">SEND_START</span><a href="#send_start" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>该命令用于热迁移前的准备工作（源端)</ul><li>action<ul><li>valiate<ul><li>IF GCTX.POLICY.NOSEND != 0, return error<li>IF GCTX.POLICY.SEV == 0. PDH, PEK, CEK, ASK, ARK cert 才被认为有效<li>check API Version.<li>GCTX.POLICY: PDH - PEK - OCA 将被会验证(验证过程没说, 是否验证到ARK?, 感 觉可能会，因为其已经传过来了)<li>如果guest policy required?? 验证PDH, PEK, OCA, CEK , ARK, ASK证书链.</ul><li>重新生成 NONCE<li><p>通过NONCE, PDH_CERT(dst) 以及 <font color="red"><strong>PCTX.PDH(src) private key</strong></font> 计算master secret，然后生成新的TEK, TIK传输密钥，然后根据下图对传输密钥重新封装， 将封装后的结果写入WRAP_TK, WRAP_IV, WRAP_MAC</p><p><img src="pic/KEK.png" alt="KEK" /></p><li>GCTX.POLICY 被写在 POLICY field, 并且被TIK 摘要，并写到 POLICY_MAC 字段.</ul><li><p>parameters</p><p><img src="pic/SEND_START_PARAM1.png" alt="SEND_START_PARAM1" /></p><p><img src="pic/SEND_START_PARAM2.png" alt="SEND_START_PARAM2" /></p><p><img src="pic/SEND_START_PARAM3.png" alt="SEND_START_PARAM3" /></p><li><p>summary</p><p>该命令在热迁移过程中十分关键, 其工作主要分为四部分</p><ul><li>验证dst 端 证书链<li>通过两边的PDH (dst public key, source private key) 以及NONCE 生成master secret.<li>通过master secret 派生KIK, KEK<li>生成TEK, TIK，IV, 并通过KEK 加密生成WRAP_TK, WRAP_IV, 然后对WRAP_TK 使用KIK 进行认 证标签.</ul><p>主要是为了达成 安全传输 TEK, TIK 的目的，为之后加密数据的传输做准备.</p></ul><h4 id="send_update_data"><span class="me-2">SEND_UPDATE_DATA</span><a href="#send_update_data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>导出guest memory 到另一个platform</ul><li>action<ul><li>新生成IV<li>通过GCTX.VEK解密（手册中没有写, 但是个人认为这个流程必须先用VEK解密)<li>将GUEST_PADDR 指向的数据，通过 GCTX.TEK 加密, 写入TRANS_PADDR中;<li>计算MAC<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>HMAC(0x02 || FLAGS || IV || GUEST_LENGTH || TRANS_LENGTH || DATA;
GCTX.TIK)
</pre></table></code></div></div><p>其中DATA 是<code class="language-plaintext highlighter-rouge">TRANS_PADDR</code>指向的密文</p></ul></ul><h4 id="send_update_vmsa"><span class="me-2">SEND_UPDATE_VMSA</span><a href="#send_update_vmsa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>略</p><h4 id="send_finish"><span class="me-2">SEND_FINISH</span><a href="#send_finish" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>finalizes the send operational flow</ul><li>action<ul><li>The following fields of the guest context are zeroed:<ul><li>GCTX.TEK<li>GCTX.TIK<li>GCTX.MS<li>GCTX.NONCE</ul></ul></ul><h4 id="send_cancel"><span class="me-2">SEND_CANCEL</span><a href="#send_cancel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>This command cancels the send operational flow</ul><li>action<ul><li>The following fields of the guest context are zeroed:<ul><li>GCTX.TEK<li>GCTX.TIK<li>GCTX.MS<li>GCTX.NONCE</ul></ul></ul><h4 id="receive_start"><span class="me-2">RECEIVE_START</span><a href="#receive_start" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>import a guest from one platform to anther<li>常见的使用方式:<ul><li>在热迁仪目的端使用<li>在磁盘上恢复guest</ul></ul><li>action<ul><li>create a new guest context<li>如果HANDLE字段为0，则生成一个新的VEK, 如果不是0, 则检查如下字段<ul><li>HANDLE is a valid guest<li>GUESTS[HANDLE].POLICY is equal to the POLICY field<li>The MAC of the POLICY is valid<li>POLICY.NOKS is zero</ul><p>如果上述检查通过，HANDLE指向的guest的VEK 将copy到新的GCTX</p><li>write new guest handle to HANDLE<li> <font color="red"><strong>通过NONCE 和 PDH_CERT(src) 以及PCTX.PDH private key(dst) </strong></font><p>计算<code class="language-plaintext highlighter-rouge">master secret</code></p><li>通过master secret 派生 KEK, KIK 以及参数中的WRAP_IV, WRAP_MAC来解密并 验证 WRAP_TK，从而得到TEK, TIK<li>使用 TIK 和 GCTX.POLICY 得到MAC，然后在和POLICY_MAC 字段进行对 比验证<li>验证 <code class="language-plaintext highlighter-rouge">GCTX.POLICY.API</code> 和 <code class="language-plaintext highlighter-rouge">POLICY.API_MAJOR</code>.<li>POLICY.ES 相关</ul><li><p>parameters:</p><p><img src="pic/RECEIVE_START.png" alt="RECEIVE_START" /></p><p><img src="pic/RECEIVE_START_param2.png" alt="RECEIVE_START_param2" /></p><li><p>summary</p><p>该命令主要工作:</p><ul><li>创建新的GCTX<li>验证src端传过来的各类数据<li>导入从src端获取来的数据，从而建立起加密信道（主要是TEK)</ul></ul><h4 id="receive_update_data"><span class="me-2">RECEIVE_UPDATE_DATA</span><a href="#receive_update_data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>import guest memory</ul><li>action<ul><li>verify data area though computing MAC<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>HMAC(0x02 || FLAGS || IV || GUEST_LENGTH || TRANS_LENGTH || 
DATA;GCTX.TIK)
</pre></table></code></div></div><li>通过GCTX.TEK 和IV field 解密 data<li>将解密后的数据通过GCTX.VEK再次加密，并写入GUEST_PADDR指向的内存.</ul><li><p>parameters</p><p><img src="pic/RECEIVE_UPDATE_DATA_params.png" alt="RECEIVE_UPDATE_DATA_params" /></p></ul><h4 id="receive_update_vmsa"><span class="me-2">RECEIVE_UPDATE_VMSA</span><a href="#receive_update_vmsa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>(略)</p><h4 id="receive_finish"><span class="me-2">RECEIVE_FINISH</span><a href="#receive_finish" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>overflow<ul><li>结束 RECEIVE work flow</ul><li>actions<ul><li>清空如下guest context 字段:<ul><li>GCTX.TEK<li>GCTX.TIK<li>GCTX.MS<li>GCTX.NONCE<h4 id="guest_status"><span class="me-2">GUEST_STATUS</span><a href="#guest_status" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="activate"><span class="me-2">ACTIVATE</span><a href="#activate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></ul></ul><li>overflow<ul><li>该命令用于通知固件, VM 已经绑定到特定的ASID。随后固件将会将该虚拟机的VEK 加 载到 ASID 对应的 memory controller 的key slot 中。当guest 是RUNNING状态， 所有Cache Core Complexes 都可以执行该guest.<h4 id="deactivate"><span class="me-2">DEACTIVATE</span><a href="#deactivate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></ul><li>overflow<ul><li>This command is used to dissociate the guest from its current ASID. The firmware will uninstall the guest’s key from the memory controller and disallow use of the ASID by all CCXs.<h4 id="df_flush"><span class="me-2">DF_FLUSH</span><a href="#df_flush" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></ul><li>overflow<ul><li>在该命令用于deactivate 一个或多个guest后执行<li>在执行该命令之前需要先执行WBINVD<li>该命令用于 flush 每个core上的 data fabric write buffers<h4 id="others"><span class="me-2">OTHERS</span><a href="#others" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>TODO</p></blockquote></ul></ul><h2 id="参考链接"><span class="me-2">参考链接</span><a href="#参考链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><a href="https://blog.csdn.net/huang987246510/article/details/135487665?spm=1001.2014.3001.5501">huangyong - AMD SEV基本原理</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/white-papers/memory-encryption-white-paper.pdf">AMD MEMORY ENCRYPTION</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/white-papers/SEV-SNP-strengthening-vm-isolation-with-integrity-protection-and-more.pdf">AMD SEV SNP</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/programmer-references/55766_SEV-KM_API_Specification.pdf">Secure Encrypted Virtualization API Version 0.24</a><li><a href="https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/58019.pdf">Secure VM Service Module for SEV-SNP Guests</a><li><a href="https://www.youtube.com/watch?v=RYIjUweFysA">YouTube – SNP Live Migration with guest-memfd and mirror VM </a><li><a href="https://github.com/AMDESE/linux-svsm">Git – linux-svsm</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/coco/">coco</a>, <a href="/categories/sev/">sev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/sev/" class="post-tag no-text-decoration" >sev</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=sev%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Famd-sev%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=sev%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Famd-sev%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Famd-sev%2F&text=sev%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/virtio-notify/">virtio notify</a><li class="text-truncate lh-lg"> <a href="/posts/virtio/">一文搞懵IO虚拟化之 -- virtio</a><li class="text-truncate lh-lg"> <a href="/posts/bpf-ISA/">Bpf Isa</a><li class="text-truncate lh-lg"> <a href="/posts/bpf-jit/">Bpf Jit</a><li class="text-truncate lh-lg"> <a href="/posts/bpf-verify/">Bpf Verify</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/coroutine/" class="btn btn-outline-primary" aria-label="Older" ><p>qemu coroutine</p></a> <a href="/posts/svm-overflow/" class="btn btn-outline-primary" aria-label="Newer" ><p>svm</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/pcie/">pcie</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/cache/">cache</a> <a class="post-tag btn btn-outline-primary" href="/tags/io-virt/">io_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/kvm/">kvm</a> <a class="post-tag btn btn-outline-primary" href="/tags/live-migration/">live_migration</a> <a class="post-tag btn btn-outline-primary" href="/tags/perftest/">perftest</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
