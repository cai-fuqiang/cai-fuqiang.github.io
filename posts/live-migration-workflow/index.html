<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="live migration" /><meta name="author" content="fuqiang" /><meta property="og:locale" content="en" /><meta name="description" content="热迁移简述" /><meta property="og:description" content="热迁移简述" /><link rel="canonical" href="/posts/live-migration-workflow/" /><meta property="og:url" content="/posts/live-migration-workflow/" /><meta property="og:site_name" content="one step at a time" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-12T23:20:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="live migration" /><meta name="twitter:site" content="@fuqiang_cai" /><meta name="twitter:creator" content="@fuqiang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fuqiang"},"dateModified":"2024-11-12T23:20:00+08:00","datePublished":"2024-11-12T23:20:00+08:00","description":"热迁移简述","headline":"live migration","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/live-migration-workflow/"},"url":"/posts/live-migration-workflow/"}</script><title>live migration | one step at a time</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="one step at a time"><meta name="application-name" content="one step at a time"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="preconnect" href="https://cdnjs.cloudflare.com" ><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"></a><h1 class="site-title"> <a href="/">one step at a time</a></h1><p class="site-subtitle fst-italic mb-0">a noob's growing diary</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/cai-fuqiang" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/fuqiang_cai" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['iwng86','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>live migration</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>live migration</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1731424800" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 12, 2024 </time> </span><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3475 words" > <em>19 min</em> read</span></div></div></div></header><div class="content"><h2 id="热迁移简述"><span class="me-2">热迁移简述</span><a href="#热迁移简述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>热迁移(live migration) 可以在虚拟机正在RUNNING时，对用户透明的从 source host 迁移到dest host.</p><ol><li><p>涉及迁移对象种类</p><p>热迁移的流程会大概包含几个对象:</p><ul><li>cpu<li>内存<li>设备</ul><li><p>主要工作</p><p>而热迁移主要工作是将这几个对象的信息，从原端 copy到目的端，并且 做好sync工作。</p><p>由于不停机vm，vcpu还会更改一些对象状态。例如: 内存，可能在迁移完 一个page后，该page由于vcpu还在跑, 有可能又有更改。这时，qemu还需要 track到该page，并完成对该page的再一次的迁移。</p><li><p>如何做到避免在热迁移过程中影响vcpu</p><p>迁移线程和vcpu线程是不同线程, 所以热迁移时，qemu进程会新增一个进程。</p><li>如何评价一个热迁移流程的质量<ul><li>downtime: 热迁移过程中，虚拟机暂停的时间<li>migration total time: 迁移总时间<li>vm performance during migration: 迁移过程中虚拟机运行效率</ul><li><p>对象分类</p><p>对于热迁移的对象来说，主要分为两类</p><ol><li>对象传输数据量大(典型内存)<li>对象传输数据量小(典型cpu apic)</ol><p>为什么要这样分呢?</p><p>假设, 在某个环境下, 虚拟机内存为2G , 而网络传输2G的数据需要60s. 而CPU apic的传输数据仅为4096, 传输时间 0.0001s。这两个对象都会在 vm running时频繁改变，但是如果要将内存迁移完全放到虚拟机暂停之后， 在传输。虚拟机内的服务可能没有办法接受，但是对于CPU而言由于数据量 小，vm可能能接受该停机时间。</p></ol><p>热迁移还有一些限制条件, e.g.:</p><ol><li>对存储有一定的限制: 要使用共享存储，例如nbd,nfs<li>两端的CPU类型要一致<li>两端虚拟化相关的software要一致，例如KVM, QEMU, ROM等等.<li>两端vm的machine-type, cpuid要一致。</ol><p>我们接下来，结合代码流程分析细节.</p><h2 id="热迁移主要流程分析"><span class="me-2">热迁移主要流程分析</span><a href="#热迁移主要流程分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="迁移对象注册"><span class="me-2">迁移对象注册</span><a href="#迁移对象注册" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上面提到过，迁移过程可能涉及一些对象。qemu定义了 <code class="language-plaintext highlighter-rouge">SaveStateEntry</code>数据 结构来描述每一个迁移对象:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">SaveStateEntry</span> <span class="p">{</span>
    <span class="n">QTAILQ_ENTRY</span><span class="p">(</span><span class="n">SaveStateEntry</span><span class="p">)</span> <span class="n">entry</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">idstr</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">instance_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">alias_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">version_id</span><span class="p">;</span>
    <span class="cm">/* version id read from the stream */</span>
    <span class="kt">int</span> <span class="n">load_version_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">section_id</span><span class="p">;</span>
    <span class="cm">/* section id read from the stream */</span>
    <span class="kt">int</span> <span class="n">load_section_id</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SaveVMHandlers</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">VMStateDescription</span> <span class="o">*</span><span class="n">vmsd</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">;</span>
    <span class="n">CompatEntry</span> <span class="o">*</span><span class="n">compat</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">is_ram</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SaveStateEntry</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>entry: 用户链接每个迁移对象<li>idstr: 唯一标识该对象<li>instance_id: 表示设备实例编号<li>…id: 先ignore<li>ops, vmsd: 下面详细介绍<li>opaque: 模块注册时，提供给热迁移过程中用到的结构体<li>is_ram: is ram or not ?</ul><p>上面提到过，对象主要分为两类, 一种是热迁移过程中需要一直sync的。 另一种是可以在虚拟机暂停时，一次传输完成的。</p><p>第一种会准备一个<code class="language-plaintext highlighter-rouge">SaveVMHandlers</code>, 存放到<code class="language-plaintext highlighter-rouge">SaveStateEntry</code>中的ops成员中。 在热迁移的几个阶段来调用。</p><p>第二种会准备一个<code class="language-plaintext highlighter-rouge">VMStateDescription</code>,存放在<code class="language-plaintext highlighter-rouge">SaveStateEntry</code>中的<code class="language-plaintext highlighter-rouge">vmsd</code>, 该函数也会有一些回调。(!!!)</p><p>两类的注册流程如下, 以内存和apic为例</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>ram_mig_init
  register_savevm_live {
    ops = savevm_ram_handlers,
    opaque = ram_state
  }

apic_common_realize
  vmstate_register_with_alias_id {
    vmsd = vmstate_apic_common,
    opaque = APICCommonState
  }

ram_mig_init -- SaveStateEntry(mem)         ---+
                                                \
apic_common_realize --SaveStateEntry(apic)  -----+---- link to savevm_state.handlers
</pre></table></code></div></div><p>第一类相关的，我们在下面称为<code class="language-plaintext highlighter-rouge">T_ram</code>, 而第二类相关的，我们 称为<code class="language-plaintext highlighter-rouge">T_apic</code></p><h3 id="迁移线程"><span class="me-2">迁移线程</span><a href="#迁移线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上面提到过，为了避免对vcpu的性能产生影响，qemu创建了一个单独的migration thread 来做热迁移工作。我们来看下相关堆栈:</p><p>在qemu monitor 中输入migrate 命令后:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>hmp_migrate
  =&gt; qmp_migrate
     =&gt; if (channels) addr = channels-&gt;value-&gt;addr //获取到dest channel addr
     //仅分析tcp
     =&gt; socket_start_outgoing_migration
        =&gt; qio_channel_socket_connect_async
           =&gt; socket_outgoing_migration
              =&gt; migration_channel_connect
                 =&gt; migrate_fd_connect
                    //创建迁移线程
                    =&gt; qemu_thread_create -- migration_thread
</pre></table></code></div></div><p>迁移线程<code class="language-plaintext highlighter-rouge">migration_thread</code>中调用函数流程如下:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre>migration_thread
   <span class="c"># NOTE</span>
   <span class="c">#</span>
   <span class="c"># 下面的save的意思，就是迁移，将source端的数据copy并存储</span>
   <span class="c"># 到目的端</span>
   <span class="c"># </span>
   <span class="c"># T_ram 和一些公共流程，我们用1,2,3标出</span>
   <span class="c"># T_apic 我们用1(t_apic),2(t_apic)...标出</span>
   <span class="c">#</span>
   <span class="o">=&gt;</span> qemu_savevm_state_header
   <span class="c"># </span>
   <span class="c"># T_ram: 1.完成迁移前的准备工作</span>
   <span class="o">=&gt;</span> qemu_savevm_state_setup   
      <span class="o">=&gt;</span> for_each<span class="o">(</span>savevm_state.handlers<span class="o">)</span>
         <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>vmsd-&gt;early_setup<span class="o">)</span> vmstate_save<span class="o">()</span> <span class="k">continue</span>
         <span class="o">=&gt;</span> se-&gt;ops-&gt;save_setup<span class="o">()</span>
   <span class="c"># 2. 热迁移主流程，在里面会进行持续循环，直到状态满足要求</span>
   <span class="o">=&gt;</span> foreach<span class="o">(</span>s-&gt;state <span class="o">==</span> ms_ACTIVE <span class="o">||</span> ms_POSTCOPY_ACTIVE<span class="o">)</span>
      <span class="o">=&gt;</span> migration_iteration_run<span class="o">(</span>简单描述可能执行到的函数<span class="o">)</span>
         <span class="c"># 3. 计算本轮还要 copy的数量粗略的</span>
         <span class="o">=&gt;</span> qemu_savevm_state_pending_estimate
            <span class="o">=&gt;</span> for_each<span class="o">(</span>savevm_state.handlers<span class="o">)</span>
               se-&gt;ops-&gt;state_pending_estimate<span class="o">()</span>
         <span class="c"># 4. 将pending_size &lt; s-&gt;threshold_size时，需要</span>
         <span class="c">#    精细的获取下还要copy的数量</span>
         <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>pending_size &lt; s-&gt;threshold_size<span class="o">)</span> 
            <span class="o">{</span>
               <span class="o">=&gt;</span> qemu_savevm_state_pending_exact<span class="o">()</span>
                  <span class="o">=&gt;</span> for_each<span class="o">(</span>savevm_state.handlers<span class="o">)</span>
                     se-&gt;ops-&gt;state_pending_exact<span class="o">()</span>
            <span class="o">}</span>
         <span class="o">=&gt;</span> <span class="c"># 7. 如果真的达到了s-&gt;threshold_size,  则认为可以暂停虚拟机了</span>
            <span class="c">#    然后将剩下的信息一次性copy完</span>
            migration_completion<span class="o">()</span>
            <span class="o">=&gt;</span> migration_completion_precopy
               <span class="o">=&gt;</span> migration_stop_vm
                  <span class="o">=&gt;</span> vm_stop_force_state
                     <span class="o">=&gt;</span> vm_stop
                        <span class="o">=&gt;</span> do_vm_stop
                           <span class="o">=&gt;</span> pause_all_vcpus
                           <span class="o">=&gt;</span> vm_state_notify
                           <span class="o">=&gt;</span> bdrv_drain_all
                           <span class="o">=&gt;</span> bdrv_flush_all
               <span class="o">=&gt;</span> qemu_savevm_state_complete_precopy
                  <span class="c"># 7.1 将剩余的全部save完</span>
                  <span class="o">=&gt;</span> qemu_savevm_state_complete_precopy_iterable
                     <span class="o">=&gt;</span> foreach<span class="o">(</span>savevm_state.handlers<span class="o">)</span>
                        <span class="o">=&gt;</span> se-&gt;ops-&gt;save_live_complete_precopy<span class="o">()</span>
                  <span class="c"># 7.2(t_apic)</span>
                  <span class="c"># 在该流程中，我们将T_apic类型的对象全部迁移完，注意</span>
                  <span class="c"># 此时，vcpu已经全部pause了。</span>
                  <span class="o">=&gt;</span> qemu_savevm_state_complete_precopy_non_iterable
                     <span class="o">=&gt;</span> foreach<span class="o">(</span>savevm_state.handlers<span class="o">)</span>
                        vmstate_save<span class="o">()</span>
                         vmstate_save_state_with_err
                          <span class="o">=&gt;</span> vmstate_save_state_v
                             <span class="o">=&gt;</span> vmsd-&gt;pre_save<span class="o">()</span>
                             <span class="o">=&gt;</span> <span class="o">!!</span>进行vmsd递归!! OR field-&gt;info-&gt;put<span class="o">()</span>
                             <span class="o">=&gt;</span> vmsd-&gt;post_save<span class="o">()</span>
                             <span class="c">#  (t_apic)对每一个subsection做savestate</span>
                             <span class="o">=&gt;</span> vmstate_subsection_save
                                <span class="o">=&gt;</span> foreach<span class="o">(</span>subsection<span class="o">)</span>
                                   <span class="o">=&gt;</span> vmstate_save_state_with_err
            <span class="o">=&gt;</span> OR: migration_completion_postcopy
         <span class="c"># 5. 进行实际的数据save</span>
         <span class="o">=&gt;</span> qemu_savevm_state_iterate<span class="o">()</span>
            <span class="o">=&gt;</span> for_each<span class="o">(</span>savevm_state.handlers<span class="o">)</span>
               se-&gt;ops-&gt;save_live_iterate<span class="o">()</span>
   <span class="c"># 6. 会根据带宽, 用户允许的downtime来更新 热迁移过程中的一些条件和限制信息，</span>
   <span class="c">#    e.g., threshold_size, pages_per_second</span>
   <span class="o">=&gt;</span> urgent <span class="o">=</span> migration_rate_limit<span class="o">()</span><span class="p">;</span>
   <span class="c"># END. 8. 热迁移结束， cleanup资源</span>
   <span class="o">=&gt;</span> migration_iteration_finish
      <span class="o">=&gt;</span> switch s-&gt;state   ... <span class="k">do </span>something
      <span class="o">=&gt;</span> migration_bh_schedule<span class="o">(</span>migrate_fd_cleanup_bh,...<span class="o">)</span>
         <span class="o">=&gt;</span> migrate_fd_cleanup
</pre></table></code></div></div><p>该流程比较复杂，我们按照下面的条目进行展开:</p><ul><li>qemu 热迁移传输<li>ram::save_setup</ul><h3 id="qemu-热迁移传输"><span class="me-2">qemu 热迁移传输</span><a href="#qemu-热迁移传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>qemu使用<code class="language-plaintext highlighter-rouge">MigrationState</code>表示当前热迁移的状态, 其中</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">MigrationState</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">QEMUFile</span> <span class="o">*</span><span class="n">to_dst_file</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">JSONWriter</span> <span class="o">*</span><span class="n">vmdesc</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>to_dst_file: src和dst通信文件fd, src write，source read<li>vmdesc: qemu发送数据都是json格式, 将所要发送的json信息，存储到vmdesc.</ul><p>在<code class="language-plaintext highlighter-rouge">migration_thread()</code> 首先调用<code class="language-plaintext highlighter-rouge">qemu_savevm_state_header()</code>函数, 将迁移数据 的头信息发送出去:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">qemu_savevm_state_header</span><span class="p">(</span><span class="n">QEMUFile</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MigrationState</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">migrate_get_current</span><span class="p">();</span>

    <span class="c1">//新创建一个writer</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">vmdesc</span> <span class="o">=</span> <span class="n">json_writer_new</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

    <span class="n">trace_savevm_state_header</span><span class="p">();</span>
    <span class="c1">//发送 MAGIC, VERSON</span>
    <span class="n">qemu_put_be32</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">QEMU_VM_FILE_MAGIC</span><span class="p">);</span>
    <span class="n">qemu_put_be32</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">QEMU_VM_FILE_VERSION</span><span class="p">);</span>

    <span class="c1">//如果需要发送configuration, 则会讲`vmstate_configuration`</span>
    <span class="c1">//相关数据发送</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">send_configuration</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">qemu_put_byte</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">QEMU_VM_CONFIGURATION</span><span class="p">);</span>

        <span class="n">json_writer_start_object</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vmdesc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">json_writer_start_object</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vmdesc</span><span class="p">,</span> <span class="s">"configuration"</span><span class="p">);</span>
        <span class="n">vmstate_save_state</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmstate_configuration</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">savevm_state</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">vmdesc</span><span class="p">);</span>
        <span class="n">json_writer_end_object</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vmdesc</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是对于某些数据，其没有字段这样的信息（没有vmsd), 这时，就没有必要用json 传输。我们下面会看到.</p><h2 id="ram-save_setup"><span class="me-2">ram:: save_setup</span><a href="#ram-save_setup" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre><td class="rouge-code"><pre>ram_save_setup
<span class="c"># save ram总大小</span>
<span class="o">=&gt;</span> ram_init_all
   <span class="o">=&gt;</span> ram_init_bitmaps
      <span class="o">=&gt;</span> ram_list_init_bitmaps
         <span class="o">=&gt;</span> foreach RAMBlock
            <span class="c"># 新申请一个bmap, 并且bitmap_set全部设置为1,</span>
            <span class="c"># 表示所有页都是脏的，需要全部copy到目的端</span>
            <span class="o">=&gt;</span> block-&gt;bmap <span class="o">=</span> bitmap_new<span class="o">()</span>
            <span class="o">=&gt;</span> bitmap_set<span class="o">(</span>block-&gt;bmap, 0, pages<span class="o">)</span>
            <span class="o">=&gt;</span> block-&gt;clear_bmap<span class="o">()</span>
      <span class="o">=&gt;</span> memory_global_dirty_log_start
         <span class="o">=&gt;</span> <span class="nb">set </span>global_dirty_tracking  bit GLOBAL_DIRTY_MIGRATION
         <span class="o">=&gt;</span> memory_region_transaction_commit
            <span class="o">=&gt;</span> flatview_reset<span class="o">()</span>
               <span class="o">=&gt;</span> flatview_init<span class="o">()</span>
               <span class="o">=&gt;</span> foreach<span class="o">(</span>as<span class="o">)</span> 
                  <span class="o">=&gt;</span> physmr <span class="o">=</span> memory_region_get_flatview_root<span class="o">(</span>as-&gt;root<span class="o">)</span><span class="p">;</span>
                  <span class="o">=&gt;</span> generate_memory_topology<span class="o">(</span>physmr<span class="o">)</span><span class="p">;</span>
                     <span class="o">=&gt;</span> render_memory_region<span class="o">()</span>  <span class="c">## 根据新的拓扑，更新flatview，而在</span>
                                                <span class="c">## 该流程中，实际上只是FlatRange的 </span>
                                                <span class="c">## dirty_log_mask需要更改</span>
                        <span class="o">=&gt;</span> fr.dirty_log_mask <span class="o">=</span> memory_region_get_dirty_log_mask<span class="o">(</span>mr<span class="o">)</span><span class="p">;</span>
                           <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>global_dirty_tracking <span class="o">&amp;&amp;</span> <span class="o">(</span>qemu_ram_is_migratable<span class="o">(</span>rb<span class="o">)</span>
                               <span class="o">||</span>memory_region_is_iommu<span class="o">(</span>mr<span class="o">))</span>
                              <span class="o">=&gt;</span> <span class="k">return </span>mr-&gt;dirty_log_mask | 
                                <span class="o">(</span>1 &lt; &lt; DIRTY_MEMORY_MIGRATION<span class="o">)</span>
            <span class="o">=&gt;</span> address_space_set_flatview       <span class="c">## new view `dirty_log_mask` has </span>
               <span class="o">=&gt;</span> address_space_update_topology_pass
                  <span class="c">## 如果两个flatview完全一样</span>
                  <span class="o">=&gt;</span> compare oldview and newview every ranges[]
                     <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>frold <span class="o">&amp;&amp;</span> frnew <span class="o">&amp;&amp;</span> flatrange_equal<span class="o">(</span>frold, frnew<span class="o">))</span>
                        <span class="c">## 需要看下是否是dirty_log_mask改变</span>
                        <span class="c">## 如果是新增 dirty_log_mask</span>
                        <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>frnew-&gt;dirty_log_mask &amp; ~frold-&gt;dirty_log_mask<span class="o">)</span>
                           <span class="o">=&gt;</span> call all memorylisteners log_start<span class="o">()</span>
                              <span class="o">=&gt;</span> kvm_log_start
                        <span class="c">## 如果是减少 dirty_log_mask</span>
                        <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>frold-&gt;dirty_log_mask &amp; ~frnew-&gt;dirty_log_mask<span class="o">)</span> 
                           <span class="o">=&gt;</span> call all memorylisteners log_stop<span class="o">()</span>
                              <span class="o">=&gt;</span> kvm_log_stop
<span class="o">=&gt;</span> qemu_put_be64<span class="o">(</span>f, ram_bytes_total_with_ignored<span class="o">()</span>
                 | RAM_SAVE_FLAG_MEM_SIZE<span class="o">)</span><span class="p">;</span>
<span class="c"># 遍历每一个memblock</span>
<span class="o">=&gt;</span> foreach<span class="o">(</span>block<span class="o">)</span>
   <span class="o">=&gt;</span> qemu_put_byte<span class="o">(</span>f, strlen<span class="o">(</span>block-&gt;idstr<span class="o">))</span><span class="p">;</span>
      qemu_put_buffer<span class="o">(</span>f, <span class="o">(</span>uint8_t <span class="k">*</span><span class="o">)</span>block-&gt;idstr, strlen<span class="o">(</span>block-&gt;idstr<span class="o">))</span><span class="p">;</span>
      <span class="c"># 当前使用了的mem大小</span>
      qemu_put_be64<span class="o">(</span>f, block-&gt;used_length<span class="o">)</span><span class="p">;</span>
   <span class="o">=&gt;</span> 根据不同内存类型，以及迁移方式进行不同的save
      <span class="o">=&gt;</span> <span class="k">if</span>
         <span class="c"># postcopy 并且block-&gt;page_size 当前block-&gt;page_size 和 max_hg_page_size</span>
         <span class="c"># 不相同, 需要save page_size（为什么postcopy原因未知）</span>
         migrate_postcopy_vm<span class="o">()</span> <span class="o">&amp;&amp;</span> block-&gt;page_size <span class="o">!=</span> max_hg_page_size<span class="o">)</span>
           qemu_put_be64<span class="o">(</span>f, block-&gt;page_size<span class="o">)</span><span class="p">;</span>
         migrate_ignore_shared<span class="o">()</span>
           <span class="c"># ignore shared 不copy memory， 所以仅把首地址传递过去就可以了</span>
           qemu_put_be64<span class="o">(</span>f, block-&gt;mr-&gt;addr<span class="o">)</span><span class="p">;</span>
         migrate_mapped_ram<span class="o">()</span>
           mapped_ram_setup_ramblock<span class="o">()</span>
           <span class="o">{</span>

           <span class="o">}</span>
<span class="o">=&gt;</span> rdma_registration_start<span class="o">(</span>f, RAM_CONTROL_SETUP<span class="o">)</span><span class="p">;</span>
<span class="o">=&gt;</span> rdma_registration_stop<span class="o">(</span>f, RAM_CONTROL_SETUP<span class="o">)</span><span class="p">;</span>

<span class="c"># 根据是否开启了multifd, 选择 save ram  的 方法</span>
<span class="o">=&gt;</span> <span class="k">if </span>migrate_multifd
   <span class="o">=&gt;</span> multifd_ram_save_setup<span class="o">()</span><span class="p">;</span>
   <span class="o">=&gt;</span> migration_ops-&gt;ram_save_target_page <span class="o">=</span> ram_save_target_page_multifd<span class="p">;</span>
<span class="o">=&gt;</span> NO migrate_multifd
   <span class="o">=&gt;</span> migration_ops-&gt;ram_save_target_page <span class="o">=</span> ram_save_target_page_legacy<span class="p">;</span>

<span class="o">=&gt;</span> multifd_ram_flush_and_sync<span class="o">()</span>

<span class="c"># FLAG_EOS 表示本次写入结束</span>
<span class="o">=&gt;</span> qemu_put_be64<span class="o">(</span>f, RAM_SAVE_FLAG_EOS<span class="o">)</span><span class="p">;</span>
<span class="o">=&gt;</span> qemu_fflush<span class="o">(</span>f<span class="o">)</span>
   将信息flush,  也就是发送到目的端
</pre></table></code></div></div><p>总结下，该流程一共有几件事:</p><ul><li>调用 log_start 通知各个memorylistener 要记录dirty log<li>将一些基本信息发送到dist 端<li>做一些multifd, 以及rdma相关初始化</ul><h3 id="kvm_log_start"><span class="me-2">kvm_log_start</span><a href="#kvm_log_start" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">kvm_log_start</code>流程比较简单, 主要有:</p><ul><li>申请dirty_bitmap<li>更新KVMSlots flags, 重新提交 memslots-&gt;kvm</ul><p>流程如下:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>kvm_log_start
  <span class="o">=&gt;</span> kvm_section_update_flags
     <span class="o">=&gt;</span> get slot by mr_section
     <span class="o">=&gt;</span> kvm_slot_update_flags
        <span class="o">=&gt;</span> KVMSlot-&gt;flags <span class="o">=</span> kvm_mem_flags<span class="o">()</span>  <span class="c"># 更新KVMSlots flags</span>
           <span class="o">=&gt;</span> memory_region_get_dirty_log_mask
              <span class="o">=&gt;</span> <span class="k">return </span>flags |<span class="o">=</span> KVM_MEM_LOG_DIRTY_PAGES
        <span class="o">=&gt;</span> kvm_slot_init_dirty_bitmap
           <span class="o">=&gt;</span> mem-&gt;dirty_bitmap <span class="o">=</span> g_malloc<span class="o">()</span>  <span class="c"># 申请dirty_bitmap</span>
           <span class="o">=&gt;</span> mem-&gt;dirty_bmap_size <span class="o">=</span> xxx<span class="p">;</span>
        <span class="o">=&gt;</span> kvm_set_user_memory_region
           <span class="o">=&gt;</span> kvm_vm_ioctl<span class="o">(</span>,KVM_SET_USER_MEMORY_REGION,<span class="o">)</span><span class="p">;</span> <span class="c"># 重新提交给KVM</span>
</pre></table></code></div></div><h3 id="内存信息send"><span class="me-2">内存信息send</span><a href="#内存信息send" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>将一些内存的基本信息息，例如:</p><ul><li>内存总大小，<li>RAMBlock相关信息</ul><p>发送到dst端，并且做一些multifd, 以及rdma 相关流程的初始化</p><p>我们下面看下，具体的RAMBlock setup的流程:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">mapped_ram_setup_ramblock</span><span class="p">(</span><span class="n">QEMUFile</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">RAMBlock</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_autofree</span> <span class="n">MappedRamHeader</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">header_size</span><span class="p">,</span> <span class="n">bitmap_size</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">num_pages</span><span class="p">;</span>

    <span class="c1">//===(1)===</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">g_new0</span><span class="p">(</span><span class="n">MappedRamHeader</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">header_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MappedRamHeader</span><span class="p">);</span>

    <span class="c1">//===(2)===</span>
    <span class="n">num_pages</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">used_length</span> <span class="o">&gt;&gt;</span> <span class="n">TARGET_PAGE_BITS</span><span class="p">;</span>
    <span class="n">bitmap_size</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">num_pages</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

    <span class="cm">/*
     * Save the file offsets of where the bitmap and the pages should
     * go as they are written at the end of migration and during the
     * iterative phase, respectively.
     */</span>
    <span class="n">block</span><span class="o">-&gt;</span><span class="n">bitmap_offset</span> <span class="o">=</span> <span class="n">qemu_get_offset</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">+</span> <span class="n">header_size</span><span class="p">;</span>
    <span class="n">block</span><span class="o">-&gt;</span><span class="n">pages_offset</span> <span class="o">=</span> <span class="n">ROUND_UP</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">bitmap_offset</span> <span class="o">+</span>
                                   <span class="n">bitmap_size</span><span class="p">,</span>
                                   <span class="n">MAPPED_RAM_FILE_OFFSET_ALIGNMENT</span><span class="p">);</span>

    <span class="c1">//==(2.1)==</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">MAPPED_RAM_HDR_VERSION</span><span class="p">);</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">bitmap_offset</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">bitmap_offset</span><span class="p">);</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">pages_offset</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">pages_offset</span><span class="p">);</span>

    <span class="n">qemu_put_buffer</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">header</span><span class="p">,</span> <span class="n">header_size</span><span class="p">);</span>

    <span class="c1">//===(3)===</span>
    <span class="cm">/* prepare offset for next ramblock */</span>
    <span class="n">qemu_set_offset</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">pages_offset</span> <span class="o">+</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">used_length</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>创建一个<code class="language-plaintext highlighter-rouge">MappedRamHeader</code>其中包含一些基本信息，例如<ul><li>version: version<li>page_size: 当前RAMBlock的 page_size<li>bitmap_offset: 记录当前block的bitmap_offset在file中的偏移<li>pages_offset: 传出page 的地址</ul><li>每个RAMBlock都有一个自己的bitmap(mem, bitmap每一个bit记录着，该index的 page是否是dirty的. 此处先算出有多少个page，然后在算出bitmap的大小。<li>设置设置offset, 为下一个RAMBlock的首地址。</ol><p>我们用图来解释下:</p><p><img src="./pic/RAMBlock.svg" alt="RAMBlock migration information" /></p><p>page[] 数组中的空白部分是空洞。这部分传输不占用传输时的带宽。</p><h3 id="ramram_state_pending_estimate"><span class="me-2">ram::ram_state_pending_estimate</span><a href="#ramram_state_pending_estimate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>该函数，只是粗略估计当前还剩余的要copy的dirty page。</p><blockquote><p>估计值偏小</p></blockquote><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">ram_state_pending_estimate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">must_precopy</span><span class="p">,</span>
                                       <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">can_postcopy</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RAMState</span> <span class="o">**</span><span class="n">temp</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
    <span class="n">RAMState</span> <span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="c1">//===(1)===</span>
    <span class="kt">uint64_t</span> <span class="n">remaining_size</span> <span class="o">=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">migration_dirty_pages</span> <span class="o">*</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">;</span>

    <span class="c1">//===(2)===</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">migrate_postcopy_ram</span><span class="p">())</span> <span class="p">{</span>
        <span class="cm">/* We can do postcopy, and all the data is postcopiable */</span>
        <span class="o">*</span><span class="n">can_postcopy</span> <span class="o">+=</span> <span class="n">remaining_size</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">must_precopy</span> <span class="o">+=</span> <span class="n">remaining_size</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>根据当前的migration_dirty_page计算还剩余数据需要传输<li>根据postcopy/precopy 来选择，加到哪个出参中。</ol><h3 id="ramram_state_pending_exact"><span class="me-2">ram::ram_state_pending_exact</span><a href="#ramram_state_pending_exact" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>该函数，用来精确计算remain save的dirtypage 数量, 达到精确的 方法是，sync下KVM传递下来的dirty bitmap, 见(1)</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">ram_state_pending_exact</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">must_precopy</span><span class="p">,</span>
                                    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">can_postcopy</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RAMState</span> <span class="o">**</span><span class="n">temp</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
    <span class="n">RAMState</span> <span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">remaining_size</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">migration_in_postcopy</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">bql_lock</span><span class="p">();</span>
        <span class="n">WITH_RCU_READ_LOCK_GUARD</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">//==(1)==</span>
            <span class="n">migration_bitmap_sync_precopy</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">bql_unlock</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">remaining_size</span> <span class="o">=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">migration_dirty_pages</span> <span class="o">*</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">migrate_postcopy_ram</span><span class="p">())</span> <span class="p">{</span>
        <span class="cm">/* We can do postcopy, and all the data is postcopiable */</span>
        <span class="o">*</span><span class="n">can_postcopy</span> <span class="o">+=</span> <span class="n">remaining_size</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">must_precopy</span> <span class="o">+=</span> <span class="n">remaining_size</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>来看下<code class="language-plaintext highlighter-rouge">migration_bitmap_sync_precopy</code>整体逻辑:</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre>migration_bitmap_sync_precopy
<span class="o">=&gt;</span> precopy_notify<span class="o">(</span>PRECOPY_NOTIFY_BEFORE_BITMAP_SYNC, &amp;local_err<span class="o">)</span>
<span class="o">=&gt;</span> migration_bitmap_sync
   <span class="c"># ==(2.1)==</span>
   <span class="c"># 此处是第一轮iter时，rs-&gt;time_last_bitmap_sync才会为0</span>
   <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">!</span>rs-&gt;time_last_bitmap_sync
      <span class="o">=&gt;</span> rs-&gt;time_last_bitmap_sync <span class="o">=</span> qemu_clock_get_ms<span class="o">(</span>QEMU_CLOCK_REALTIME<span class="o">)</span><span class="p">;</span>
   <span class="o">=&gt;</span> memory_global_dirty_log_sync
      <span class="o">=&gt;</span> memory_region_sync_dirty_bitmap
         <span class="c"># ==(1)==</span>
         <span class="c"># 通知各个memroy listener</span>
         <span class="o">=&gt;</span> foreach<span class="o">(</span>memory_listeners<span class="o">)</span>
         <span class="o">{</span>
             <span class="o">=&gt;</span> <span class="k">if </span>listener-&gt;log_sync
                <span class="o">=&gt;</span> foreach<span class="o">(</span>flatview<span class="o">)</span>
                    <span class="o">=&gt;</span> listener-&gt;log_sync<span class="o">()</span>
             <span class="o">=&gt;</span> <span class="k">else if </span>listener-&gt;log_sync_global
                <span class="o">=&gt;</span> foreach<span class="o">(</span>flatview<span class="o">)</span>
                   <span class="o">=&gt;</span> listener-&gt;log_sync_global<span class="o">()</span>
         <span class="o">}</span>
   <span class="o">=&gt;</span> foreach<span class="o">(</span>RAMBlock<span class="o">)</span>
      <span class="o">=&gt;</span> ramblock_sync_dirty_bitmap<span class="o">(</span>rs, block<span class="o">)</span>
   <span class="c"># ==(2.2)==</span>
   <span class="o">=&gt;</span> end_time <span class="o">=</span> qemu_clock_get_ms<span class="o">(</span>QEMU_CLOCK_REALTIME<span class="o">)</span><span class="p">;</span>
   <span class="c"># ==(2.3)==</span>
   <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span>end_time <span class="o">&gt;</span> rs-&gt;time_last_bitmap_sync + 1000<span class="o">)</span> <span class="o">{</span>
         migration_trigger_throttle<span class="o">(</span>rs<span class="o">)</span><span class="p">;</span>
         <span class="c"># ==(3)==</span>
         migration_update_rates<span class="o">(</span>rs, end_time<span class="o">)</span><span class="p">;</span>
         rs-&gt;time_last_bitmap_sync <span class="o">=</span> end_time<span class="p">;</span>
      <span class="o">}</span>
<span class="o">=&gt;</span> precopy_notify<span class="o">(</span>PRECOPY_NOTIFY_AFTER_BITMAP_SYNC, &amp;local_err<span class="o">)</span>
</pre></table></code></div></div><ol><li><code class="language-plaintext highlighter-rouge">memory_global_dirty_log_sync</code>会通知各个<code class="language-plaintext highlighter-rouge">memory listener</code>, 告诉他们要去做log sync。 我们会在后面的章节, 介绍和kvm相关的<code class="language-plaintext highlighter-rouge">log_sync</code>函数, 这里我们只需要知道, <code class="language-plaintext highlighter-rouge">log_sync</code> 的作用就是将内核统计的dirty page 的相关信息，同步到qemu侧.<li><p>该部分和<code class="language-plaintext highlighter-rouge">auto-coverage</code> 热迁移优化相关，在脏页频率比较高的情况下，限制脏页产生速率 从而达到收敛的状态<code class="language-plaintext highlighter-rouge">converage</code>. 具体做法是， 自动降低vcpu的CPU使用率，来降低该vcpu 产生脏页的速度</p><p>这里的条件也是, 本轮和上一轮时间差距1s的情况下，认为本轮发送的dirty page过于 多。</p><li><p>和<code class="language-plaintext highlighter-rouge">xbzrle</code>(XOR-Based zero Run-length Encoding 一个压缩算法)相关, 指在带宽不足的情况下, 将内存进行压缩传输，从而提升压缩效率</p><p>上面两种迁移优化的策略, 我们会在后面的章节中介绍</p></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/live-migration/">live_migration</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/live-migration/" class="post-tag no-text-decoration" >live_migration</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=live%20migration%20-%20one%20step%20at%20a%20time&url=%2Fposts%2Flive-migration-workflow%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=live%20migration%20-%20one%20step%20at%20a%20time&u=%2Fposts%2Flive-migration-workflow%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Flive-migration-workflow%2F&text=live%20migration%20-%20one%20step%20at%20a%20time" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/dirty-rate/">Dirty Rate</a><li class="text-truncate lh-lg"> <a href="/posts/guestperf/">guestperf</a><li class="text-truncate lh-lg"> <a href="/posts/kernel-pml/">kernel PML</a><li class="text-truncate lh-lg"> <a href="/posts/live-migration-workflow/">live migration</a><li class="text-truncate lh-lg"> <a href="/posts/Migration-auto-converge-problem/">[Translate]: Migration auto-converge problem</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-hot-upgrade/">qemu_hot_upgrade</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-bitmap/">dirty-bitmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-ring/">dirty-ring</a> <a class="post-tag btn btn-outline-primary" href="/tags/guestperf/">guestperf</a> <a class="post-tag btn btn-outline-primary" href="/tags/html-details/">html-details</a> <a class="post-tag btn btn-outline-primary" href="/tags/ipmi/">ipmi</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Migration-auto-converge-problem/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">[Translate]: Migration auto-converge problem</h4><div class="text-muted"><p>1 2 3 4 5 From: &quot;Jason J. Herne&quot; &amp;lt;jjherne@linux.vnet.ibm.com&amp;gt; To: &quot;qemu-devel@nongnu.org qemu-devel&quot; &amp;lt;qemu-devel@nongnu.org&amp;gt;, Christian Borntraeger &amp;lt;borntraeger@de.ibm.com&amp;gt; Subje...</p></div></div></a></article><article class="col"> <a href="/posts/auto-converge/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">auto-converge</h4><div class="text-muted"><p>简介 在大型机器，并且系统负载高时热迁移，工作负载往往比热迁移速度更快，从而导致 live migration无法 converge. 这个往往受限于bandwidth, 虽然现在网卡的带宽越来越高。但是虚拟机的核心数量 以及cpu主频，内存带宽也在逐渐增大。 Chegu Vinod 在 2013 年提出了 auto-converge, （但是的场景即使使用了10Gig NICs也仍然...</p></div></div></a></article><article class="col"> <a href="/posts/kvm-dirty_bitmap/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1731424800" data-df="ll" > Nov 12, 2024 </time><h4 class="pt-0 my-2">dirty-bitmap</h4><div class="text-muted"><p>ORG PATCH 我们来看下最初的KVM实现了哪些功能。最初的KVM代码，是基于shadow page table, 支持了dirty_bitmap. 我们从几个方面看下dirty_bitmap实现: kernel data struct USER API lock Contention Analysis kernel data struct 并支持了dirty_b...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/mce/" class="btn btn-outline-primary" aria-label="Older" ><p>Mce</p></a> <a href="/posts/Migration-auto-converge-problem/" class="btn btn-outline-primary" aria-label="Newer" ><p>[Translate]: Migration auto-converge problem</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2024</time> <a href="https://twitter.com/fuqiang_cai">fuqiang wang</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v6.5.5" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/virt/">virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/para-virt/">para_virt</a> <a class="post-tag btn btn-outline-primary" href="/tags/autoconverge/">autoconverge</a> <a class="post-tag btn btn-outline-primary" href="/tags/qemu-hot-upgrade/">qemu_hot_upgrade</a> <a class="post-tag btn btn-outline-primary" href="/tags/acs/">acs</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-bitmap/">dirty-bitmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/dirty-ring/">dirty-ring</a> <a class="post-tag btn btn-outline-primary" href="/tags/guestperf/">guestperf</a> <a class="post-tag btn btn-outline-primary" href="/tags/html-details/">html-details</a> <a class="post-tag btn btn-outline-primary" href="/tags/ipmi/">ipmi</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
