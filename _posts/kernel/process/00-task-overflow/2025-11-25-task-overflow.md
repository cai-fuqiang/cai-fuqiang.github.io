--- 
layout: post
title:  "task - overflow"
author: fuqiang
date:   2025-11-25 11:00:00 +0800
categories: [task mgmt]
tags: [kernel, task_mgmt]
---

## Basic Concepts

进程的定义非常简单: **运行中的程序**. 和程序不同的是, 程序是没有
生命周期的，其只是磁盘上的一些指令。而操作系统负责是让这些运
行起来.

而操作系统用户往往希望同时运行多钟程序, 例如, 当我们用家用电脑时，
电脑中会同时运行 浏览器, 音乐播放器, 游戏等等。并且同一个程序可能会
运行多个实例, 例如, 我们可能同时启动多个浏览器窗口。有的窗口在打开
视频播放器，有的窗口在查询资料。如此多的程序，像是在同时跑一样。
但是实际上，在一个cpu核上，某个时刻只有一个程序可以运行。如何
让程序"同时"跑，并且各自有独立的生命周期和资源（当然也可能共享
某些资源），这些就是操作系统去进行分配和管理(如下图所示):

![os_task_management](./pic/os_task_management.svg)

所以, 从内核的角度看, 进程就是担当分配系统资源(CPU, 内存, IO device) 
的实体<sup>2</sup>, 并且该实体有一定的生命周期。 而对不同资源的管理在
内核软件架构上分为不同的subsystem.

### lifestyle of task

进程的生命周期也非常简单, 将可执行程序被os load 到内存，并被分配各个
资源, 该进程就被创建了。当程序因为自己的意愿或者os的管理不再
运行，并将其拥有的资源释放时，该进程就go dead了。

但是进程在运行时往往会有一些状态的变化，如下图所示:

![task_state_switch](pic/task_state_switch.png)

主要有三种:

* **running**: 进程正在cpu上跑
* **ready**: 进程想跑，但是cpu被其他任务或者os占用
* **blocked**: 进程在等待某个事件完成，常见的例子是发起 同步IO，在io complete
  之前该进程是blocked 状态

### resource

进程可能会享用哪些资源呢?
1. **CPU:** 前面我们提到过，不同的进程在分时复用CPU资源, 而分时复用的策略由操作
        系统制定, 称之为调度策略。这是一个比较大的subsystem, 我们放到调度章节中
        讲述.

   但是当进程被调度，或者被调度走时，需要save restore cpu的上下文。通常是cpu
   的某些寄存器。

2. **Mem:** 内存和cpu不同, 在内存较为充足时, 每个进程拥有独立的内存区域(有自己的
        栈和堆， 当然在内存不足时，这些内存可能被swap到disk上，从而将这些内存
        分配给其他的进程). 但是，内核也做了一些 "virtualization", 让这些每个
        进程各自拥有独立的虚拟地址空间, 并且为每个进程虚拟地址空间映射到不同的
        物理地址上。这样，每个进程在运行时不会互相干扰。（除非是进程主动共享
        内存资源)

   举个例子, 进程`A` 和进程`B` 都想将磁盘数据存放到地址为`0x1000` 的buffer上，
   此时，os会为不同的进程的该虚拟地址，映射到不同的物理地址上。从而让其访问
   不同的物理内存。

   这是一个相当大的 subsystem, 我们放到内存管理的章节中讲述。

3. **IO device**: 我们往往要将运算结果，或者数据固化，这时，我们需要将这些数据
   存放到 磁盘中，或者通过网络存放到对端，等等，这时就需要程序操作 IO  device.
   但是不同于内存的是，用户态程序，往往没有 "权限" 执行这些IO 指令，另外这些
   操作也比较复杂，所以os 往往将这些 IO device 进行抽象，并提供 简单的API，让
   用户态程序操作这些设备。

   而在内核中, 和 IO device 相关的有两个比较大的 subsystem:
   * block
   * net

   内核不仅要完成和硬件的交互，也要完成对这些资源的分时复用, 对于net subsystem而
   言， 还需要将用户的调用 API的请求，转换为协议栈报文。

4. **IPC**: 每个进程是独立的，但是往往也有通信的需求。我们称之为进程间通信(IPC),
   这些IPC也被操作系统封装为简单的接口。例如: 信号，信号量，条件变量，共享内存等
   等。

好! 关于进程管理 的基础概念我们就讲解这些, 如果想更体系的了解这部分知识，请参考
<sup>1</sup>

## Linux implemention && section overflow

Linux为每个进程实体定义了两个数据结构`task_struct`, `thread_info`。用来存储进程
的相关标识及管理信息以及其拥有的资源。我们将在下面章节中具体讲述.
* 进程管理数据结构 -- task_struct
* 进程标识

Linux 和 Unix 一样，进程之间有明确的父子关系，所有进程形成一个家族tree, 父进程通
过  `fork()` 系统调用，创建子进程。另外, 进程之间通过任务切换完成在CPU上的分时复
用，而选择策略将由 调度子系统控制。进程执行完或者进程被迫停止后，内核将触发进程
的销毁流程。这些是内核控制进程生命周期的主要手段。我们放到 下面章节中讲述。

* 进程创建
* 进程切换
* 进程销毁

父进程通过`fork()`创建子进程后，父进程和子进程大部分资源将互相独立，但是也有一
部分资源可以共享。例如, 代码段, 文件描述符等。 但是有一些场景用户希望完全放弃
父进程资源，例如我们通过shell 执行我们编写的 hello world. 还有一些场景用户希望
共享更多的父进程资源，例如多线程场景, 线程之间可以共享大部分资源，例如数据段。
新打开的文件等等。这些 需求 Linux 实现了不同的系统调用来满足。我们将放到下面的
章节中描述。

进程在创建后，由于内核的调度策略，或者进程的某些行为，进程将处于不同的状态。我们
将在下面章节中描述Linux下的进程状态有哪些，以及其是如何切换的。

* 进程状态

## 总结

计算机用户总是希望在有限的硬件资源下，运行无限的任务。而 kernel 职责就是帮助这些
task 管理分配这些资源。进程做为操作系统最基础的抽象，是操作系统的心脏<sup>3</sup>.
而进程管理主要关注下面的事情:

* 进程生命周期管理
* 进程信息及其资源维护 

但是进程分配管理资源将涉及到其他各个子系统。这些实现分布到各个子系统的代码中，不再是
进程管理的责任。所以进程管理在处理这些资源是更像是一个API 调用者。其主要focus 主
要流程。


## 其他
### 实现主要参考

本文编写与`2025-11-27`, 主要参考当前最新内核tag `6.18-rc7` 实现, 在链接<sup>
5</sup>中所在的代码分支中，将增加详细的注释。为了便于观看，尽量将具体实现细节
总结在该系列的文章中。

另外，为了更好的理解各个功能引入，本文将通过借助`git log`, 以及kernel 在线阅读
网站<sup>5</sup>关注各个历史。

## 参考链接

1. [操作系统导论(中文)](https://github.com/iTanken/ostep-chinese/tree/main/chinese)
2. `<<深入理解Linux内核>>`
3. `<<linux内核设计与实现>>`
4. <<深入Linux内核架构>>
5. [my kernel note](https://github.com/cai-fuqiang/linux/tree/6.18-rc7-my-note)

