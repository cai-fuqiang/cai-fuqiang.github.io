## MCA

RAS 全称 reliability, availability 和 serviceability. 


## MCA type

* **_correct_**
  + If an error can be corrected by hardware, no immediate action by software
    is required. In this case, information is logged, if enabled, to aid in
    later diagnosis and possible repair.
 
   > 这种可以被硬件correct的 hardware error, 软件无需立即做动作。这种情况下， 
   > 错误信息应该被记录下来，来帮助接下来的 诊断和修复

* **_uncorrected_**

  + If correction is not possible, the error is classified as uncorrected. The
    occurrence of an uncorrected error requires immediate action by system 
    software to either correct the error and resume the interrupted program or,
    if software-based correction is not possible, to determine the extent of 
    the impact of the uncorrected error to any executing instruction stream 
    or the architectural state of the processor or system and take actions
    to contain the error condition by terminating corrupted software processes.

    > 如果该错误不能correct, 那么需要软件来立即采取一些行动, 具体的行动可能有:
    > + 软件尝试crrect error，并恢复被中断的程序
    > + 如果software-based correction 已经不可能, 首先确定uncorrected error对于
    >   当前任意执行流或者处理器/系统的架构状态的影响程序，通过终止 软件程序来
    >   控制当前的错误。
* **_deferred_**

  + For errors that are not corrected, but have no immediate impact on the
    architectural state of the system, processor core, or any current thread of
    execution, the error may be classified by hardware as a deferred error.
    Information about deferred errors is logged, if enabled, but not reported
    via a machine- check exception. Instead hardware monitors the error and
    escalates the error classification to uncorrected at the point in time
    where the error condition is about to impact the execution of an
    instruction stream or cause the corruption of the processor core or system
    architectural state.

    > 有一些error是 not corrected, 但是没有立即影响当前系统的 architectural
    > state, processor core 以及任何当前线程的执行, 这类error被归类为 deferred
    > error. 这些defer error信息被log，并且可以配置为不触发 #MC. 和uncorrected
    > 错误不同的时，uncorrected error影响到了当前指令流的执行，或者导致
    > 处理器核心或者系统架构状态损坏

This escalation results in a #MC exception, assuming that reporting for that
error source is enabled. If software can correct the error, it may be possible
to resume the affected program. If not, software can terminate the affected
program rather than bringing down the entire system. This is referred to as
error localization.

> 当软件遇到#MC时(可能由uncorrected error触发), 软件如果可以纠正该错误，受影响的
> 程序就可以继续运行，如果不能，软件应该终止受影响的程序，而不是重启整个系统。
> 这被成为 **_error localization_**

A common example of deferred error processing and localization is the
conversion of globally uncorrected DRAM errors to process-specific consumed
memory errors. In this example, uncorrected ECC-protected data that has not yet
been consumed by any processor core is tagged as “poison.” Hardware reports the
uncorrected data as a localized error via a #MC exception when it is about to
be used (“consumed”) by an instruction execution stream.

> deferred error processing 和localization 的一个常见例子是将全局不可纠正的 
> DRAM 错误转换为特定进程的 consumed memory error。在这个例子中，尚未被任何
> 处理器核心消耗的不可纠正的 ECC 保护数据被标记为‘poison’。当指令执行流即将
> 使用（"consumed"）这些数据时，硬件通过 #MC 异常将不可纠正的数据报告为一个
> localized error.

> 这个是硬件来保证的么?
>
> 也就是说，之前触发了一个deferred error（关联一个内存地址），下次当硬件访问到这个
> 地址时，就可以知道这个地址之前触发过defer error， 然后触发 #MC, 并报告为
> localized error ?
{: .prompt-warning}

In contrast, an error that cannot be contained and is of such severity that it
has compromised the continued operation of a processor core requires immediate
action to terminate system processing and may result in a hardware-enforced
shutdown. In the shutdown state, the execution of instructions by that
processor core is halted. See Section 8.2.9 “#DF—Double-Fault Exception (Vector
8)” on page 250 for a description of the shutdown processor state.

> 相反，对于无法被控制且严重到影响处理器核心持续运行的错误，需要立即采取措施终止系
> 统处理，并可能导致 hardware-enforced *shutdown* 。在shutdown state下，该处理器核心
> 的指令执行被halt。有关 shutdown processor state 的描述，请参见 #DF

If supported, system software can chose to configure and enable hardware to
generate an interrupt when a deferred error is first detected. Corrected errors
may be counted as they are logged. If supported and enabled, exceeding a
software-configured count threshold may be signalled via an interrupt. These
notification mechanisms are independent of machine-check reporting.

> 如果支持，系统软件可以选择配置并启用硬件, 以便在首次检测到延迟错误时生成中断。
> 已纠正的错误可以在记录时计数。如果支持并启用，超过软件配置的计数阈值可能会通过
> 中断发出信号。这些通知机制独立于机器检查报告。

> 这段介绍了, 不同的错误，推荐用什么样的方式处理:
> * **_uncorrected error_** : 毫无疑问，当触发MCE时，立即处理
> * **_deferred error_**: 可以配置为当该deferred error第一次被发现时，触发interrupt
> * **_correct error_**: 可以配置为 计数-阈值 触发interrupt的方式。
{: .prompt-info}

Specific details on hardware error detection, logging, and reporting are
implementation-dependent and are described in the BIOS and Kernel Developer’s
Guide (BKDG) or Processor Programming Reference Manual applicable to your
product.

## Machine-Check Status Registers

![MCi_STATUS](pic/MCi_STATUS.png)

* **_Poison_**: 

  Bit 43. When set to 1, this bit indicates that the uncorrected error
  condition being reported is due to the attempted use of data that was
  previous detected as in error (and could not be corrected) and marked as
  known-bad.

  > 当设置为1时，这个位表示所报告的未校正错误情况是由于尝试使用先前检测
  > 为错误（且无法校正）并标记为已知错误的数据引起的.
* **_Deferred_**:

  > 当设置为1时，这个位表示硬件已确定所记录的错误情况未影响任何指令流的执行，
  > 系统软件无需采取措施来预防或纠正错误。不会发出机器检查异常。当任何执
  > 行线程受到影响时，硬件将监控该错误并记录一个未校正错误。

* **_TCC_** (Bit 55)

  When set to 1, this bit indicates that the hardware context of the process
  thread to which the error was reported may have been corrupted. Continued
  operation of the thread may have unpredictable results. When this bit is
  cleared, the hardware context of the process thread to which the error was
  reported is not corrupted and recovery of the process thread is possible.
  This bit is only meaningful when MCA_STATUS[PCC]=0.

  > 当 MCA_STATUS[PCC]为0的时候，该字段才有意义。当该字段为1时，表示该process
  > thread的hardware context 已经损坏了。继续执行该thread可能会导致不可预测的行为.

  > 某些hardware state时per-task的. 某些hardware state是global的(processor state)。
  > 这种错误似乎说明, 只有 per-task的 hardware state 被损坏了。软件无法通过异常返回，
  > 再次返回被中断的task中，软件需要终止该task 来fixup 该error. 另外，processor state
  > 未损坏，软件也不必立即 重启机器
  {: .prompt-tip}

* **_PCC_** (Bit 57)

  When set to 1, this bit indicates that the processor state is likely to be
  corrupt due to an uncorrected error. In this case, it is possible that
  software cannot reliably continue execution. When this bit is cleared, the
  processor state is not corrupted and recovery is still possible. If the PCC
  bit is set in any error bank, the processor will clear RIPV and EIPV in the
  MCG_STATUS register.

  > 当该字段为1， 表示 **processor state** 似乎因为uncorrected error 而被顺坏.
  > 在该情况下，软件可能无法可靠的运行。
  >
  > 如果PCC 在任何bank中被设置，处理器将会 clear MCG_STATUS 中的 RIPV和EIPV.

  > 这种说明processor state 已经被损坏了，软件已经无法可靠运行。（一般来说，
  > 这种情况下，需要立即重启机器)
  {: .prompt-tip}

## survivable MCA overflow

* survivable MCA overflow: 
  + CPUID Fn8000_0007_EBX[McaOverflowRecov]
  + MCi_STATUS[PCC] bit 暗示着系统能否继续运行
  + 如果在某些不支持surivable MCA overflow的机型上, 发生了overflow, 
    软件应该立即halt指令执行，不管PCC bit, 因为critical information
    可能在overflow的过程中，已经丢了.

## Machine-Check Recovery

MCR 允许系统可以在硬件不能crrent的error时, system 可以recovery.

CPUID Fn8000_0007_EBX[SUCCOR] = 1

When Machine Check Recovery is supported and an uncorrected error has been
detected that the hardware can contain to the task or process to which the
machine check has been delivered, it logs a context-synchronous uncorrectable
error (MCi_STATUS[UC]=1, MCi_STATUS[PCC]=0). The rest of the system is
unaffected and may continue running if supervisory software can terminate only
the affected process context.

> 当支持机器检查恢复（Machine Check Recovery）并检测到一个未校正的错误，
> 而硬件可以将其限制在接收到machine 的任务或进程中时，它会记录一个
> context-synchronous 的不可校正错误 (MCi_STATUS[UC]=1, MCi_STATUS[PCC]=0).
> 这样系统其他的部分将不受影响，并且如果supervisory software(监督软件）可以
> 只终止受影响的process context的话，系统可以继续运行。

## Machine-check Control Register

`MCi_CTL When set to 1, this bit indicates that the uncorrected error condition being
reported is due to the attempted use of data that was previous detected as in error (and could not be
corrected) and marked as known-bad.`
