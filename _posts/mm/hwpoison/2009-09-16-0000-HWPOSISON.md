## patch 0
layout:     post
title:      "[PATCH 00/21] HWPOISON: infra"
author:     "fuqiang"
date:       "Wed, 16 Sep 2009 11:50:03 +0200"
categories: [mm,hwpoison]
tags:       [hwpoison]
---
```
This the version of hwpoison I intend to submit for 2.6.32.

Only some very minor fixes compared to the last version posted.
I integrated one patch from Fengguang that has been reviewed
separately.

Passes the hwpoison specific parts of the mce-test test suite
(git://git.kernel.org/pub/scm/utils/cpu/mce/mce-test.git)

Also available as git tree from 
git://git.kernel.org/pub/scm/linux/kernel/git/ak/linux-mce-2.6.git hwpoison

-Andi

Signed-off-by: Andi Kleen <ak@linux.intel.com>

---

Upcoming Intel CPUs have support for recovering from some memory errors
(``MCA recovery''). This requires the OS to declare a page "poisoned", 
kill the processes associated with it and avoid using it in the future. 

This patchkit implements the necessary infrastructure in the VM.

>  该补丁集在 VM 中实现了所需的基础设施。

To quote the overview comment:

 * High level machine check handler. Handles pages reported by the
 * hardware as being corrupted usually due to a 2bit ECC memory or cache
 * failure.
 * 
 * > 高级machine check 处理程序。处理由硬件报告为损坏的页面，通常是由于2位ECC
 * > 内存或缓存故障引起的。
 *
 * This focusses on pages detected as corrupted in the background.
 * When the current CPU tries to consume corruption the currently
 * running process can just be killed directly instead. This implies
 * that if the error cannot be handled for some reason it's safe to
 * just ignore it because no corruption has been consumed yet. Instead
 * when that happens another machine check will happen.
 *
 * 这主要关注在后台检测到的页面损坏。 当当前的CPU试图访问已损坏的内存时，
 * 正在运行的进程可以直接被终止。这意味着如果由于某种原因无法处理该错误，
 * 还没有消耗到损坏的数据。当这种情况发生时，系统会触发另一次机器检查。
 *
 * Handles page cache pages in various states. The tricky part
 * here is that we can access any page asynchronous to other VM
 * users, because memory failures could happen anytime and anywhere,
 * possibly violating some of their assumptions. This is why this code
 * has to be extremely careful. Generally it tries to use normal locking
 * rules, as in get the standard locks, even if that means the
 * error handling takes potentially a long time.
 *
 * 处理各种状态下的页面缓存页。棘手的部分在于，我们可以异步访问任意页面，
 * 因为内存故障可能在任何时间和地点发生，可能会破坏其他虚拟内存用户的一
 * 些假设。这就是为什么这段代码必须格外小心。通常，它尝试使用正常的锁定
 * 规则，例如获取标准锁，即使这意味着错误处理可能需要很长时间。
 *
 * Some of the operations here are somewhat inefficient and have non
 * linear algorithmic complexity, because the data structures have not
 * been optimized for this case. This is in particular the case
 * for the mapping from a vma to a process. Since this case is expected
 * to be rare we hope we can get away with this.
 *
 * > 这里的一些操作效率较低，且具有非线性算法复杂度，因为数据结构并未针对这
 * 种情况进行优化。特别是从VMA（虚拟内存区域）映射到进程的操作。在这种情况
 * 下预计是罕见的，所以我们希望这样做不会造成太大问题。

The code consists of a the high level handler in mm/memory-failure.c, 
a new page poison bit and various checks in the VM to handle poisoned
pages.

> 这段代码包括了mm/memory-failure.c中的高级处理程序、新的页面损坏标志位，
> 以及虚拟内存（VM）中用于处理损坏页面的各种检查机制。

The main target right now is KVM guests, but it works for all kinds
of applications.

> 目前的主要目标是KVM虚拟机，但该机制适用于所有类型的应用程序。

For the KVM use there was need for a new signal type so that
KVM can inject the machine check into the guest with the proper
address. This in theory allows other applications to handle
memory failures too. The expection is that near all applications
won't do that, but some very specialized ones might. 

> 为了在KVM中使用，需要引入一种新的信号类型，以便KVM能够向虚拟机注入
> 带有正确地址的机器检查。这理论上也允许其他应用程序处理内存故障。
> 预期几乎所有应用程序都不会这样做，但一些非常特殊的应用程序可能会处理
> 这种情况。

This is not fully complete yet, in particular there are still ways
to access poison through various ways (crash dump, /proc/kcore etc.)
that need to be plugged too.

> 这还没有完全完成，特别是通过各种方式（如崩溃转储、/proc/kcore等）
> 仍然有可能访问到损坏的页面，这些途径也需要被堵住。


-Andi
```
