---
layout: post
title: "intel tdx (spec)"
author: fuqiang
date:   2025-12-30 14:00:00 +0800
categories: [tee, arch_intel]
tags: [tee, tdx]
media_subpath: /_posts/tee/arch/x86/tdx
---

## overflow

**_add new operation mode_**

**Secure Arbitration Mode (SEAM)** 是对于VMX 架构的扩展。在 vmx root/non-root
operation(我们只有称为 legacy vmx XXX operation)下新增了两组模式:
* SEAM VMX root operation
* SEAM VMX non-root operation

`SEAM VMX root operation` 中托管了成为 `Intel Trust Domain Extensions(Intel TDX)`
模块, 用于管理 **TD虚拟机(可以理解为机密虚拟机)**. Intel TDX 模块实现了对TD虚拟机的:
* operation
  + build
  + tear down
  + start execution

而VMM 提供TD 所需的内存资源，并通过intel TDX 模块提供的API 来调用TD。

![TDX_components](pic/TDX_components.png)

和`legacy VMX operation` 类似, 在 `SEAM VMX root operation` 中通过
`launched/resumed` 操作， 切换到 `SEAM VMX non-root operation`. 而运行在`SEAM
mode`下的虚拟机, 则受 SEAM 扩展保护，防止host VMM和`non-SEAM` 下的软件访问或修改
(`confidentiality and integrity`) TD memory/CPU state.

另外 `SEAM VMX root operation` 除了运行 `Intel TDX module`之外，也会运行`Intel
Persistent SEAMLDR(Intel P-SEAMLDR)` 来load & update `Intel TDX module`

**_seam vmx root operation run in SPEICAL memory range_**

上面提到的运行在`SEAM VMX root operation` 的两个module, 均运行在 由 `SEAM
range register (SEAMRR)` 所定义的地址范围中。这段预留的内存需要platform owner
通过BIOS 设置。

`SEAMRR range`被划分为两个 `sub-ranges`:
* MODULE_RANGE
* P_SEAMLDR_RANGE

![seam_range_register](pic/seam_range_register.png)

`MODULE_RANGE` 用于`P-SEAMLDR`安装(其实不仅是安装，还包括安装前的measure, verify)
`Intel TDX module`, 该过程发生在系统启动，或者RUNTIME。 而`P_SEAMLDR_RANGE`用于
`NP-SEAMLDR`安装 `P-SEAMLDR`.

**_how to switch between SEAM mode & LEGACY mode_**

当 VMM 想要切到 `SEAM mode`时，需要执行`SEAMCALL`指令。而`SEAM mode`要切到`VMM`
需要执行`SEAMRET`指令。

另外, 上面提到`SEAM vmx-root operation`运行两个module, `VMM`如何选择将进入
哪个module呢? 通过调用`SEAMCALL`时，指定`EAX`:
* **_bit63(0)_**: `MODULE_RANGE`
* **_bit63(1)_**: `P_SEAMLDR_RANGE`

对于VMM管理TD而言, 其控制权的转移增加了额外的转换:
* `VMM->TD`
  + `legacy VMX root -- SEAMCALL => SEAM VMX root -- vmlanched/vmresume => SEAM VMX non-root`
* `TD->VMM`
  + `SEAM VMX non-root -- vm exit => SEAM VMX root -- SEAMRET => legacy VMX root`

如下图所示:

![vmx-and-seam-transition](pic/vmx-and-seam-transition.png)

## INTEL TDX module and intel P-SEAMLDR module

`Intel TDX module`和`Intel P-SEAMLDR` 均运行在`SEAMRR`接口定义的内存范围。并且
对该范围内的访问仅限于`SEAM VMX root operation`。另外，在`SEAM VMX root
operation`下只能运行`SEAMRR`范围内的代码，如果运行其他地址的代码，会导致
不可中断关机...

![tdx_mode_and_seamrr](pic/tdx_mode_and_seamrr.svg)

`IA32_MTRRCAP`中的`SEAMRR`bit 15位表示是否支持`SEAMRR`接口, 用于划出一个受限制
的内存区域，这个内存区域被 `SEAM vmx-root operation`下的`TDX module`使用.

![IA32_SEAMRR_PHYS_BASE](pic/IA32_SEAMRR_PHYS_BASE.png)

![IA32_SEAMRR_PHYS_MASK](pic/IA32_SEAMRR_PHYS_MASK.png)

base 地址以32 位对齐。另外，`MASK`寄存器有`lock bit(10)` 该bit有BIOS配置完
寄存器的其他字段再设置。设置`lock bit`后，再对相关寄存器进行写操作则会触发
`#GP`。

**_重头戏来了_**, 在`base`地址偏移 4K处，存放一个VMCS的数组，用作`legacy vmx
root operation` 到 `SEAM vmx root operation` 切换，用于save/restore 各自模
式的上下文. 既然`VMCS`位于`SEAMRR`，那么`SEAM vmx root`就类似于`VMM`,
而`legacy vmx root` 类似于vm.

* SEAM -> Legacy: 相当于触发了 vmentry.
* Legacy-> SEAM:  相当于触发了 vm-exit.

每个cpu对应的 tranfer vmcs地址为:
```
IA32_SEAMRR_PHYS_BASE + 4096 + CPUID.B.0.EDX [31:0] * 4096
```

> NOTE
>
> 但是我们需要思考下, `VMCS` 除了有 `state area`用于保存恢复上下文的区域 ,
> 还有`VM-exit control, VM-entry control`等等和虚拟机强项关的区域。
> 这些区域会在这个过程中起作用么。
>
> 个人认为不会。这里只是借用了VMCS 的格式。有待进一步考究。
>
> 不过，从VMCS的归属来看, `SEAM VMX root operation` 对`legacy VMX root 
> operation`有着绝对的控制权，前者不高兴了，可以随意破坏后者的上下文。
> 而后者没有这个权利。
{: .prompt-tip}

`SEAMRR`是划分`MODULE_RANGE`区间，用于`Intel TDX module`, 还有一个
module -- `P-SEAMLDR`, 其使用 `P_SEAMLDR_RANGE`, 切换到该模式（前面讲过
如何切换) 应该如何保存上下文呢?

答案也是通过VMCS，但和`Intel TDX module`不同，`P-SEAMLDR` 只能有一个cpu运行。
那VMCS结构需要一个就够了.

`P-SEAMLDR` 模块用于在 `SEAMRR` 的`MODULE_RANGE`中加载 `TDX module`, 并初始化
和`TDX module`相关的 tranfer VMCS。

而`NP-SEAMLDR` 则会帮助初始化`SEAM range`,并初始化 `P-SEAMLDR transfer VMCS`,
load `P-SEAMLDR` 到`P_SEAMLDR_RANGE`中

> The OS can launch the NP-SEAMLDR ACM using the GETSEC[ENTERACCS] instruction
> if the SEAMRR range enable bit (bit 11) of IA32_SEAMRR_PHYS_MASK MSR is 1.
> > EMMM... 为什么os会调用这个... 难道是更新 `P-SEAMLDR`?

## SEAM VMX ROOT OPERATION

TDX module 帮助给TD VM 进行资源分配, 并且会切换到 `SEAM VMX non-root operation`
来运行`TD VM`。TDX module使用 `MK-TME` 技术，用于保护TD VM 私有数据的机密性和完
整性。

### TDX private KeyID
TDX 为每个TD VM 分配不同的MK-TME keyID 用来加密内存，另外, **KeyID 分配给 TD 的情
况下，不可信软件不应被允许读取或写入内存!** 完整性是怎么保证的呢?


Intel Trust Domain Extensions 允许预留一定数量的KeyID 给 TD VM 用。在支持 SEAM
的soc上, MK-TME也会保证该内存的完整性。具体做法为: 

> Intel TDX 在这里搞得相当复杂下面是自己的理解 (参考<sup>2</sup> 第16章)
>
> 以`Non-ACT Platforms: Cryptographic Integrity (Ci)`为例,

每个cacheline 对应`message authentication code (MAC)`(用于校验该cacheline完整性)
的元数据, 当在 `SEAM non-root operation`  下使用 `MK-TME` `private key`修改写内
存时，cacheline中的数据其实是解密的，但是 `MK-TME` 会去`private key`计算
cacheline data的MAC 并保存到元数据, 并标记该cacheline的 `TD-owner`元数据为1. 
**这些元数据也会随着cacheline flush，最终会保存在内存元数据中，受ecc保护...**

此时假设 `legacy VMX-root operation` 去修改这块内存, 此时其不会检查`TD-owner`,
直接修改内存, 此时会使用`shared key`重新计算MAC, 并保存到cache元数据中，接下来,
`SEAM non-root operation`  下如果在访问这段内存， `MK-TME`会重新计算`MAC` 并和元
数据中的`MAC`做比对。如果不相同，则触发`Integrity Check failed`, 标记cacheline被
标记为`poisoned`, 并返回值为0. 防止`SEAM non-root operation`继续使用该cache.

## 参考链接
1. [Intel® Trust Domain CPU Architectural Extensions 343754-002US MAY 2021](https://cdrdv2-public.intel.com/733582/intel-tdx-cpu-architectural-specification.pdf)
2. [Intel® Trust Domain Extensions (Intel® TDX) Module Base Architecture Specification](https://cdrdv2-public.intel.com/853286/intel-tdx-module-base-spec-348549006.pdf)
3. [Scalable Memory Protection in the Penglai Enclave](https://www.usenix.org/system/files/osdi21-feng.pdf)
