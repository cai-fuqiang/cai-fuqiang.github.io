[ { "title": "async pf", "url": "/posts/async-pf/", "categories": "kernel, kvm", "tags": "para_virt", "date": "2024-04-10 12:20:00 +0800", "snippet": "introduce在支持EPT的架构中, 对于GVA-&gt;HPA一般有两段映射: GVA-&gt;GPA GPA-&gt;HPA而host kernel (kvm) 需要关心的是 GPA-&gt;HPA的映射, 需要host做的事情主要有以下几个: 捕捉相关 VM-exit event (EPT violation), 得到 GPA 分配page 建立映射关系(当然这个映射关系...", "content": "introduce在支持EPT的架构中, 对于GVA-&gt;HPA一般有两段映射: GVA-&gt;GPA GPA-&gt;HPA而host kernel (kvm) 需要关心的是 GPA-&gt;HPA的映射, 需要host做的事情主要有以下几个: 捕捉相关 VM-exit event (EPT violation), 得到 GPA 分配page 建立映射关系(当然这个映射关系, 不止是GPA-&gt;HPA的mmu pgtable, 还有 HVA – GPA,在这里不展开, 总之分配好具体的page(分配HPA), 以及为其建立好 mmu pgtable, 就可以完成该事件的处理)但是, 已经建立好映射的页面, 也是qemu进程的虚拟地址空间(匿名页), 是可以被swap out,当被swap out后, GUEST 访问该HPA对应的 GVA/GPA时, 仍然会触发 EPT violation. 这时还会再走一次 VM-exit, 而且也需要完成上面所述的三件事, 其中第二件:分配page, 需要swap in之前被swap out的page, 路径比较长, 如下:VM-exit handle_ept_violation kvm_mmu_page_fault tdp_page_fault gfn_to_pfn hva_to_pfn get_user_pages --slow pathget_user_pages会走到slow path, 由于会走swap in流程, 所以该过程执行较慢. 所以大佬们就想着能不能让其异步执行, 然后让vcpu先不complete 造成 EPT violation 的 instruction, 去干别的事情, 等page present后, 再去执行该指令. 另外将 get_user_pages 让一个 dedicated thread 去完成,这样, 对于虚拟机来说, 就相当于搞了一个额外的 硬件, 专门去处理 swap in, 解放了vcpu的算力. NOTE 大家思考下, 如果要达到该目的, 一定是让GUEST有意无意的 sche out 造成 EPT violation的进程,该上面流程总结如下:graphviz-8d7cf6fb51f0587413a2482c375da409digraph G { subgraph cluster_host { style=&quot;filled&quot; color=&quot;#71324556&quot; subgraph cluster_host_dedicated_thread { do_slow_path [ shape=&quot;note&quot; label=&quot;I&#39;m a delicated thread, \\nLike a special hardware, \\nsharing the pressure of VCPU&quot; ] label=&quot;dedicated thread&quot; have_get_page [ label=&quot;get page, \\nPAGE IS PRESENT!&quot; ] do_slow_path-&gt; &quot;get_user_pages(slow path)&quot;-&gt; have_get_page } subgraph cluster_host_kvm_vcpu_thread { &quot;ept violation handle&quot;-&gt; get_user_page_fast get_user_page_fast [ label=&quot;get_user_pages() -- \\nfast path&quot; ] dont_do_slow_path [ shape=&quot;note&quot; label=&quot;I don&#39;t want handle slow path, \\nit will speed to much time&quot; ] get_user_page_fast_is_success [ shape=&quot;diamond&quot; label=&quot;get_user_page_fast \\nSUCCESS ?&quot; ] let_guest_sched_out [ shape=&quot;note&quot; label=&quot;Let vcpu do other things\\n rather than wait page present&quot; ] get_user_page_fast-&gt;get_user_page_fast_is_success get_user_page_fast_is_success-&gt;dont_do_slow_path [ label=&quot;N, seem to need do slow path&quot; ] dont_do_slow_path-&gt;let_guest_sched_out label=&quot;host kvm vcpu thread&quot; } label = &quot;host&quot; } subgraph cluster_guest { style=&quot;filled&quot; color=&quot;#12323456&quot; subgraph cluster_trigger_ept_violation_task { task1_access_a_memory [ label=&quot;acesss a memory address [BEG]&quot; color=&quot;white&quot; style=&quot;filled&quot; ] access_memory_success [ label=&quot;access memory success&quot; ] trigger_EPT_violation [ label=&quot;trigger EPT violation&quot; ] task1_access_a_memory -&gt; trigger_EPT_violation [ label=&quot;page NOT present&quot; ] label=&quot;TASK1 trigger ept vioaltion&quot; } subgraph cluster_sched_in_task2 { task2_run_a_time [ label=&quot;task2_run_a_time&quot; ] label=&quot;task2&quot; } trigger_EPT_violation -&gt; guest_sched_module [ label=&quot;sched out TASK1&quot; color=&quot;blue&quot; ] guest_sched_module-&gt;task2_run_a_time [ label=&quot;sched out TASK1&quot; color=&quot;blue&quot; ] guest_sched_module [ label=&quot;guest sched module&quot; style=&quot;filled&quot; color=&quot;red&quot; ] task2_run_a_time-&gt;guest_sched_module [ label=&quot;sched in TASK1&quot; color=&quot;red&quot; ] guest_sched_module-&gt;task1_access_a_memory [ label=&quot;sched in TASK1&quot; color=&quot;red&quot; ] task1_access_a_memory-&gt;access_memory_success [ label=&quot;page is present&quot; ] label=&quot;guest&quot; } trigger_EPT_violation-&gt;&quot;ept violation handle&quot; [ label=&quot;trap to HOST&quot; ] dont_do_slow_path-&gt;do_slow_path [ label=&quot;start a work&quot; ] have_get_page-&gt;guest_sched_module [ color=&quot;green&quot; ] let_guest_sched_out-&gt;guest_sched_module [ color=&quot;green&quot; ] get_user_page_fast_is_success-&gt;task1_access_a_memory [ label=&quot;Y, return to GUEST direct&quot; ]}Gcluster_hosthostcluster_host_dedicated_threaddedicated threadcluster_host_kvm_vcpu_threadhost kvm vcpu threadcluster_guestguestcluster_trigger_ept_violation_taskTASK1 trigger ept vioaltioncluster_sched_in_task2task2do_slow_pathI&#39;m a delicated thread, Like a special hardware, sharing the pressure of VCPUget_user_pages(slow path)get_user_pages(slow path)do_slow_path&#45;&gt;get_user_pages(slow path)have_get_pageget page, PAGE IS PRESENT!guest_sched_moduleguest sched modulehave_get_page&#45;&gt;guest_sched_moduleget_user_pages(slow path)&#45;&gt;have_get_pageept violation handleept violation handleget_user_page_fastget_user_pages() &#45;&#45; fast pathept violation handle&#45;&gt;get_user_page_fastget_user_page_fast_is_successget_user_page_fast SUCCESS ?get_user_page_fast&#45;&gt;get_user_page_fast_is_successdont_do_slow_pathI don&#39;t want handle slow path, it will speed to much timedont_do_slow_path&#45;&gt;do_slow_pathstart a worklet_guest_sched_outLet vcpu do other things rather than wait page presentdont_do_slow_path&#45;&gt;let_guest_sched_outget_user_page_fast_is_success&#45;&gt;dont_do_slow_pathN, seem to need do slow pathtask1_access_a_memoryacesss a memory address [BEG]get_user_page_fast_is_success&#45;&gt;task1_access_a_memoryY, return to GUEST directlet_guest_sched_out&#45;&gt;guest_sched_moduleaccess_memory_successaccess memory successtask1_access_a_memory&#45;&gt;access_memory_successpage is presenttrigger_EPT_violationtrigger EPT violationtask1_access_a_memory&#45;&gt;trigger_EPT_violationpage NOT presenttrigger_EPT_violation&#45;&gt;ept violation handletrap to HOSTtrigger_EPT_violation&#45;&gt;guest_sched_modulesched out TASK1task2_run_a_timetask2_run_a_timetask2_run_a_time&#45;&gt;guest_sched_modulesched in TASK1guest_sched_module&#45;&gt;task1_access_a_memorysched in TASK1guest_sched_module&#45;&gt;task2_run_a_timesched out TASK1由上图可见, 引入async pf 的逻辑是让其能够在触发 EPT violation后, 能够让VCPU 调度到另外一个task, 从而阻塞触发 EPT violation 的进程执行. 为了达到这一目的, 做了以下改动: VCPU 线程在执行get_user_page()时, 仅执行fast path, 如果page 不是present的, 该接口直接返回, 而剩下的工作, 则交给另外一个dedicated thread 去做 KVM 会通过一些方式, 让 GUEST 执行调度, 从而避免再次执行触发EPT violation的指令.具体方法有两种 : 对应于半虚拟化方式, 和非半虚拟化方式, 我们下面会分别讨论我们首先讨论非半虚拟化方式:非半虚拟化方式我们知道, 如果达到这一目的, 就必须让 GUEST 去 sched out 当前触发 EPT violation 的 tasks, 而非半虚拟化方式, 就是对 guest transparent, 所以, 又得要求guest 是靠自己当前的调度逻辑, 主动的schedule, KVM 很巧妙的利用了操作系统使用时钟中断进行调度, 来达到这一目的, 主要步骤如下:graphviz-f344c85124c6ea27b12ef8f7edc3307cdigraph G { subgraph cluster_host { style=&quot;filled&quot; color=&quot;#71324556&quot; subgraph cluster_host_vcpu_thread { get_user_page_fast [ label=&quot;get_user_pages() -- \\nfast path&quot; ] get_user_page_fast_is_success [ shape=&quot;diamond&quot; label=&quot;get_user_page_fast \\nSUCCESS ?&quot; ] halt_vcpu [ label=&quot;halt vcpu&quot; ] unhalt_vcpu_intr [ shape=&quot;record&quot; label=&quot;interrupt&quot; ] unhalt_vcpu_kick [ shape=&quot;record&quot; label=&quot;other KVM \\nproduce \\nkvm_vcpu_kick()&quot; ] unhalt_vcpu_and_re_VM_entry [ label=&quot;unhalt and VM entry&quot; ] unhalt_vcpu_and_inject_timer [ label=&quot;unhalt and inject a timer intr&quot; ] halt_vcpu-&gt;unhalt_vcpu_intr [ label = &quot;detect intr event, UNHALT&quot; ] halt_vcpu-&gt;unhalt_vcpu_kick [ label = &quot;detect vcpu kick event, UNHALT&quot; ] unhalt_vcpu_kick-&gt;unhalt_vcpu_and_re_VM_entry get_user_page_fast-&gt;get_user_page_fast_is_success unhalt_vcpu_intr-&gt;unhalt_vcpu_and_inject_timer get_user_page_fast_is_success-&gt;halt_vcpu [ label=N ] label=&quot;host kvm vcpu thread&quot; } subgraph cluster_host_dedicated_thread { get_user_page_slow_path [ label=&quot;get_user_pages(slow path)&quot; ] have_get_page [ label=&quot;get page, \\nPAGE IS PRESENT!&quot; ] get_user_page_slow_path-&gt;have_get_page label=&quot;dedicated thread&quot; } subgraph cluster_host_timer { inject_a_timer_interrupt [ label=&quot;inject a timer \\ninterrupt to GUEST&quot; ] &quot;receive a timer \\ninterrupt belong \\nto GUEST&quot;-&gt; inject_a_timer_interrupt-&gt; unhalt_vcpu_intr label=&quot;timer&quot; } label = &quot;host&quot; } subgraph cluster_guest { style=&quot;filled&quot; color=&quot;#12323456&quot; subgraph cluster_guest_task1 { task1_access_a_memory [ label=&quot;acesss a memory address [BEG]&quot; color=&quot;white&quot; style=&quot;filled&quot; ] trigger_EPT_violation [ label=&quot;trigger EPT violation&quot; ] task1_access_a_memory -&gt; trigger_EPT_violation [ label=&quot;page NOT present&quot; ] label=&quot;TASK1 trigger ept vioaltion&quot; } subgraph cluster_guest_task2 { } subgraph cluster_guest_schedule_model { timer_schedule_handler [ label=&quot;receive a timer \\ninterrupt, need schedule&quot; ] label=&quot;schedule module&quot; } label=&quot;guest&quot; } trigger_EPT_violation-&gt;get_user_page_fast unhalt_vcpu_and_inject_timer-&gt;timer_schedule_handler [ label=&quot;inject intr event&quot; ] have_get_page-&gt;unhalt_vcpu_kick unhalt_vcpu_and_re_VM_entry-&gt;task1_access_a_memory get_user_page_fast_is_success-&gt;get_user_page_slow_path [ label=&quot;N&quot; ]}Gcluster_hosthostcluster_host_vcpu_threadhost kvm vcpu threadcluster_host_dedicated_threaddedicated threadcluster_host_timertimercluster_guestguestcluster_guest_task1TASK1 trigger ept vioaltioncluster_guest_schedule_modelschedule moduleget_user_page_fastget_user_pages() &#45;&#45; fast pathget_user_page_fast_is_successget_user_page_fast SUCCESS ?get_user_page_fast&#45;&gt;get_user_page_fast_is_successhalt_vcpuhalt vcpuget_user_page_fast_is_success&#45;&gt;halt_vcpuNget_user_page_slow_pathget_user_pages(slow path)get_user_page_fast_is_success&#45;&gt;get_user_page_slow_pathNunhalt_vcpu_intrinterrupthalt_vcpu&#45;&gt;unhalt_vcpu_intrdetect intr event, UNHALTunhalt_vcpu_kickother KVM produce kvm_vcpu_kick()halt_vcpu&#45;&gt;unhalt_vcpu_kickdetect vcpu kick event, UNHALTunhalt_vcpu_and_inject_timerunhalt and inject a timer intrunhalt_vcpu_intr&#45;&gt;unhalt_vcpu_and_inject_timerunhalt_vcpu_and_re_VM_entryunhalt and VM entryunhalt_vcpu_kick&#45;&gt;unhalt_vcpu_and_re_VM_entrytask1_access_a_memoryacesss a memory address [BEG]unhalt_vcpu_and_re_VM_entry&#45;&gt;task1_access_a_memorytimer_schedule_handlerreceive &#160;a timer interrupt, need scheduleunhalt_vcpu_and_inject_timer&#45;&gt;timer_schedule_handlerinject intr eventhave_get_pageget page, PAGE IS PRESENT!get_user_page_slow_path&#45;&gt;have_get_pagehave_get_page&#45;&gt;unhalt_vcpu_kickinject_a_timer_interruptinject a timer interrupt to GUESTinject_a_timer_interrupt&#45;&gt;unhalt_vcpu_intrreceive a timer \\ninterrupt belong \\nto GUESTreceive a timer interrupt belong to GUESTreceive a timer \\ninterrupt belong \\nto GUEST&#45;&gt;inject_a_timer_interrupttrigger_EPT_violationtrigger EPT violationtask1_access_a_memory&#45;&gt;trigger_EPT_violationpage NOT presenttrigger_EPT_violation&#45;&gt;get_user_page_fast这里需要注意的是: 上面是以timer interrupt 举例, 如果收到不是timer interrupt, 该中断也会inject 到guest中, 只不过guest在处理完interrupt后,还会返回到之前的task, 在page 没有present的情况下, 还会触发 EPT violation(包括如果收到了timer interrupt, 但是并没有执行sched动作. 也是同样的情况). But so what ? 本来引入async pf 的目的, 就是让vcpu 能够去做些别的任务? schedule other task &amp;&amp; handle interrupt, 都可以让vcpu 继续运行, 和 get_user_page(slowpath) 并行运行. 该实现比较巧妙的时, 它对GUEST 完全透明, 当guest 触发async pf时, 当vcpu再次运行,无论是收到interrupt, 还是 async pf complete kick this vcpu, 对于guest而言, 就像是在触发异常指令之前的 instruction boundary执行了较长的时间(也就是触发异常的上一条指令)下面我们详细介绍下, PV async pf.PV async pf NOTE 我们思考下, 该方式看似就已经解决问题了,为什么还要搞一个半虚拟化的方式, 来使该流程便复杂,我们来看下该方式有何缺点: 场景1 vcpu_thread interrupt handler or work halt_vcpu kick vcpu unhalt vcpu_enter 可以看到在 halt_vcpu 之间, 到vcpu enter 之间, 有一个比较大的window, 如果能把 该window优化掉就好了 场景2 vcpu_thread_kvm host_intr_handler_or_work GUEST halt_vcpu kick_vcpu uhalt vcpu_enter sched out task1 sched in task1 page is NOT present trigger EPT violation vcpu_exit halt_vcpu 可以看到, 这里在vcpu enter后, 还有可能调度回 task1, 接着触发EPT violation, 如果page还没有present的话, 本次调度, 仍然会VM exit, 继续halt vcpu, 还会有场景1 中的较大的window. 所以通过上面两种场景看, 该方式的实现, 并不能做到与vcpu 与 get_user_page_slow_path做到完全平行.还是会在某些地方有block结合上述, 我们首先需要思考下, 半虚拟化的 async pf要达到一个什么样的目的: 尽量不去 halt vcpu, 让其能够在get_user_page_fast()没有成功的时候, 就可以VM-entry, 为了避免再次执行触发EPT violation的指令, 需要打破现有的执行流程, 并且执行调度. 而打破现有的执行流程, 无非是通过 INTERRUPT/EXCEPTION 能够让GUEST知道, 哪些task是因为async pf被调度走了, 避免再page没有present的情况下, 将这些task调度回来 而PV async pf, 就是多做了上面两件事." } ]
